{
  "v3.5.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "Build the translator (along with the model)",
    "Put messages sizes in antichronological order",
    "Caluculate antichronological history sizes",
    "Prune the history from the beginning",
    "Put back indices in chronological order.",
    "Build the translator (along with the model)",
    "We need to build the Llama tokenizer to count tokens and prune the history.",
    "The hypotheses are lists of one element but we still need to take the first one.",
    "#####",
    "UI #",
    "#####",
    "What are the 3 best french cities ?",
    "Which one is better if I like outdoor activities ?",
    "Which one is better if I like cultural outings?",
    "What are the best neighborhoods in these 5 cities?",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "flake8: noqa",
    "-*- coding: utf-8 -*-",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: sentencepiece_model.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(module_scope)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "if shard == 0:",
    "vocab_size = onmt_safetensor[\"generator.weight\"].size(0)",
    "vocab[11] = \"</s>\"  # Falcon only",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "from onmt.utils.misc import use_gpu",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "Falcon stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "print(batch)",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "!/usr/bin/env python",
    "redpajama stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "Avoid functionality on inference",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "If new training initialize the model params",
    "If update_vocab init also but checkpoint will overwrite old weights",
    "ONLY for legacy fusedam with amp pytorch requires NOT to half the model",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "after this checkpoint contains no embeddings",
    "when using LoRa or updating the vocab (no more embeddings in ckpt)",
    "=> strict=False when loading state_dict",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "!/usr/bin/env python",
    "maybe prepare pretrained embeddings, if any",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "GPU",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Create a thread to listen for errors in the child processes.",
    "Build translator",
    "Build vocab",
    "Build transform pipe",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "raw_srcs = []",
    "raw_refs = []",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "The loss of the prompt will be set to zero.",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Auto import python files in this directory",
    "batch x len x dim",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "Padding mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Help functions for Rotary Embeddings",
    "https://arxiv.org/pdf/2104.09864.pdf",
    "too convoluted to make maxseqlen a parameter.",
    "we suppose src_seq_len at training and max_length at inference",
    "are both < 2048 tokens.",
    "rope is now matrix [maxseqlen, dim/2]",
    "Help functions for max_relative positions",
    "https://arxiv.org/abs/1803.02155",
    "Shift values to be >= 0",
    "now relative_position is in the range [0, inf)",
    "half of the buckets are for exact increments in positions",
    "The other half of the buckets are for logarithmically bigger bins in positions",
    "up to max_distance",
    "Help functions to split model dim per head",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "Retrieve keys and values from the KV cache (decoding mode only).",
    "Resize rotary embeddings.",
    "Resize rotary embeddings.",
    "We take a margin of 32 tokens as the kv_cache",
    "is incremented by 32 tokens every 32 tokens.",
    "Increase the cached key pad mask by concatenation.",
    "For decoding only.",
    "Retrieve keys and values from linear layers (training mode).",
    "Resize rotary embeddings.",
    "expand key on heads dimension when it's less than query heads (multi-query variant)",
    "expand value on heads dimension when it's less than query heads (multi-query variant)",
    "2) When standard pos. enc. or rotary, use flash attention",
    "Ultimately flashv2 will be part of pytorch https://github.com/pytorch/pytorch/pull/105602",
    "In the meantime: if vanilla tranformer or Rotary embeddings (not rel_pos, not alibi)",
    "then use flash2 if seq len > 256 otherwise use xtransformer from pt2 uptream",
    "Apply flash2 attention.",
    "Apply scaled dot product attention.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "copied and adapted https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "Support bnb quantization of nderlying layers",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "we do not super().reset_parameters() save lot of time and useless when no grad.",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "cannot merge/unmerge quantized weigts with unquantized lora_X",
    "Check if QLoraLinear has a custom __init__ method",
    "Invoke the __init__ method of QLoraLinear",
    "LoRA implemented in a dense layer",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "for some reason list comprehension is slower in this scenario",
    "for silu, see: https://arxiv.org/pdf/2002.05202.pdf",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "Code taken from bitsandbytes but modified with arg device to accept skipt_init",
    "from torch.nn.utils => makes model building way faster.",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "We exclude tokenization for contractions in",
    "order to avoid inconsistencies with pyonmtok's tokenization.",
    "(e.g. \"I ca n't\" with spacy, \"I can ' t\" with pyonmttok)",
    "Use Spacy's stopwords to get rid of junk entries",
    "Perform tokenization with spacy for consistency.",
    "We ensure that the target lemma is present in the lemmatized",
    "target string, that the match is an exact match (there is",
    "whitespace before or after the term)",
    "and we perform some bound checking.",
    "Map the lemmatized string match index to",
    "the lemmatized list index",
    "We need to know if the term is multiword",
    "Join multiword target lemmas with a unique separator so",
    "we can treat them as single word and not change the indices.",
    "Construct the final source from the lemmatized list",
    "that contains the terms. We compare the tokens in the",
    "term-augmented lemma list with the tokens in the original",
    "lemma list. If the lemma is the same, then we replace with",
    "the token from the original tokenized source list. If they",
    "are not the same, it means the lemma has been augemented",
    "with a term, so we inject this in the final list.",
    "Restore the spaces in multi-word terms",
    "Skip half examples to improve performance. This means we set",
    "a hard limit for the `term_corpus_ratio` to 0.5, which is actually",
    "quite high. TODO: We can add this (skipping examples) as an option",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Create all possible tag forms. We inject a special",
    "unicode char (\u2225) as a placeholder for whitespace in order",
    "to keep the indices unaltered. This char is replaced with",
    "spaces before we return the augmented examples.",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "Skip half examples to speed up the transform. This sets",
    "a hard limit of 0.5 to the `tags_corpus_ratio`, which is",
    "excessive and should be avoided anyway.",
    "normalize dict src/tgt for each dataset",
    "print(\"src empty\")",
    "print(\"too many same char in src\")",
    "print(\"too many same word in src\")",
    "print(\"avg token min\", len(src_str) / len(ex['src']))",
    "print(\"avg token max\", len(src_str) / len(ex['src']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(src_str))",
    "print(\"src = tgt\")",
    "print(\"tgt empty\")",
    "print(\"src / tgt ratio \", len(src_str) / len(tgt_str))",
    "print(\"too many same char in tgt\")",
    "print(\"too many same word in tgt\")",
    "print(\"avg token min\", len(tgt_str) / len(ex['tgt']))",
    "print(\"avg token max\", len(tgt_str) / len(ex['tgt']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(tgt_str))",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "This method embeds a custom logic to correctly handle certain placeholders",
    "in case the tokenizer doesn't preserve them.",
    "Locate the end-of-sentence placeholders.",
    "Tokenize each sentence separately.",
    "Locate the mask-before placeholders",
    "(to zero-out the prompt loss during LM finetuning).",
    "Tokenize each chunk separately and insert the padding token.",
    "between each sequence of tokens.",
    "Re-insert the eos token.",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "ugly patch to make sure \"\\n\\n\" is split in two items",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "normalize dict src/tgt for each dataset",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Test mask location",
    "Test mask location",
    "Test mask location",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "Build the translator (along with the model)",
    "Required arguments",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Auto import python files in this directory",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "Add triangular future_mask and pad_mask, result mask in (B, T, T).",
    "Patch for scaled dot product attention.",
    "Only mask padding, result mask in (B, 1, T).",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "Masking is necessary when sequence length is greater than one",
    "The decoding has not started yet,",
    "we compute the scores on the source tokens in one shot.",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "decoding mode.",
    "Initialize KV and key_pad_mask cache.",
    "training mode.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "Create a mask with zeros at prompt positions and ones at answer postions.",
    "Apply the mask on the target side.",
    "Put the padding token index at the prompt positions.",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "########## #",
    "Translator #",
    "########## #",
    "Set \"default\" translation options on empty cfgfile",
    "Build translator from options",
    "################### #",
    "Validation iterator #",
    "################### #",
    "Reinstantiate the validation iterator",
    "transforms_cls = get_transforms_cls(model_opt._all_transform)",
    "Retrieve raw references and sources",
    "########### #",
    "Predictions #",
    "########### #",
    "####### #",
    "Outputs #",
    "####### #",
    "Flatten predictions",
    "Save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "single thread - create batch directly on GPU if device is gpu",
    "multithread faster to create batch on CPU in each thread and then move it to gpu",
    "Move tensor_batch from cpu to device",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "careful below it will return a bucket sorted by corpora",
    "but we sort by length later and shuffle batches",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'cid': corpus id",
    "'cid_line_number' : cid line number",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "this is hack: if the special separator \uff5fnewline\uff60is returned because of the",
    "\"docify\" transform.get_specials we don't add it if the corresponding newline code",
    "is already included in the sentencepiece or BPE-with-gpt2-pretok.",
    "Reached end of file",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "empty example: skip",
    "ugly patch because in_feat and out_feat are reversed in WQLinear_GEMM",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "This preserves backward-compat for models using customed layernorm",
    "Force add_ffnbias to True if bias found in model w_1 keys",
    "fix v2 compatibility",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "BPE training",
    "SentencePiece training",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "not 100% necessary to define those",
    "self.is_finished = torch.zeros(",
    "[self.batch_size, self.parallel_paths], dtype=torch.bool",
    ")",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "For seq2seq when we need to force doc to spit the same number of sents",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "beg_time = time()",
    "Reorder states.",
    "select indexes in model state/cache",
    "if step == 0:",
    "print(\"step0 time: \", time() - beg_time)",
    "beam parameters",
    "beam state",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "after this we get topk_ids between 0 and beam_size*vocab_size",
    "topk_ids // vocab_size => indice in beam",
    "topk_ids % vocab_size => true vocab indice",
    "using lists instead of tensors for topk_scores and is_finished make things faster",
    "Store finished hypotheses for this example in the batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "early stop when top beam is finished",
    "Penalize beams that finished.",
    "this is required to pursue finished beams in non finished batches",
    "If all sentences are translated, no need to go further.",
    "reset the selection for the next step",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction to reordered alive sequence",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "These comp lists are costy but less than for loops",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory",
    "contractions",
    "number separators",
    "punctuation",
    "double brackets",
    "miscellaneous",
    "Clean and Concat the dataset",
    "joiner = tokenizer._tokenize(\"\\n\")",
    "tokens += tokenizer._tokenize([x])",
    "Tokenize the dataset.",
    "Build the translator (along with the model.",
    "Score the dataset.",
    "zero out the context tokens",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "get prompt and make sure it fits",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "get prompt and make sure it fits"
  ],
  "v3.5.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "Build the translator (along with the model)",
    "Put messages sizes in antichronological order",
    "Caluculate antichronological history sizes",
    "Prune the history from the beginning",
    "Put back indices in chronological order.",
    "Build the translator (along with the model)",
    "We need to build the Llama tokenizer to count tokens and prune the history.",
    "The hypotheses are lists of one element but we still need to take the first one.",
    "#####",
    "UI #",
    "#####",
    "What are the 3 best french cities ?",
    "Which one is better if I like outdoor activities ?",
    "Which one is better if I like cultural outings?",
    "What are the best neighborhoods in these 5 cities?",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "flake8: noqa",
    "-*- coding: utf-8 -*-",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: sentencepiece_model.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(module_scope)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "if shard == 0:",
    "vocab_size = onmt_safetensor[\"generator.weight\"].size(0)",
    "vocab[11] = \"</s>\"  # Falcon only",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "from onmt.utils.misc import use_gpu",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "Falcon stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "print(batch)",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "!/usr/bin/env python",
    "redpajama stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "Avoid functionality on inference",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "If new training initialize the model params",
    "If update_vocab init also but checkpoint will overwrite old weights",
    "ONLY for legacy fusedam with amp pytorch requires NOT to half the model",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "after this checkpoint contains no embeddings",
    "when using LoRa or updating the vocab (no more embeddings in ckpt)",
    "=> strict=False when loading state_dict",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "GPU",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Create a thread to listen for errors in the child processes.",
    "Build translator",
    "Build vocab",
    "Build transform pipe",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "raw_srcs = []",
    "raw_refs = []",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "The loss of the prompt will be set to zero.",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Auto import python files in this directory",
    "batch x len x dim",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "Padding mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Help functions for Rotary Embeddings",
    "https://arxiv.org/pdf/2104.09864.pdf",
    "too convoluted to make maxseqlen a parameter.",
    "we suppose src_seq_len at training and max_length at inference",
    "are both < 2048 tokens.",
    "rope is now matrix [maxseqlen, dim/2]",
    "Help functions for max_relative positions",
    "https://arxiv.org/abs/1803.02155",
    "Shift values to be >= 0",
    "now relative_position is in the range [0, inf)",
    "half of the buckets are for exact increments in positions",
    "The other half of the buckets are for logarithmically bigger bins in positions",
    "up to max_distance",
    "Help functions to split model dim per head",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "Retrieve keys and values from the KV cache (decoding mode only).",
    "Resize rotary embeddings.",
    "Resize rotary embeddings.",
    "We take a margin of 32 tokens as the kv_cache",
    "is incremented by 32 tokens every 32 tokens.",
    "Increase the cached key pad mask by concatenation.",
    "For decoding only.",
    "Retrieve keys and values from linear layers (training mode).",
    "Resize rotary embeddings.",
    "expand key on heads dimension when it's less than query heads (multi-query variant)",
    "expand value on heads dimension when it's less than query heads (multi-query variant)",
    "2) When standard pos. enc. or rotary, use flash attention",
    "Ultimately flashv2 will be part of pytorch https://github.com/pytorch/pytorch/pull/105602",
    "In the meantime: if vanilla tranformer or Rotary embeddings (not rel_pos, not alibi)",
    "then use flash2 if seq len > 256 otherwise use xtransformer from pt2 uptream",
    "Apply flash2 attention.",
    "Apply scaled dot product attention.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "copied and adapted https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "Support bnb quantization of nderlying layers",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "we do not super().reset_parameters() save lot of time and useless when no grad.",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "cannot merge/unmerge quantized weigts with unquantized lora_X",
    "Check if QLoraLinear has a custom __init__ method",
    "Invoke the __init__ method of QLoraLinear",
    "LoRA implemented in a dense layer",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "for some reason list comprehension is slower in this scenario",
    "for silu, see: https://arxiv.org/pdf/2002.05202.pdf",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "Code taken from bitsandbytes but modified with arg device to accept skipt_init",
    "from torch.nn.utils => makes model building way faster.",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "We exclude tokenization for contractions in",
    "order to avoid inconsistencies with pyonmtok's tokenization.",
    "(e.g. \"I ca n't\" with spacy, \"I can ' t\" with pyonmttok)",
    "Use Spacy's stopwords to get rid of junk entries",
    "Perform tokenization with spacy for consistency.",
    "We ensure that the target lemma is present in the lemmatized",
    "target string, that the match is an exact match (there is",
    "whitespace before or after the term)",
    "and we perform some bound checking.",
    "Map the lemmatized string match index to",
    "the lemmatized list index",
    "We need to know if the term is multiword",
    "Join multiword target lemmas with a unique separator so",
    "we can treat them as single word and not change the indices.",
    "Construct the final source from the lemmatized list",
    "that contains the terms. We compare the tokens in the",
    "term-augmented lemma list with the tokens in the original",
    "lemma list. If the lemma is the same, then we replace with",
    "the token from the original tokenized source list. If they",
    "are not the same, it means the lemma has been augemented",
    "with a term, so we inject this in the final list.",
    "Restore the spaces in multi-word terms",
    "Skip half examples to improve performance. This means we set",
    "a hard limit for the `term_corpus_ratio` to 0.5, which is actually",
    "quite high. TODO: We can add this (skipping examples) as an option",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Create all possible tag forms. We inject a special",
    "unicode char (\u2225) as a placeholder for whitespace in order",
    "to keep the indices unaltered. This char is replaced with",
    "spaces before we return the augmented examples.",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "Skip half examples to speed up the transform. This sets",
    "a hard limit of 0.5 to the `tags_corpus_ratio`, which is",
    "excessive and should be avoided anyway.",
    "normalize dict src/tgt for each dataset",
    "print(\"src empty\")",
    "print(\"too many same char in src\")",
    "print(\"too many same word in src\")",
    "print(\"avg token min\", len(src_str) / len(ex['src']))",
    "print(\"avg token max\", len(src_str) / len(ex['src']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(src_str))",
    "print(\"src = tgt\")",
    "print(\"tgt empty\")",
    "print(\"src / tgt ratio \", len(src_str) / len(tgt_str))",
    "print(\"too many same char in tgt\")",
    "print(\"too many same word in tgt\")",
    "print(\"avg token min\", len(tgt_str) / len(ex['tgt']))",
    "print(\"avg token max\", len(tgt_str) / len(ex['tgt']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(tgt_str))",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "This method embeds a custom logic to correctly handle certain placeholders",
    "in case the tokenizer doesn't preserve them.",
    "Locate the end-of-sentence placeholders.",
    "Tokenize each sentence separately.",
    "Locate the mask-before placeholders",
    "(to zero-out the prompt loss during LM finetuning).",
    "Tokenize each chunk separately and insert the padding token.",
    "between each sequence of tokens.",
    "Re-insert the eos token.",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "ugly patch to make sure \"\\n\\n\" is split in two items",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "normalize dict src/tgt for each dataset",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Test mask location",
    "Test mask location",
    "Test mask location",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "Build the translator (along with the model)",
    "Required arguments",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Auto import python files in this directory",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "Add triangular future_mask and pad_mask, result mask in (B, T, T).",
    "Patch for scaled dot product attention.",
    "Only mask padding, result mask in (B, 1, T).",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "Masking is necessary when sequence length is greater than one",
    "The decoding has not started yet,",
    "we compute the scores on the source tokens in one shot.",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "decoding mode.",
    "Initialize KV and key_pad_mask cache.",
    "training mode.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "Create a mask with zeros at prompt positions and ones at answer postions.",
    "Apply the mask on the target side.",
    "Put the padding token index at the prompt positions.",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "########## #",
    "Translator #",
    "########## #",
    "Set \"default\" translation options on empty cfgfile",
    "Build translator from options",
    "################### #",
    "Validation iterator #",
    "################### #",
    "Reinstantiate the validation iterator",
    "Retrieve raw references and sources",
    "########### #",
    "Predictions #",
    "########### #",
    "####### #",
    "Outputs #",
    "####### #",
    "Flatten predictions",
    "Save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "single thread - create batch directly on GPU if device is gpu",
    "multithread faster to create batch on CPU in each thread and then move it to gpu",
    "Move tensor_batch from cpu to device",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "careful below it will return a bucket sorted by corpora",
    "but we sort by length later and shuffle batches",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'cid': corpus id",
    "'cid_line_number' : cid line number",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "this is hack: if the special separator \uff5fnewline\uff60is returned because of the",
    "\"docify\" transform.get_specials we don't add it if the corresponding newline code",
    "is already included in the sentencepiece or BPE-with-gpt2-pretok.",
    "Reached end of file",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "empty example: skip",
    "ugly patch because in_feat and out_feat are reversed in WQLinear_GEMM",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "This preserves backward-compat for models using customed layernorm",
    "Force add_ffnbias to True if bias found in model w_1 keys",
    "fix v2 compatibility",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "BPE training",
    "SentencePiece training",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "not 100% necessary to define those",
    "self.is_finished = torch.zeros(",
    "[self.batch_size, self.parallel_paths], dtype=torch.bool",
    ")",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "For seq2seq when we need to force doc to spit the same number of sents",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "beg_time = time()",
    "Reorder states.",
    "select indexes in model state/cache",
    "if step == 0:",
    "print(\"step0 time: \", time() - beg_time)",
    "beam parameters",
    "beam state",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "after this we get topk_ids between 0 and beam_size*vocab_size",
    "topk_ids // vocab_size => indice in beam",
    "topk_ids % vocab_size => true vocab indice",
    "using lists instead of tensors for topk_scores and is_finished make things faster",
    "Store finished hypotheses for this example in the batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "early stop when top beam is finished",
    "Penalize beams that finished.",
    "this is required to pursue finished beams in non finished batches",
    "If all sentences are translated, no need to go further.",
    "reset the selection for the next step",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction to reordered alive sequence",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "These comp lists are costy but less than for loops",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory",
    "contractions",
    "number separators",
    "punctuation",
    "double brackets",
    "miscellaneous",
    "Clean and Concat the dataset",
    "joiner = tokenizer._tokenize(\"\\n\")",
    "tokens += tokenizer._tokenize([x])",
    "Tokenize the dataset.",
    "Build the translator (along with the model.",
    "Score the dataset.",
    "zero out the context tokens",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "get prompt and make sure it fits",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "get prompt and make sure it fits"
  ],
  "v3.4.3": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "Build the translator (along with the model)",
    "Put messages sizes in antichronological order",
    "Caluculate antichronological history sizes",
    "Prune the history from the beginning",
    "Put back indices in chronological order.",
    "Build the translator (along with the model)",
    "We need to build the Llama tokenizer to count tokens and prune the history.",
    "The hypotheses are lists of one element but we still need to take the first one.",
    "#####",
    "UI #",
    "#####",
    "What are the 3 best french cities ?",
    "Which one is better if I like outdoor activities ?",
    "Which one is better if I like cultural outings?",
    "What are the best neighborhoods in these 5 cities?",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "flake8: noqa",
    "-*- coding: utf-8 -*-",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: sentencepiece_model.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(module_scope)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "from onmt.utils.misc import use_gpu",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "Falcon stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "!/usr/bin/env python",
    "redpajama stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "Avoid functionality on inference",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "If new training initialize the model params",
    "If update_vocab init also but checkpoint will overwrite old weights",
    "ONLY for legacy fusedam with amp pytorch requires NOT to half the model",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "after this checkpoint contains no embeddings",
    "when using LoRa or updating the vocab (no more embeddings in ckpt)",
    "=> strict=False when loading state_dict",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "GPU",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Create a thread to listen for errors in the child processes.",
    "Build translator",
    "Build vocab",
    "Build transform pipe",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "raw_srcs = []",
    "raw_refs = []",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "The loss of the prompt will be set to zero.",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Auto import python files in this directory",
    "batch x len x dim",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "Padding mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Help functions for Rotary Embeddings",
    "https://arxiv.org/pdf/2104.09864.pdf",
    "too convoluted to make maxseqlen a parameter.",
    "we suppose src_seq_len at training and max_length at inference",
    "are both < 2048 tokens.",
    "rope is now matrix [maxseqlen, dim/2]",
    "Help functions for max_relative positions",
    "https://arxiv.org/abs/1803.02155",
    "Shift values to be >= 0",
    "now relative_position is in the range [0, inf)",
    "half of the buckets are for exact increments in positions",
    "The other half of the buckets are for logarithmically bigger bins in positions",
    "up to max_distance",
    "Help functions to split model dim per head",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "expand key on heads dimension when it's less than query heads (multi-query variant)",
    "expand value on heads dimension when it's less than query heads (multi-query variant)",
    "2) When standard pos. enc. or rotary, use flash attention",
    "Ultimately flashv2 will be part of pytorch https://github.com/pytorch/pytorch/pull/105602",
    "In the meantime: if vanilla tranformer or Rotary embeddings (not rel_pos, not alibi)",
    "then use flash2 if seq len > 256 otherwise use xtransformer from pt2 uptream",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "copied and adapted https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "Support bnb quantization of nderlying layers",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "we do not super().reset_parameters() save lot of time and useless when no grad.",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "cannot merge/unmerge quantized weigts with unquantized lora_X",
    "Check if QLoraLinear has a custom __init__ method",
    "Invoke the __init__ method of QLoraLinear",
    "LoRA implemented in a dense layer",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "for some reason list comprehension is slower in this scenario",
    "for silu, see: https://arxiv.org/pdf/2002.05202.pdf",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "Code taken from bitsandbytes but modified with arg device to accept skipt_init",
    "from torch.nn.utils => makes model building way faster.",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "reorder weight layout back from ampere/turing to row",
    "we only need to save SCB as extra data, because CB for quantized weights",
    "is already stored in weight.data",
    "case 1: .cuda was called, SCB is in self.weight",
    "case 2: self.init_8bit_state was called, SCB is in self.state",
    "buffers not yet initialized, can't call them directly without",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "we converted 8-bit row major to turing/ampere format in the first inference pass",
    "we no longer need the row-major weight",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "We exclude tokenization for contractions in",
    "order to avoid inconsistencies with pyonmtok's tokenization.",
    "(e.g. \"I ca n't\" with spacy, \"I can ' t\" with pyonmttok)",
    "Use Spacy's stopwords to get rid of junk entries",
    "Perform tokenization with spacy for consistency.",
    "We ensure that the target lemma is present in the lemmatized",
    "target string, that the match is an exact match (there is",
    "whitespace before or after the term)",
    "and we perform some bound checking.",
    "Map the lemmatized string match index to",
    "the lemmatized list index",
    "We need to know if the term is multiword",
    "Join multiword target lemmas with a unique separator so",
    "we can treat them as single word and not change the indices.",
    "Construct the final source from the lemmatized list",
    "that contains the terms. We compare the tokens in the",
    "term-augmented lemma list with the tokens in the original",
    "lemma list. If the lemma is the same, then we replace with",
    "the token from the original tokenized source list. If they",
    "are not the same, it means the lemma has been augemented",
    "with a term, so we inject this in the final list.",
    "Restore the spaces in multi-word terms",
    "Skip half examples to improve performance. This means we set",
    "a hard limit for the `term_corpus_ratio` to 0.5, which is actually",
    "quite high. TODO: We can add this (skipping examples) as an option",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Create all possible tag forms. We inject a special",
    "unicode char (\u2225) as a placeholder for whitespace in order",
    "to keep the indices unaltered. This char is replaced with",
    "spaces before we return the augmented examples.",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "Skip half examples to speed up the transform. This sets",
    "a hard limit of 0.5 to the `tags_corpus_ratio`, which is",
    "excessive and should be avoided anyway.",
    "normalize dict src/tgt for each dataset",
    "print(\"src empty\")",
    "print(\"too many same char in src\")",
    "print(\"too many same word in src\")",
    "print(\"avg token min\", len(src_str) / len(ex['src']))",
    "print(\"avg token max\", len(src_str) / len(ex['src']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(src_str))",
    "print(\"src = tgt\")",
    "print(\"tgt empty\")",
    "print(\"src / tgt ratio \", len(src_str) / len(tgt_str))",
    "print(\"too many same char in tgt\")",
    "print(\"too many same word in tgt\")",
    "print(\"avg token min\", len(tgt_str) / len(ex['tgt']))",
    "print(\"avg token max\", len(tgt_str) / len(ex['tgt']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(tgt_str))",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "This method embeds a custom logic to correctly handle certain placeholders",
    "in case the tokenizer doesn't preserve them.",
    "Locate the end-of-sentence placeholders.",
    "Tokenize each sentence separately.",
    "Locate the mask-before placeholders",
    "(to zero-out the prompt loss during LM finetuning).",
    "Tokenize each chunk separately and insert the padding token.",
    "between each sequence of tokens.",
    "Re-insert the eos token.",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "normalize dict src/tgt for each dataset",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Test mask location",
    "Test mask location",
    "Test mask location",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "Build the translator (along with the model)",
    "Required arguments",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Auto import python files in this directory",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "Create a mask with zeros at prompt positions and ones at answer postions.",
    "Apply the mask on the target side.",
    "Put the padding token index at the prompt positions.",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "########## #",
    "Translator #",
    "########## #",
    "Set translation options",
    "Build translator from options",
    "################### #",
    "Validation iterator #",
    "################### #",
    "Reinstantiate the validation iterator",
    "Retrieve raw references and sources",
    "########### #",
    "Predictions #",
    "########### #",
    "####### #",
    "Outputs #",
    "####### #",
    "Flatten predictions",
    "Save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "single thread - create batch directly on GPU if device is gpu",
    "multithread faster to create batch on CPU in each thread and then move it to gpu",
    "Move tensor_batch from cpu to device",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "careful below it will return a bucket sorted by corpora",
    "but we sort by length later and shuffle batches",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'cid': corpus id",
    "'cid_line_number' : cid line number",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "this is hack: if the special separator \uff5fnewline\uff60is returned because of the",
    "\"docify\" transform.get_specials we don't add it if the corresponding newline code",
    "is already included in the sentencepiece or BPE-with-gpt2-pretok.",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "empty example: skip",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "This preserves backward-compat for models using customed layernorm",
    "Force add_ffnbias to True if bias found in model w_1 keys",
    "fix v2 compatibility",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "BPE training",
    "SentencePiece training",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "not 100% necessary to define those",
    "self.is_finished = torch.zeros(",
    "[self.batch_size, self.parallel_paths], dtype=torch.bool",
    ")",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "For seq2seq when we need to force doc to spit the same number of sents",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "after this we get topk_ids between 0 and beam_size*vocab_size",
    "topk_ids // vocab_size => indice in beam",
    "topk_ids % vocab_size => true vocab indice",
    "Store finished hypotheses for this example in the batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "early stop when top beam is finished",
    "Penalize beams that finished.",
    "this is required to pursue finished beams in non finished batches",
    "If all sentences are translated, no need to go further.",
    "reset the selection for the next step",
    "assert torch.equal(",
    "self.src_len[self.select_indices],",
    "self.src_len.view(_B_old, self.beam_size)[non_finished].view(",
    "_B_new * self.beam_size",
    "),",
    ")",
    "Remove finished batches for the next step.",
    "here we combine two slections in one",
    "self.topk_log_probs = self.topk_log_probs[non_finished]",
    "self._batch_index = self._batch_index.index_select(0, non_finished)",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction to reordered alive sequence",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "These comp lists are costy but less than for loops",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "get prompt and make sure it fits",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "get prompt and make sure it fits"
  ],
  "v3.4.2": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "Build the translator (along with the model)",
    "Put messages sizes in antichronological order",
    "Caluculate antichronological history sizes",
    "Prune the history from the beginning",
    "Put back indices in chronological order.",
    "Build the translator (along with the model)",
    "We need to build the Llama tokenizer to count tokens and prune the history.",
    "The hypotheses are lists of one element but we still need to take the first one.",
    "#####",
    "UI #",
    "#####",
    "What are the 3 best french cities ?",
    "Which one is better if I like outdoor activities ?",
    "Which one is better if I like cultural outings?",
    "What are the best neighborhoods in these 5 cities?",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "flake8: noqa",
    "-*- coding: utf-8 -*-",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: sentencepiece_model.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(module_scope)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "from onmt.utils.misc import use_gpu",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "Falcon stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "!/usr/bin/env python",
    "redpajama stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "Avoid functionality on inference",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "If new training initialize the model params",
    "If update_vocab init also but checkpoint will overwrite old weights",
    "ONLY for legacy fusedam with amp pytorch requires NOT to half the model",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "after this checkpoint contains no embeddings",
    "when using LoRa or updating the vocab (no more embeddings in ckpt)",
    "=> strict=False when loading state_dict",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "GPU",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Create a thread to listen for errors in the child processes.",
    "Build translator",
    "Build vocab",
    "Build transform pipe",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "raw_srcs = []",
    "raw_refs = []",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "The loss of the prompt will be set to zero.",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Auto import python files in this directory",
    "batch x len x dim",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Help functions for Rotary Embeddings",
    "https://arxiv.org/pdf/2104.09864.pdf",
    "too convoluted to make maxseqlen a parameter.",
    "we suppose src_seq_len at training and max_length at inference",
    "are both < 2048 tokens.",
    "rope is now matrix [maxseqlen, dim/2]",
    "Help functions for max_relative positions",
    "https://arxiv.org/abs/1803.02155",
    "Shift values to be >= 0",
    "now relative_position is in the range [0, inf)",
    "half of the buckets are for exact increments in positions",
    "The other half of the buckets are for logarithmically bigger bins in positions",
    "up to max_distance",
    "Help functions to split model dim per head",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "expand key on heads dimension when it's less than query heads (multi-query variant)",
    "expand value on heads dimension when it's less than query heads (multi-query variant)",
    "2) When standard pos. enc. or rotary, use flash attention",
    "Ultimately flashv2 will be part of pytorch https://github.com/pytorch/pytorch/pull/105602",
    "In the meantime: if vanilla tranformer or Rotary embeddings (not rel_pos, not alibi)",
    "then use flash2 if seq len > 256 otherwise use xtransformer from pt2 uptream",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "copied and adapted https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "Support bnb quantization of nderlying layers",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "we do not super().reset_parameters() save lot of time and useless when no grad.",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "cannot merge/unmerge quantized weigts with unquantized lora_X",
    "Check if QLoraLinear has a custom __init__ method",
    "Invoke the __init__ method of QLoraLinear",
    "LoRA implemented in a dense layer",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "for some reason list comprehension is slower in this scenario",
    "for silu, see: https://arxiv.org/pdf/2002.05202.pdf",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "Code taken from bitsandbytes but modified with arg device to accept skipt_init",
    "from torch.nn.utils => makes model building way faster.",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "reorder weight layout back from ampere/turing to row",
    "we only need to save SCB as extra data, because CB for quantized weights",
    "is already stored in weight.data",
    "case 1: .cuda was called, SCB is in self.weight",
    "case 2: self.init_8bit_state was called, SCB is in self.state",
    "buffers not yet initialized, can't call them directly without",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "we converted 8-bit row major to turing/ampere format in the first inference pass",
    "we no longer need the row-major weight",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "We exclude tokenization for contractions in",
    "order to avoid inconsistencies with pyonmtok's tokenization.",
    "(e.g. \"I ca n't\" with spacy, \"I can ' t\" with pyonmttok)",
    "Use Spacy's stopwords to get rid of junk entries",
    "Perform tokenization with spacy for consistency.",
    "We ensure that the target lemma is present in the lemmatized",
    "target string, that the match is an exact match (there is",
    "whitespace before or after the term)",
    "and we perform some bound checking.",
    "Map the lemmatized string match index to",
    "the lemmatized list index",
    "We need to know if the term is multiword",
    "Join multiword target lemmas with a unique separator so",
    "we can treat them as single word and not change the indices.",
    "Construct the final source from the lemmatized list",
    "that contains the terms. We compare the tokens in the",
    "term-augmented lemma list with the tokens in the original",
    "lemma list. If the lemma is the same, then we replace with",
    "the token from the original tokenized source list. If they",
    "are not the same, it means the lemma has been augemented",
    "with a term, so we inject this in the final list.",
    "Restore the spaces in multi-word terms",
    "Skip half examples to improve performance. This means we set",
    "a hard limit for the `term_corpus_ratio` to 0.5, which is actually",
    "quite high. TODO: We can add this (skipping examples) as an option",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Create all possible tag forms. We inject a special",
    "unicode char (\u2225) as a placeholder for whitespace in order",
    "to keep the indices unaltered. This char is replaced with",
    "spaces before we return the augmented examples.",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "Skip half examples to speed up the transform. This sets",
    "a hard limit of 0.5 to the `tags_corpus_ratio`, which is",
    "excessive and should be avoided anyway.",
    "normalize dict src/tgt for each dataset",
    "print(\"src empty\")",
    "print(\"too many same char in src\")",
    "print(\"too many same word in src\")",
    "print(\"avg token min\", len(src_str) / len(ex['src']))",
    "print(\"avg token max\", len(src_str) / len(ex['src']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(src_str))",
    "print(\"src = tgt\")",
    "print(\"tgt empty\")",
    "print(\"src / tgt ratio \", len(src_str) / len(tgt_str))",
    "print(\"too many same char in tgt\")",
    "print(\"too many same word in tgt\")",
    "print(\"avg token min\", len(tgt_str) / len(ex['tgt']))",
    "print(\"avg token max\", len(tgt_str) / len(ex['tgt']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(tgt_str))",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "This method embeds a custom logic to correctly handle certain placeholders",
    "in case the tokenizer doesn't preserve them.",
    "Locate the end-of-sentence placeholders.",
    "Tokenize each sentence separately.",
    "Locate the mask-before placeholders",
    "(to zero-out the prompt loss during LM finetuning).",
    "Tokenize each chunk separately and insert the padding token.",
    "between each sequence of tokens.",
    "Re-insert the eos token.",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "normalize dict src/tgt for each dataset",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Test mask location",
    "Test mask location",
    "Test mask location",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "Build the translator (along with the model)",
    "Required arguments",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Auto import python files in this directory",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "Create a mask with zeros at prompt positions and ones at answer postions.",
    "Apply the mask on the target side.",
    "Put the padding token index at the prompt positions.",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "########## #",
    "Translator #",
    "########## #",
    "Set translation options",
    "Build translator from options",
    "################### #",
    "Validation iterator #",
    "################### #",
    "Reinstantiate the validation iterator",
    "Retrieve raw references and sources",
    "########### #",
    "Predictions #",
    "########### #",
    "####### #",
    "Outputs #",
    "####### #",
    "Flatten predictions",
    "Save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "single thread - create batch directly on GPU if device is gpu",
    "multithread faster to create batch on CPU in each thread and then move it to gpu",
    "Move tensor_batch from cpu to device",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "this is hack: if the special separator \uff5fnewline\uff60is returned because of the",
    "\"docify\" transform.get_specials we don't add it if the corresponding newline code",
    "is already included in the sentencepiece or BPE-with-gpt2-pretok.",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "This preserves backward-compat for models using customed layernorm",
    "Force add_ffnbias to True if bias found in model w_1 keys",
    "fix v2 compatibility",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "BPE training",
    "SentencePiece training",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "For seq2seq when we need to force doc to spit the same number of sents",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "These comp lists are costy but less than for loops",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "get prompt and make sure it fits",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "get prompt and make sure it fits"
  ],
  "v3.4.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "inf_type = \"ct2\"",
    "#####################",
    "Inference with CT2 #",
    "#####################",
    "#####################",
    "Inference with -py #",
    "#####################",
    "ckpt_path = \"finetuned_llama7B/llama7B-vicuna-onmt_step_4000.pt\"",
    "we receive a text box content",
    "might be good to split also based on full period (later)",
    "we reformat the transformed batch to be numericalized / tensorified",
    "#####",
    "UI #",
    "#####",
    "What are the 3 best french cities ?",
    "Which one is better if I like outdoor activities ?",
    "Which one is better if I like cultural outings?",
    "What are the best neighborhoods in these 5 cities?",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "flake8: noqa",
    "-*- coding: utf-8 -*-",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: sentencepiece_model.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(module_scope)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "from onmt.utils.misc import use_gpu",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "Falcon stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "!/usr/bin/env python",
    "redpajama stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "Avoid functionality on inference",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "If new training initialize the model params",
    "If update_vocab init also but checkpoint will overwrite old weights",
    "ONLY for legacy fusedam with amp pytorch requires NOT to half the model",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "after this checkpoint contains no embeddings",
    "when using LoRa or updating the vocab (no more embeddings in ckpt)",
    "=> strict=False when loading state_dict",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "GPU",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Create a thread to listen for errors in the child processes.",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "raw_srcs = []",
    "raw_refs = []",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "The loss of the prompt will be set to zero.",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Auto import python files in this directory",
    "batch x len x dim",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Help functions for Rotary Embeddings",
    "https://arxiv.org/pdf/2104.09864.pdf",
    "too convoluted to make maxseqlen a parameter.",
    "we suppose src_seq_len at training and max_length at inference",
    "are both < 2048 tokens.",
    "rope is now matrix [maxseqlen, dim/2]",
    "Help functions for max_relative positions",
    "https://arxiv.org/abs/1803.02155",
    "Shift values to be >= 0",
    "now relative_position is in the range [0, inf)",
    "half of the buckets are for exact increments in positions",
    "The other half of the buckets are for logarithmically bigger bins in positions",
    "up to max_distance",
    "Help functions to split model dim per head",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "expand key on heads dimension when it's less than query heads (multi-query variant)",
    "expand value on heads dimension when it's less than query heads (multi-query variant)",
    "2) When standard pos. enc. or rotary, use flash attention",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "copied and adapted https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "Support bnb quantization of nderlying layers",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "we do not super().reset_parameters() save lot of time and useless when no grad.",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "cannot merge/unmerge quantized weigts with unquantized lora_X",
    "Check if QLoraLinear has a custom __init__ method",
    "Invoke the __init__ method of QLoraLinear",
    "LoRA implemented in a dense layer",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "for silu, see: https://arxiv.org/pdf/2002.05202.pdf",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "Code taken from bitsandbytes but modified with arg device to accept skipt_init",
    "from torch.nn.utils => makes model building way faster.",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "reorder weight layout back from ampere/turing to row",
    "we only need to save SCB as extra data, because CB for quantized weights",
    "is already stored in weight.data",
    "case 1: .cuda was called, SCB is in self.weight",
    "case 2: self.init_8bit_state was called, SCB is in self.state",
    "buffers not yet initialized, can't call them directly without",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "we converted 8-bit row major to turing/ampere format in the first inference pass",
    "we no longer need the row-major weight",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "We exclude tokenization for contractions in",
    "order to avoid inconsistencies with pyonmtok's tokenization.",
    "(e.g. \"I ca n't\" with spacy, \"I can ' t\" with pyonmttok)",
    "Use Spacy's stopwords to get rid of junk entries",
    "Perform tokenization with spacy for consistency.",
    "We ensure that the target lemma is present in the lemmatized",
    "target string, that the match is an exact match (there is",
    "whitespace before or after the term)",
    "and we perform some bound checking.",
    "Map the lemmatized string match index to",
    "the lemmatized list index",
    "We need to know if the term is multiword",
    "Join multiword target lemmas with a unique separator so",
    "we can treat them as single word and not change the indices.",
    "Construct the final source from the lemmatized list",
    "that contains the terms. We compare the tokens in the",
    "term-augmented lemma list with the tokens in the original",
    "lemma list. If the lemma is the same, then we replace with",
    "the token from the original tokenized source list. If they",
    "are not the same, it means the lemma has been augemented",
    "with a term, so we inject this in the final list.",
    "Restore the spaces in multi-word terms",
    "Skip half examples to improve performance. This means we set",
    "a hard limit for the `term_corpus_ratio` to 0.5, which is actually",
    "quite high. TODO: We can add this (skipping examples) as an option",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Create all possible tag forms. We inject a special",
    "unicode char (\u2225) as a placeholder for whitespace in order",
    "to keep the indices unaltered. This char is replaced with",
    "spaces before we return the augmented examples.",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "Skip half examples to speed up the transform. This sets",
    "a hard limit of 0.5 to the `tags_corpus_ratio`, which is",
    "excessive and should be avoided anyway.",
    "normalize dict src/tgt for each dataset",
    "print(\"src empty\")",
    "print(\"too many same char in src\")",
    "print(\"too many same word in src\")",
    "print(\"avg token min\", len(src_str) / len(ex['src']))",
    "print(\"avg token max\", len(src_str) / len(ex['src']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(src_str))",
    "print(\"src = tgt\")",
    "print(\"tgt empty\")",
    "print(\"src / tgt ratio \", len(src_str) / len(tgt_str))",
    "print(\"too many same char in tgt\")",
    "print(\"too many same word in tgt\")",
    "print(\"avg token min\", len(tgt_str) / len(ex['tgt']))",
    "print(\"avg token max\", len(tgt_str) / len(ex['tgt']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(tgt_str))",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "This method embeds a custom logic to correctly handle certain placeholders",
    "in case the tokenizer doesn't preserve them.",
    "Locate the end-of-sentence placeholders.",
    "Tokenize each sentence separately.",
    "Locate the mask-before placeholders",
    "(to zero-out the prompt loss during LM finetuning).",
    "Tokenize each chunk separately and insert the padding token.",
    "between each sequence of tokens.",
    "Re-insert the eos token.",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "normalize dict src/tgt for each dataset",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Test mask location",
    "Test mask location",
    "Test mask location",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Auto import python files in this directory",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "Create a mask with zeros at prompt positions and ones at answer postions.",
    "Apply the mask on the target side.",
    "Put the padding token index at the prompt positions.",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "########## #",
    "Translator #",
    "########## #",
    "Set translation options",
    "Build translator from options",
    "################### #",
    "Validation iterator #",
    "################### #",
    "Reinstantiate the validation iterator",
    "Retrieve raw references and sources",
    "########### #",
    "Predictions #",
    "########### #",
    "####### #",
    "Outputs #",
    "####### #",
    "Flatten predictions",
    "Save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "temporary as long as translation_server and scoring_preparator still use lists",
    "this is hack: if the special separator \uff5fnewline\uff60is returned because of the",
    "\"docify\" transform.get_specials we don't add it if the corresponding newline code",
    "is already included in the sentencepiece or BPE-with-gpt2-pretok.",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "This preserves backward-compat for models using customed layernorm",
    "Force add_ffnbias to True if bias found in model w_1 keys",
    "fix v2 compatibility",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "BPE training",
    "SentencePiece training",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "get prompt and make sure it fits",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "Build the transforms (along with the tokenizer)",
    "get prompt and make sure it fits"
  ],
  "v3.4.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "inf_type = \"ct2\"",
    "#####################",
    "Inference with CT2 #",
    "#####################",
    "#####################",
    "Inference with -py #",
    "#####################",
    "ckpt_path = \"finetuned_llama7B/llama7B-vicuna-onmt_step_4000.pt\"",
    "we receive a text box content",
    "might be good to split also based on full period (later)",
    "we reformat the transformed batch to be numericalized / tensorified",
    "#####",
    "UI #",
    "#####",
    "What are the 3 best french cities ?",
    "Which one is better if I like outdoor activities ?",
    "Which one is better if I like cultural outings?",
    "What are the best neighborhoods in these 5 cities?",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "flake8: noqa",
    "-*- coding: utf-8 -*-",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: sentencepiece_model.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(module_scope)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "from onmt.utils.misc import use_gpu",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "Falcon stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "!/usr/bin/env python",
    "redpajama stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "Avoid functionality on inference",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "If new training initialize the model params",
    "If update_vocab init also but checkpoint will overwrite old weights",
    "ONLY for legacy fusedam with amp pytorch requires NOT to half the model",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "after this checkpoint contains no embeddings",
    "when using LoRa or updating the vocab (no more embeddings in ckpt)",
    "=> strict=False when loading state_dict",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "GPU",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Create a thread to listen for errors in the child processes.",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "raw_srcs = []",
    "raw_refs = []",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Auto import python files in this directory",
    "batch x len x dim",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Help functions for Rotary Embeddings",
    "https://arxiv.org/pdf/2104.09864.pdf",
    "too convoluted to make maxseqlen a parameter.",
    "we suppose src_seq_len at training and max_length at inference",
    "are both < 2048 tokens.",
    "rope is now matrix [maxseqlen, dim/2]",
    "Help functions for max_relative positions",
    "https://arxiv.org/abs/1803.02155",
    "Shift values to be >= 0",
    "now relative_position is in the range [0, inf)",
    "half of the buckets are for exact increments in positions",
    "The other half of the buckets are for logarithmically bigger bins in positions",
    "up to max_distance",
    "Help functions to split model dim per head",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "expand key on heads dimension when it's less than query heads (multi-query variant)",
    "expand value on heads dimension when it's less than query heads (multi-query variant)",
    "2) When standard pos. enc. or rotary, use flash attention",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "copied and adapted https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "Support bnb quantization of nderlying layers",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "we do not super().reset_parameters() save lot of time and useless when no grad.",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "cannot merge/unmerge quantized weigts with unquantized lora_X",
    "Check if QLoraLinear has a custom __init__ method",
    "Invoke the __init__ method of QLoraLinear",
    "LoRA implemented in a dense layer",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "for silu, see: https://arxiv.org/pdf/2002.05202.pdf",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "Code taken from bitsandbytes but modified with arg device to accept skipt_init",
    "from torch.nn.utils => makes model building way faster.",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "reorder weight layout back from ampere/turing to row",
    "we only need to save SCB as extra data, because CB for quantized weights",
    "is already stored in weight.data",
    "case 1: .cuda was called, SCB is in self.weight",
    "case 2: self.init_8bit_state was called, SCB is in self.state",
    "buffers not yet initialized, can't call them directly without",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "we converted 8-bit row major to turing/ampere format in the first inference pass",
    "we no longer need the row-major weight",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "We exclude tokenization for contractions in",
    "order to avoid inconsistencies with pyonmtok's tokenization.",
    "(e.g. \"I ca n't\" with spacy, \"I can ' t\" with pyonmttok)",
    "Use Spacy's stopwords to get rid of junk entries",
    "Perform tokenization with spacy for consistency.",
    "We ensure that the target lemma is present in the lemmatized",
    "target string, that the match is an exact match (there is",
    "whitespace before or after the term)",
    "and we perform some bound checking.",
    "Map the lemmatized string match index to",
    "the lemmatized list index",
    "We need to know if the term is multiword",
    "Join multiword target lemmas with a unique separator so",
    "we can treat them as single word and not change the indices.",
    "Construct the final source from the lemmatized list",
    "that contains the terms. We compare the tokens in the",
    "term-augmented lemma list with the tokens in the original",
    "lemma list. If the lemma is the same, then we replace with",
    "the token from the original tokenized source list. If they",
    "are not the same, it means the lemma has been augemented",
    "with a term, so we inject this in the final list.",
    "Restore the spaces in multi-word terms",
    "Skip half examples to improve performance. This means we set",
    "a hard limit for the `term_corpus_ratio` to 0.5, which is actually",
    "quite high. TODO: We can add this (skipping examples) as an option",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Create all possible tag forms. We inject a special",
    "unicode char (\u2225) as a placeholder for whitespace in order",
    "to keep the indices unaltered. This char is replaced with",
    "spaces before we return the augmented examples.",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "Skip half examples to speed up the transform. This sets",
    "a hard limit of 0.5 to the `tags_corpus_ratio`, which is",
    "excessive and should be avoided anyway.",
    "normalize dict src/tgt for each dataset",
    "print(\"src empty\")",
    "print(\"too many same char in src\")",
    "print(\"too many same word in src\")",
    "print(\"avg token min\", len(src_str) / len(ex['src']))",
    "print(\"avg token max\", len(src_str) / len(ex['src']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(src_str))",
    "print(\"src = tgt\")",
    "print(\"tgt empty\")",
    "print(\"src / tgt ratio \", len(src_str) / len(tgt_str))",
    "print(\"too many same char in tgt\")",
    "print(\"too many same word in tgt\")",
    "print(\"avg token min\", len(tgt_str) / len(ex['tgt']))",
    "print(\"avg token max\", len(tgt_str) / len(ex['tgt']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(tgt_str))",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "normalize dict src/tgt for each dataset",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Auto import python files in this directory",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "########## #",
    "Translator #",
    "########## #",
    "Set translation options",
    "Build translator from options",
    "################### #",
    "Validation iterator #",
    "################### #",
    "Reinstantiate the validation iterator",
    "Retrieve raw references and sources",
    "########### #",
    "Predictions #",
    "########### #",
    "####### #",
    "Outputs #",
    "####### #",
    "Flatten predictions",
    "Save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "temporary as long as translation_server and scoring_preparator still use lists",
    "this is hack: if the special separator \uff5fnewline\uff60is returned because of the",
    "\"docify\" transform.get_specials we don't add it if the corresponding newline code",
    "is already included in the sentencepiece or BPE-with-gpt2-pretok.",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "This preserves backward-compat for models using customed layernorm",
    "Force add_ffnbias to True if bias found in model w_1 keys",
    "fix v2 compatibility",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "BPE training",
    "SentencePiece training",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "get prompt and make sure it fits",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "Build the transforms (along with the tokenizer)",
    "get prompt and make sure it fits"
  ],
  "v3.3.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "inf_type = \"ct2\"",
    "#####################",
    "Inference with CT2 #",
    "#####################",
    "#####################",
    "Inference with -py #",
    "#####################",
    "ckpt_path = \"finetuned_llama7B/llama7B-vicuna-onmt_step_4000.pt\"",
    "we receive a text box content",
    "might be good to split also based on full period (later)",
    "we reformat the transformed batch to be numericalized / tensorified",
    "#####",
    "UI #",
    "#####",
    "What are the 3 best french cities ?",
    "Which one is better if I like outdoor activities ?",
    "Which one is better if I like cultural outings?",
    "What are the best neighborhoods in these 5 cities?",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "from onmt.utils.misc import use_gpu",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "Falcon stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "!/usr/bin/env python",
    "redpajama stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "Avoid functionality on inference",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "If new training initialize the model params",
    "If update_vocab init also but checkpoint will overwrite old weights",
    "ONLY for legacy fusedam with amp pytorch requires NOT to half the model",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "after this checkpoint contains no embeddings",
    "when using LoRa or updating the vocab (no more embeddings in ckpt)",
    "=> strict=False when loading state_dict",
    "weights are in the .pt file",
    "weights are not in the .pt checkpoint but stored in the safetensors file",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Auto import python files in this directory",
    "batch x len x dim",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Help functions for Rotary Embeddings",
    "https://arxiv.org/pdf/2104.09864.pdf",
    "too convoluted to make maxseqlen a parameter.",
    "we suppose src_seq_len at training and max_length at inference",
    "are both < 2048 tokens.",
    "rope is now matrix [maxseqlen, dim/2]",
    "Help functions for max_relative positions",
    "https://arxiv.org/abs/1803.02155",
    "Shift values to be >= 0",
    "Help functions to split model dim per head",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "2) Calculate and scale scores.",
    "expand key on heads dimension when it's less than query heads (multi-query variant)",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "expand value on heads dimension when it's less than query heads (multi-query variant)",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "copied and adapted https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "Support bnb quantization of nderlying layers",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "we do not super().reset_parameters() save lot of time and useless when no grad.",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "cannot merge/unmerge quantized weigts with unquantized lora_X",
    "Check if QLoraLinear has a custom __init__ method",
    "Invoke the __init__ method of QLoraLinear",
    "LoRA implemented in a dense layer",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "for silu, see: https://arxiv.org/pdf/2002.05202.pdf",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "Code taken from bitsandbytes but modified with arg device to accept skipt_init",
    "from torch.nn.utils => makes model building way faster.",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "reorder weight layout back from ampere/turing to row",
    "we only need to save SCB as extra data, because CB for quantized weights",
    "is already stored in weight.data",
    "case 1: .cuda was called, SCB is in self.weight",
    "case 2: self.init_8bit_state was called, SCB is in self.state",
    "buffers not yet initialized, can't call them directly without",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "we converted 8-bit row major to turing/ampere format in the first inference pass",
    "we no longer need the row-major weight",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Create all possible tag forms. We inject a special",
    "unicode char (\u2225) as a placeholder for whitespace in order",
    "to keep the indices unaltered. This char is replaced with",
    "spaces before we return the augmented examples.",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "normalize dict src/tgt for each dataset",
    "print(\"src empty\")",
    "print(\"too many same char in src\")",
    "print(\"too many same word in src\")",
    "print(\"avg token min\", len(src_str) / len(ex['src']))",
    "print(\"avg token max\", len(src_str) / len(ex['src']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(src_str))",
    "print(\"src = tgt\")",
    "print(\"tgt empty\")",
    "print(\"src / tgt ratio \", len(src_str) / len(tgt_str))",
    "print(\"too many same char in tgt\")",
    "print(\"too many same word in tgt\")",
    "print(\"avg token min\", len(tgt_str) / len(ex['tgt']))",
    "print(\"avg token max\", len(tgt_str) / len(ex['tgt']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(tgt_str))",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "normalize dict src/tgt for each dataset",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Auto import python files in this directory",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "translate",
    "for validation we build an infer_iter per batch",
    "in order to avoid oom issues because there is no",
    "batching strategy in `textbatch_to_tensor`",
    "apply_reverse refs",
    "flatten preds",
    "save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "temporary as long as translation_server and scoring_preparator still use lists",
    "this is hack: if the special separator \uff5fnewline\uff60is returned because of the",
    "\"docify\" transform.get_specials we don't add it if the corresponding newline code",
    "is already included in the sentencepiece or BPE-with-gpt2-pretok.",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "This preserves backward-compat for models using customed layernorm",
    "Force add_ffnbias to True if bias found in model w_1 keys",
    "fix v2 compatibility",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "BPE training",
    "SentencePiece training",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory",
    "def custom_stopping_criteria(input_ids, score, **kwargs):",
    "stop_ids = [29871, 13, 13] # \\n\\n",
    "return input_ids[-len(stop_ids)]",
    "Build the translator (along with the model)",
    "Build the transforms (along with the tokenizer)",
    "get prompt and make sure it fits"
  ],
  "v3.2.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "inf_type = \"ct2\"",
    "#####################",
    "Inference with CT2 #",
    "#####################",
    "#####################",
    "Inference with -py #",
    "#####################",
    "ckpt_path = \"finetuned_llama7B/llama7B-vicuna-onmt_step_4000.pt\"",
    "we receive a text box content",
    "might be good to split also based on full period (later)",
    "we reformat the transformed batch to be numericalized / tensorified",
    "#####",
    "UI #",
    "#####",
    "What are the 3 best french cities ?",
    "Which one is better if I like outdoor activities ?",
    "Which one is better if I like cultural outings?",
    "What are the best neighborhoods in these 5 cities?",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "from onmt.utils.misc import use_gpu",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "flake8: noqa",
    "Falcon stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "flake8: noqa",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "flake8: noqa",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "flake8: noqa",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "!/usr/bin/env python",
    "flake8: noqa",
    "redpajama stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "If new training initialize the model params",
    "If update_vocab init also but checkpoint will overwrite old weights",
    "ONLY for legacy fusedam with amp pytorch requires NOT to half the model",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "after this checkpoint contains no embeddings",
    "when using LoRa or updating the vocab (no more embeddings in ckpt)",
    "=> strict=False when loading state_dict",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "batch x len x dim",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Help functions for Rotary Embeddings",
    "https://arxiv.org/pdf/2104.09864.pdf",
    "too convoluted to make maxseqlen a parameter.",
    "we suppose src_seq_len at training and max_length at inference",
    "are both < 2048 tokens.",
    "rope is now matrix [maxseqlen, dim/2]",
    "Help functions for max_relative positions",
    "https://arxiv.org/abs/1803.02155",
    "Shift values to be >= 0",
    "Help functions to split model dim per head",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "copied and adapted https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "Support bnb quantization of nderlying layers",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "we do not super().reset_parameters() save lot of time and useless when no grad.",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "cannot merge/unmerge quantized weigts with unquantized lora_X",
    "Check if QLoraLinear has a custom __init__ method",
    "Invoke the __init__ method of QLoraLinear",
    "LoRA implemented in a dense layer",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "for silu, see: https://arxiv.org/pdf/2002.05202.pdf",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "Code taken from bitsandbytes but modified with arg device to accept skipt_init",
    "from torch.nn.utils => makes model building way faster.",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "reorder weight layout back from ampere/turing to row",
    "we only need to save SCB as extra data, because CB for quantized weights",
    "is already stored in weight.data",
    "case 1: .cuda was called, SCB is in self.weight",
    "case 2: self.init_8bit_state was called, SCB is in self.state",
    "buffers not yet initialized, can't call them directly without",
    "weights are cast automatically as Int8Params, but the bias has to be cast manually",
    "we converted 8-bit row major to turing/ampere format in the first inference pass",
    "we no longer need the row-major weight",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Create all possible tag forms. We inject a special",
    "unicode char (\u2225) as a placeholder for whitespace in order",
    "to keep the indices unaltered. This char is replaced with",
    "spaces before we return the augmented examples.",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "normalize dict src/tgt for each dataset",
    "print(\"src empty\")",
    "print(\"too many same char in src\")",
    "print(\"too many same word in src\")",
    "print(\"avg token min\", len(src_str) / len(ex['src']))",
    "print(\"avg token max\", len(src_str) / len(ex['src']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(src_str))",
    "print(\"src = tgt\")",
    "print(\"tgt empty\")",
    "print(\"src / tgt ratio \", len(src_str) / len(tgt_str))",
    "print(\"too many same char in tgt\")",
    "print(\"too many same word in tgt\")",
    "print(\"avg token min\", len(tgt_str) / len(ex['tgt']))",
    "print(\"avg token max\", len(tgt_str) / len(ex['tgt']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(tgt_str))",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "normalize dict src/tgt for each dataset",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "feed_forward applies residual, so we remove and apply residual with un-normed",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "translate",
    "for validation we build an infer_iter per batch",
    "in order to avoid oom issues because there is no",
    "batching strategy in `textbatch_to_tensor`",
    "apply_reverse refs",
    "flatten preds",
    "save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "this is hack: if the special separator \uff5fnewline\uff60is returned because of the",
    "\"docify\" transform.get_specials we don't add it if the corresponding newline code",
    "is already included in the sentencepiece or BPE-with-gpt2-pretok.",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "bitsandbytes quantize weights when .cuda() is called",
    "for huge models we need to save Ram",
    "so we load the weights  module by module and transfer them to GPU for quantization",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "This preserves backward-compat for models using customed layernorm",
    "Force add_ffnbias to True if bias found in model w_1 keys",
    "fix v2 compatibility",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "BPE training",
    "SentencePiece training",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory"
  ],
  "v3.1.3": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "What are the 3 best french cities ?",
    "Which one is better if I like outdoor activities ?",
    "Which one is better if I like cultural outings?",
    "What are the best neighborhoods in these 5 cities?",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "from onmt.utils.misc import use_gpu",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "flake8: noqa",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "flake8: noqa",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "flake8: noqa",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "!/usr/bin/env python",
    "flake8: noqa",
    "redpajama stores QKV in one single tensor but it is not simply piled up Q+K+V",
    "it is heads interleaved to we need to slice first",
    "also it uses the HF rotary so we need to permute Q and K interleave",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "when using LoRa or updating the vocab (no more embeddings in ckpt)",
    "=> strict=False when loading state_dict",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "batch x len x dim",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Help functions for Rotary Embeddings",
    "https://arxiv.org/pdf/2104.09864.pdf",
    "too convoluted to make maxseqlen a parameter.",
    "we suppose src_seq_len at training and max_length at inference",
    "are both < 2048 tokens.",
    "rope is now matrix [maxseqlen, dim/2]",
    "Help functions for max_relative positions",
    "https://arxiv.org/abs/1803.02155",
    "Shift values to be >= 0",
    "Help functions to split model dim per head",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "Mostly copied from https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "LoRA implemented in a dense layer",
    "Set this to True if the layer to replace stores",
    "weight like (fan_in, fan_out)",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "Compute the indices",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "for silu, see: https://arxiv.org/pdf/2002.05202.pdf",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Create all possible tag forms. We inject a special",
    "unicode char (\u2225) as a placeholder for whitespace in order",
    "to keep the indices unaltered. This char is replaced with",
    "spaces before we return the augmented examples.",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "normalize dict src/tgt for each dataset",
    "print(\"src empty\")",
    "print(\"too many same char in src\")",
    "print(\"too many same word in src\")",
    "print(\"avg token min\", len(src_str) / len(ex['src']))",
    "print(\"avg token max\", len(src_str) / len(ex['src']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(src_str))",
    "print(\"src = tgt\")",
    "print(\"tgt empty\")",
    "print(\"src / tgt ratio \", len(src_str) / len(tgt_str))",
    "print(\"too many same char in tgt\")",
    "print(\"too many same word in tgt\")",
    "print(\"avg token min\", len(tgt_str) / len(ex['tgt']))",
    "print(\"avg token max\", len(tgt_str) / len(ex['tgt']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(tgt_str))",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "normalize dict src/tgt for each dataset",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "translate",
    "for validation we build an infer_iter per batch",
    "in order to avoid oom issues because there is no",
    "batching strategy in `textbatch_to_tensor`",
    "apply_reverse refs",
    "flatten preds",
    "save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "BPE training",
    "SentencePiece training",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory"
  ],
  "v3.1.2": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "from onmt.utils.misc import use_gpu",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "flake8: noqa",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "when using LoRa or updating the vocab (no more embeddings in ckpt)",
    "=> strict=False when loading state_dict",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "batch x len x dim",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Help functions for Rotary Embeddings",
    "https://arxiv.org/pdf/2104.09864.pdf",
    "too convoluted to make maxseqlen a parameter.",
    "we suppose src_seq_len at training and max_length at inference",
    "are both < 2048 tokens.",
    "rope is now matrix [maxseqlen, dim/2]",
    "Help functions for max_relative positions",
    "https://arxiv.org/abs/1803.02155",
    "Shift values to be >= 0",
    "Help functions to split model dim per head",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "Mostly copied from https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "LoRA implemented in a dense layer",
    "Set this to True if the layer to replace stores",
    "weight like (fan_in, fan_out)",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "Compute the indices",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "for silu, see: https://arxiv.org/pdf/2002.05202.pdf",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Create all possible tag forms. We inject a special",
    "unicode char (\u2225) as a placeholder for whitespace in order",
    "to keep the indices unaltered. This char is replaced with",
    "spaces before we return the augmented examples.",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "normalize dict src/tgt for each dataset",
    "print(\"src empty\")",
    "print(\"too many same char in src\")",
    "print(\"too many same word in src\")",
    "print(\"avg token min\", len(src_str) / len(ex['src']))",
    "print(\"avg token max\", len(src_str) / len(ex['src']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(src_str))",
    "print(\"src = tgt\")",
    "print(\"tgt empty\")",
    "print(\"src / tgt ratio \", len(src_str) / len(tgt_str))",
    "print(\"too many same char in tgt\")",
    "print(\"too many same word in tgt\")",
    "print(\"avg token min\", len(tgt_str) / len(ex['tgt']))",
    "print(\"avg token max\", len(tgt_str) / len(ex['tgt']))",
    "print(\"text does not fully belong to wanted script\")",
    "print(\"Some text belong to unwanted scripts\")",
    "print(\"langid does not match\", _id(tgt_str))",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "normalize dict src/tgt for each dataset",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "translate",
    "for validation we build an infer_iter per batch",
    "in order to avoid oom issues because there is no",
    "batching strategy in `textbatch_to_tensor`",
    "apply_reverse refs",
    "flatten preds",
    "save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "BPE training",
    "SentencePiece training",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory"
  ],
  "v3.1.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "Patch for NLLB200 model loading",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "in theory we should divide by accum_count and bptt",
    "to rescale for each sub batch",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "batch x len x dim",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Shift values to be >= 0",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "MOstly copied from https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "LoRA implemented in a dense layer",
    "Set this to True if the layer to replace stores",
    "weight like (fan_in, fan_out)",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "Compute the indices",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "print(regexp, substitution)",
    "print(text)",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "translate",
    "for validation we build an infer_iter per batch",
    "in order to avoid oom issues because there is no",
    "batching strategy in `textbatch_to_tensor`",
    "apply_reverse refs",
    "flatten preds",
    "save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "for future use?",
    "if we want to save the LoRa model state_dict only",
    "model_state_dict = lora_state_dict(model, bias='lora_only')",
    "and comment the line below",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "for side in [\"src\", \"tgt\"]:",
    "keys_to_pop = []",
    "if hasattr(vocab[side], \"fields\"):",
    "unk_token = vocab[side].fields[0][1].vocab.itos[0]",
    "for key, value in vocab[side].fields[0][1].vocab.stoi.items():",
    "if value == 0 and key != unk_token:",
    "keys_to_pop.append(key)",
    "for key in keys_to_pop:",
    "vocab[side].fields[0][1].vocab.stoi.pop(key, None)",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "Here we handle the cases of mismatch in number of segments",
    "between source and target. We re-translate seg by seg.",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory"
  ],
  "v3.1.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '6.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "Patch for NLLB200 model loading",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "LoRa",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options related to source and target features",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "in theory we should divide by accum_count and bptt",
    "to rescale for each sub batch",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "batch x len x dim",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Shift values to be >= 0",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "--------------------------------------------------------------------------",
    "MOstly copied from https://github.com/microsoft/LoRA/",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License (MIT).",
    "--------------------------------------------------------------------------",
    "Optional dropout",
    "Mark the weight as unmerged",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "LoRA implemented in a dense layer",
    "Set this to True if the layer to replace stores",
    "weight like (fan_in, fan_out)",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "LoRA implemented in a dense layer",
    "Actual trainable parameters",
    "Freezing the pre-trained weight matrix",
    "Compute the indices",
    "initialize A the same way as the default",
    "for nn.Linear and B to zero",
    "Make sure that the weights are not merged",
    "Merge the weights and mark it",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "We set the start number of tags to a random number from 1",
    "to 12 + the number of subsequent tags that",
    "will be added. We also apply weights to this choice so tags",
    "are more probable to start from 1, then from 2, etc.",
    "This way we cover most scenarios met in real usage and",
    "the system will learn to handle a fairly large number of",
    "numbered tags (but not an excessively large number)",
    "Make sure we only search for exact matches (we don't want",
    "to match part of words) and perform some bound checking",
    "Make a weighted choice between paired tags or single tags.",
    "We usually encounter, and thus here we favor, paired tags",
    "with a ratio 1/3.",
    "Check if the tags include the",
    "mandatory \"#\" number placeholder\"",
    "We split the user-defined tags in the # placeholder",
    "in order to number them",
    "doc break we add it, restart new doc",
    "case 1st ex is already longer",
    "adding cur ex is too long we add cur doc",
    "and reset doc to cur ex",
    "we start the new doc with cur ex",
    "we cumulate cur ex to cur doc",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "prefix src/tgt for each dataset",
    "prefix as general option for inference",
    "suffix src/tgt for each dataset",
    "suffix as general option for inference",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "print(regexp, substitution)",
    "print(text)",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "One source feature expected but none given and no default provided",
    "Provided default does not match required features",
    "Data not properly annotated.",
    "In this case we do not use the default as it might be an error",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "translate",
    "for validation we build an infer_iter per batch",
    "in order to avoid oom issues because there is no",
    "batching strategy in `textbatch_to_tensor`",
    "apply_reverse refs",
    "flatten preds",
    "save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Check if all tokens have features or none at all",
    "Make features part of src like",
    "{'src': {'src': ..., 'feats': [...., ....]}}",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feats': [....]},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "Need to add features in last dimensions",
    "Keep it consistent with dynamic data",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "for future use?",
    "if we want to save the LoRa model state_dict only",
    "model_state_dict = lora_state_dict(model, bias='lora_only')",
    "and comment the line below",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "for side in [\"src\", \"tgt\"]:",
    "keys_to_pop = []",
    "if hasattr(vocab[side], \"fields\"):",
    "unk_token = vocab[side].fields[0][1].vocab.itos[0]",
    "for key, value in vocab[side].fields[0][1].vocab.stoi.items():",
    "if value == 0 and key != unk_token:",
    "keys_to_pop.append(key)",
    "for key in keys_to_pop:",
    "vocab[side].fields[0][1].vocab.stoi.pop(key, None)",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "Here we handle the cases of mismatch in number of segments",
    "between source and target. We re-translate seg by seg.",
    "those two should be the same except feat dim",
    "batch['src'][perm[j], :, :])",
    "trans.src",
    "we rebuild a small batch made of the sub-segments",
    "in the long segment.",
    "new sub-batch ready to be translated",
    "we re-insert the sub-batch in the initial translations",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "Quick fix. Transformers return None as enc_states.",
    "enc_states are only used later on to init decoder's state",
    "but are never used in Transformer decoder, so we can skip",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory"
  ],
  "v3.0.4": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "Usage: python3 filter_train.py in.src in.trg out.src out.trg max-tokens",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "Patch for NLLB200 model loading",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "!/usr/bin/env python",
    "if transform + options set in 'valid' we need to copy in main",
    "transform / options for scoring considered as inference",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "in theory we should divide by accum_count and bptt",
    "to rescale for each sub batch",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "batch x len x dim",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Shift values to be >= 0",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "Filter out very short or very long sentences",
    "from the TM for better performance",
    "We split the `batch` and perform fuzzy matching",
    "in smaller chunks of 10.000 examples in order to",
    "reduce memory usage.",
    "Perfomance is not affected.",
    "Probably redundant but let's be safe",
    "in case some examples are already fuzzied",
    "(e.g. from another pipeline or workflow)",
    "We don't want exact matches",
    "Apply a basic filtering to leave out very short or very long",
    "sentences and speed up things a bit during fuzzy matching",
    "Do nothing",
    "Do nothing",
    "Punctuation only",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "Most code taken from: https://github.com/alvations/sacremoses",
    "Which in turn is based on the Moses punctuation normalizer.",
    "https://github.com/moses-smt/mosesdecoder/blob/master/scripts/",
    "tokenizer/normalize-punctuation.perl",
    "don't fix period at end of sentence",
    "Regex substitutions from replace-unicode-punctuation.perl",
    "https://github.com/moses-smt/mosesdecoder/blob/master/",
    "scripts/tokenizer/replace-unicode-punctuation.perl",
    "Adds the penn substitutions after extra_whitespace regexes.",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "Actual normalization.",
    "print(regexp, substitution)",
    "print(text)",
    "Optionally, replace unicode puncts BEFORE normalization.",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "placing this here make it easier to call logger.info",
    "from anywhere, just 'from onmt.utils.logging import logger'",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "translate",
    "for validation we build an infer_iter per batch",
    "in order to avoid oom issues because there is no",
    "batching strategy in `textbatch_to_tensor`",
    "apply_reverse refs",
    "flatten preds",
    "save results",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "patch to log stdout spawned processes of dataloader",
    "bucket_size = batch_size",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Make features part of src like",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....}}",
    "We apply the same TransformPipe to all the bucket",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "we'll need to change this if we introduce tgt feat",
    "Need to add features in last dimensions",
    "Need to add features also in 'src'",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "for side in [\"src\", \"tgt\"]:",
    "keys_to_pop = []",
    "if hasattr(vocab[side], \"fields\"):",
    "unk_token = vocab[side].fields[0][1].vocab.itos[0]",
    "for key, value in vocab[side].fields[0][1].vocab.stoi.items():",
    "if value == 0 and key != unk_token:",
    "keys_to_pop.append(key)",
    "for key in keys_to_pop:",
    "vocab[side].fields[0][1].vocab.stoi.pop(key, None)",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Just for debugging purposes",
    "It appends features to subwords when dumping to file",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "Here we set the decoder to start with self.start (BOS or EOS)",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory"
  ],
  "v3.0.3": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "loss is returned normalized by tokens",
    "we unnormalize to cumulate at doc level",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "this patch is no longer needed, included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "!/usr/bin/env python",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Let's clean the GPUs before training loop",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "in theory we should divide by accum_count and bptt",
    "to rescale for each sub batch",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "batch x len x dim",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Shift values to be >= 0",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "Do nothing",
    "Do nothing",
    "Punctuation only",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "attns[\"coverage\"] is actually c^(t+1) of See et al(2017)",
    "1-index shifted",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "rescale with tau (temperature) and apply the log_softmax.",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "translate",
    "for validation we build an infer_iter per batch",
    "in order to avoid oom issues because there is no",
    "batching strategy in `textbatch_to_tensor`",
    "apply_reverse refs",
    "flatten preds",
    "save results",
    "We deactivate the decoder's cache",
    "as we use teacher forcing at training time.",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "bucket_size = batch_size",
    "We only support",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "Make features part of src like",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....}}",
    "We apply the same TransformPipe to all the bucket",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "we'll need to change this if we introduce tgt feat",
    "Need to add features in last dimensions",
    "Need to add features also in 'src'",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "for side in [\"src\", \"tgt\"]:",
    "keys_to_pop = []",
    "if hasattr(vocab[side], \"fields\"):",
    "unk_token = vocab[side].fields[0][1].vocab.itos[0]",
    "for key, value in vocab[side].fields[0][1].vocab.stoi.items():",
    "if value == 0 and key != unk_token:",
    "keys_to_pop.append(key)",
    "for key in keys_to_pop:",
    "vocab[side].fields[0][1].vocab.stoi.pop(key, None)",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Just for debugging purposes",
    "It appends features to subwords when dumping to file",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory"
  ],
  "v3.0.2": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "loss is returned normalized by tokens",
    "we unnormalize to cumulate at doc level",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "this patch is no longer needed, included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "!/usr/bin/env python",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "in theory we should divide by accum_count and bptt",
    "to rescale for each sub batch",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "batch x len x dim",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Shift values to be >= 0",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "Do nothing",
    "Do nothing",
    "Punctuation only",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "make sure the scalars are in the event accumulator tags",
    "required arguments",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead",
    "of probabilities, only the first part of the generator needs to",
    "be passed to the NMTLossCompute. At the moment, the only",
    "supported loss function of this kind is the sparsemax loss.",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "we use the raw logits, rescale with tau (temperature) and",
    "apply the log_softmax. reminder generator[0] is just the nn.Linear",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "we use the raw logits, rescale with tau (temperature) and",
    "apply the log_softmax. reminder generator[0] is just the nn.Linear",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "for validation we build an infer_iter per batch",
    "in order to avoid oom issues because there is no",
    "batching strategy in `textbatch_to_tensor`",
    "flatten sources (for validation)",
    "we deactivate the decoder's cache",
    "as we use teacher forcing at training time.",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "bucket_size = batch_size",
    "We only support",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "Make features part of src like",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....}}",
    "We apply the same TransformPipe to all the bucket",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "we'll need to change this if we introduce tgt feat",
    "Need to add features in last dimensions",
    "Need to add features also in 'src'",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "for side in [\"src\", \"tgt\"]:",
    "keys_to_pop = []",
    "if hasattr(vocab[side], \"fields\"):",
    "unk_token = vocab[side].fields[0][1].vocab.itos[0]",
    "for key, value in vocab[side].fields[0][1].vocab.stoi.items():",
    "if value == 0 and key != unk_token:",
    "keys_to_pop.append(key)",
    "for key in keys_to_pop:",
    "vocab[side].fields[0][1].vocab.stoi.pop(key, None)",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Just for debugging purposes",
    "It appends features to subwords when dumping to file",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "src_raw = self.data.examples[inds[b]].src[0]",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory"
  ],
  "v3.0.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "loss is returned normalized by tokens",
    "we unnormalize to cumulate at doc level",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "this patch is no longer needed, included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "!/usr/bin/env python",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "in theory we should divide by accum_count and bptt",
    "to rescale for each sub batch",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "batch x len x dim",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Shift values to be >= 0",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "Do nothing",
    "Do nothing",
    "Punctuation only",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use apex.amp",
    "In this case use the old FusedAdam with",
    "FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "should be: self._optimizer.zero_grad(set_to_none)",
    "but apex.amp is not up-to-date:",
    "https://github.com/NVIDIA/apex/blob/master/apex/amp/_process_optimizer.py#L367",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead",
    "of probabilities, only the first part of the generator needs to",
    "be passed to the NMTLossCompute. At the moment, the only",
    "supported loss function of this kind is the sparsemax loss.",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "we use the raw logits, rescale with tau (temperature) and",
    "apply the log_softmax. reminder generator[0] is just the nn.Linear",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "we use the raw logits, rescale with tau (temperature) and",
    "apply the log_softmax. reminder generator[0] is just the nn.Linear",
    "ct2 expects src with lengths without padding",
    "again we use raw probs to rescale with tau and apply log_softmax",
    "lm_scores are in log space so log_target=True",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "batch_side.shape[0] sentences to rebuild",
    "batch_side.shape[1] tokens per sentence",
    "we deactivate the decoder's cache",
    "as we use teacher forcing at training time.",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "bucket_size = batch_size",
    "We only support",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "this is a hack: appears quicker to apply it here",
    "than in the ParallelCorpusIterator",
    "Make features part of src like",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....}}",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "we'll need to change this if we introduce tgt feat",
    "Need to add features in last dimensions",
    "Need to add features also in 'src'",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "for side in [\"src\", \"tgt\"]:",
    "keys_to_pop = []",
    "if hasattr(vocab[side], \"fields\"):",
    "unk_token = vocab[side].fields[0][1].vocab.itos[0]",
    "for key, value in vocab[side].fields[0][1].vocab.stoi.items():",
    "if value == 0 and key != unk_token:",
    "keys_to_pop.append(key)",
    "for key in keys_to_pop:",
    "vocab[side].fields[0][1].vocab.stoi.pop(key, None)",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Just for debugging purposes",
    "It appends features to subwords when dumping to file",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "src_raw = self.data.examples[inds[b]].src[0]",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory"
  ],
  "v3.0.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "this patch is no longer needed included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "!/usr/bin/env python",
    "with the two module = imp.load_source() below",
    "we ghost the old torchtext.data.field and depercated",
    "onmt.inputters.text_dataset",
    "however this require some functions / classes to be",
    "monkey patched for loading the old field/vocab objects.",
    "module3 = imp.load_source(\"Vocab\", \"tools/convertv2_v3.py\")",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "voc = dict(sorted(fields.vocab.__dict__['freqs'].items(),",
    "key=lambda x: (-x[1], x[0]))).keys()",
    "this patch is no longer needed, included in converter",
    "if hasattr(model_opt, 'rnn_size'):",
    "model_opt.hidden_size = model_opt.rnn_size",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "!/usr/bin/env python",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "in theory we should divide by accum_count and bptt",
    "to rescale for each sub batch",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "src lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "batch x len x dim",
    "mask is now (batch x 1 x slen x slen)",
    "1 to be expanded to number of heads in MHA",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "Shift values to be >= 0",
    "class MultiHeadedAttention(torch.jit.ScriptModule):",
    "https://arxiv.org/pdf/1803.02155.pdf",
    "in the paper they suggest either two embeds",
    "relative_key / relative_value or only",
    "relative_key. We implemented the same embed",
    "for both.",
    "@torch.jit.script_method",
    "1) Project key, value, and query.",
    "as a reminder at training layer_cache[0] remains False",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "not 100% necessary but expand to nb of heads",
    "now mask and scores have the same shape",
    "3) Apply attention dropout and compute context vectors.",
    "We use the same embeddings for key and value",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "class AverageAttention(torch.jit.ScriptModule):",
    "@torch.jit.script",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "Do nothing",
    "Do nothing",
    "Punctuation only",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('hidden_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "src_len is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate src_len as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x s or t len)",
    "1 = heads to be expanded in MHA",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "first value set to True triggered by the beginning of decoding",
    "layer_cache becomes active in the MultiHeadedAttention fwd",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "mask now are (batch x 1 x tlen x tlen)",
    "1 = heads to be expanded in MHA",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "print(filled, sz)",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead",
    "of probabilities, only the first part of the generator needs to",
    "be passed to the NMTLossCompute. At the moment, the only",
    "supported loss function of this kind is the sparsemax loss.",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "take into account here the tgt_shift_index (0 / 1 = LM/NMT)",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "this param init is overridden by model_builder, useless then.",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "-*- coding: utf-8 -*-",
    "this one is needed for Random Shuffler of batches",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "we need to check the model path + any tokenizer path",
    "bucket_size = batch_size",
    "We only support",
    "For TRAIN we need to group examples by length",
    "for faster performance, but otherwise, sequential.",
    "For TRAIN we shuffle batches within the bucket",
    "otherwise sequential",
    "for specific case of rnn_packed need to be sorted",
    "within the batch",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "this is a hack: appears quicker to apply it here",
    "than in the ParallelCorpusIterator",
    "Make features part of src like",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....}}",
    "at this point an example looks like:",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....},",
    "'tgt': {'tgt': ...},",
    "'src_original': ['tok1', ...'tokn'],",
    "'tgt_original': ['tok1', ...'tokm'],",
    "'indices' : seq in bucket",
    "'align': ...,",
    "}",
    "we'll need to change this if we introduce tgt feat",
    "Need to add features in last dimensions",
    "Need to add features also in 'src'",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to dynamic_iterator.py cf process()",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "RNN uses enc_final_hs",
    "CNN uses enc_out and enc_final_hs",
    "transformer uses src",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "for side in [\"src\", \"tgt\"]:",
    "keys_to_pop = []",
    "if hasattr(vocab[side], \"fields\"):",
    "unk_token = vocab[side].fields[0][1].vocab.itos[0]",
    "for key, value in vocab[side].fields[0][1].vocab.stoi.items():",
    "if value == 0 and key != unk_token:",
    "keys_to_pop.append(key)",
    "for key in keys_to_pop:",
    "vocab[side].fields[0][1].vocab.stoi.pop(key, None)",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Just for debugging purposes",
    "It appends features to subwords when dumping to file",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Set sharing strategy manually instead of default based on the OS.",
    "torch.multiprocessing.set_sharing_strategy('file_system')",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "magic indices",
    "result caching",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [batch, tgt_len, nfeats] as input",
    "and [batch, src_len, hidden] as enc_out",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "at this point scores is batch first (dim=0)",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [batch_size, tgt_len, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(batch * n_best, src_len, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "it should be done in a better way",
    "here dec_in is batch first",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "decoder_input = decode_strategy.current_predictions.view(1, -1,",
    "1)",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task src_len is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "src_raw = self.data.examples[inds[b]].src[0]",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory"
  ],
  "2.3.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "In order to use this tool, please install comet first",
    "https://github.com/Unbabel/COMET",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate source and reference sentences nbest times",
    "for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "same for source.",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-src source.5.sl --nbest-hyp target.5.tl \\",
    "--nbest-ref reference.5.tl --nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best comet score",
    "when choosing a reference-less model no nbest-ref is required",
    "for nbest in nbests:",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python mbr_bleu.py --nbest-hyp target.5.tl \\",
    "--nbest-order 5 --output target.mbr.tl",
    "It will compare all hyp with eachother and output the max bleu",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "Load model for inference",
    "Build transforms",
    "Build datareader based on src AND tgt (should be equal)",
    "Cannot use build_loss_compute() we need reduction 'none' in the criterion",
    "to get the loss of each sentence instead of the loss of the full batch",
    "Now we can pipe the full file through the model using the Iterator",
    "reminder a batch includes .src .tgt .indices and it is sorted",
    "Compute and retrieve the loss for EACH sentence",
    "Now we need to rearrange the batch of ppl",
    "in the original order with indices",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "coding: utf-8",
    "Let's say you have a source file with N sentences in SL - eg: source.sl",
    "and the corresponding references (N sentences) reference.tl",
    "Translate your file in TL with the -n_best nbest options nbest being",
    "then number of hypotheses and output the target to -output target.nbest.tl",
    "Then you need to duplicate reference sentences nbest times for this script.",
    "for instance using awk '{for(i=1; i<=n; i++) print}' n=5 reference.tl \\",
    "> reference.5.tl",
    "This script can be run (for instance with nbest = 5) as follows:",
    "python oracle_bleu.py --nbest-hyp target.5.tl --nbest-ref reference.5.tl \\",
    "--nbest-order 5 --output target.maxbleu.tl",
    "It will search in all hyp the best bleu wrt reference",
    "and output the max bleu",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "!/usr/bin/env python",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "Override checkpoint's freezing settings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Move batch to specified device",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "Freeze Encoder and/or Decoder",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Adding options related to Transforms",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "gather stats unuseful on a single gpu",
    "valid_stats = self._maybe_gather_stats(valid_stats)",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Compute validation metrics (at batch.dataset level)",
    "Compute stats",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "Compute and save stats",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "Do nothing",
    "Do nothing",
    "Punctuation only",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "we finish 3 hyps per example in this step",
    "new beam 1 is old beam 3",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "NOTE: stride (if needed) is handled at the",
    "generator (train_iter) level",
    "Move batch to correspond device_id when consumer iterate",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "in the case criterion reduction is None then we need",
    "to sum the loss of each sentence in the batch",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "It comes from training",
    "TODO: needs to be added as inference opt",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "Helper functions",
    "Keeps track of the original words/subwords",
    "('prior_tokenization' option)",
    "In case there is a final case_markup when new_spacer is on",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "add init_token and eos_token according to src construction",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "this is a hack: appears quicker to apply it here",
    "than in the ParallelCorpusIterator",
    "Make features part of src as in TextMultiField",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....}}",
    "'src_original' and 'tgt_original' store the",
    "original line before tokenization. These",
    "fields are used later on in the feature",
    "transforms.",
    "NOTE: moved to DatasetAdapter._process method in iterator.py",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "Just for debugging purposes",
    "It appends features to subwords when dumping to file",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "NOTE: not support tgt feats yet",
    "-*- coding: utf-8 -*-",
    "Make features part of src as in TextMultiField",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....}}",
    "Cleanup",
    "Legacy function. Currently it only truncates input if truncate is set.",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "Base field",
    "Feats fields",
    "Legacy function, it is not really necessary",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Build transforms",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "import onmt.opts as opts",
    "Set sharing strategy manually instead of default based on the OS.",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "Report src and tgt vocab sizes",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "This does not work if we merge with the first loop, not sure why",
    "Get the iterator to generate from",
    "Once training is done, we can terminate the producers",
    "magic indices",
    "result caching",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "In the case of length_penalty = none we report the total logprobs",
    "divided by the number of sentence to get an approximation of the",
    "per sentence logprob. We also return the corresponding ppl",
    "When a length_penalty is used eg: \"avg\" or \"wu\" since logprobs",
    "are normalized per token we report the per line per token logprob",
    "and the corresponding \"per word perplexity\"",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)",
    "Auto import python files in this directory"
  ],
  "2.2.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "!/usr/bin/env python",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Move batch to specified device",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "Do nothing",
    "Do nothing",
    "If case markup placeholder",
    "Punctuation only (assumes joiner is also some punctuation token)",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "transforms that require vocab will not create if not provide vocab",
    "1. Init first transform in the pipe",
    "2. Init second transform in the pipe",
    "3. Sequential combine them into a transform pipe",
    "4. apply transform pipe for example",
    "5. example after the pipe exceed the length limit, thus filtered",
    "6. Transform statistics registed (here for filtertoolong)",
    "7. after report, statistics become empty as a fresh start",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "NOTE: stride (if needed) is handled at the",
    "generator (train_iter) level",
    "Move batch to correspond device_id when consumer iterate",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "Check features",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "In case there is a final case_markup when new_spacer is on",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "add init_token and eos_token according to src construction",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "this is a hack: appears quicker to apply it here",
    "than in the ParallelCorpusIterator",
    "Make features part of src as in TextMultiField",
    "{'src': {'src': ..., 'feat1': ...., 'feat2': ....}}",
    "NOTE: moved to DatasetAdapter._process method in iterator.py",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "NOTE: not support tgt feats yet",
    "-*- coding: utf-8 -*-",
    "Legacy function. Currently it only truncates input if truncate is set.",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "Base field",
    "Feats fields",
    "Legacy function, it is not really necessary",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "import onmt.opts as opts",
    "Set sharing strategy manually instead of default based on the OS.",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "Report src and tgt vocab sizes",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "This does not work if we merge with the first loop, not sure why",
    "Get the iterator to generate from",
    "Once training is done, we can terminate the producers",
    "magic indices",
    "result caching",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "hack [min_len_batch-1:] because expect <bos>",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "2.1.2": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "Remove old vocabulary associated embeddings",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint",
    "after initialization",
    "!/usr/bin/env python",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Move batch to specified device",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "transforms that require vocab will not create if not provide vocab",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "NOTE: stride (if needed) is handled at the",
    "generator (train_iter) level",
    "Move batch to correspond device_id when consumer iterate",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "add init_token and eos_token according to src construction",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "this is a hack: appears quicker to apply it here",
    "than in the ParallelCorpusIterator",
    "NOTE: moved to DatasetAdapter._process method in iterator.py",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "NOTE: not support nfeats > 0 yet",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "import onmt.opts as opts",
    "Set sharing strategy manually instead of default based on the OS.",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "Report src and tgt vocab sizes",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "This does not work if we merge with the first loop, not sure why",
    "Get the iterator to generate from",
    "Once training is done, we can terminate the producers",
    "magic indices",
    "result caching",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "hack [min_len_batch-1:] because expect <bos>",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "2.1.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint after initialization",
    "Remove old vocabulary associated embeddings",
    "Embedding layers",
    "!/usr/bin/env python",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Move batch to specified device",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "Load vocabulary file if provided and set threshold",
    "Load Subword Model",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "transforms that require vocab will not create if not provide vocab",
    "filter_transform.warm_up()",
    "test BPE-dropout:",
    "1. disable bpe dropout for not training example",
    "2. enable bpe dropout for training example",
    "3. (NOTE) disable dropout won't take effect if already seen",
    "this is caused by the cache mechanism in bpe:",
    "return cached subword if the original token is seen when no dropout",
    "test SP regularization:",
    "1. enable regularization for training example",
    "2. disable regularization for not training example",
    "Not apply token drop for not training example",
    "apply token drop for training example",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "require vocabs to warm_up",
    "Not apply token mask for not training example",
    "apply token mask for training example",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "random_ratio of inserted tokens are chosen in vocab",
    "others are MASK_TOK",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "all token are considered as an individual word",
    "1. tokens are dropped when replace_length is 0",
    "print(f\"token delete: {masked} / {tokens}\")",
    "2. tokens are replaced by MASK when replace_length is 1",
    "print(f\"token mask: {masked} / {tokens}\")",
    "insert_ratio=0.0,",
    "random_ratio=0.0,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "1. replace_length 0: \"words\" are dropped",
    "print(f\"word delete: {masked} / {tokens}\")",
    "self.assertEqual(len(masked), n_words - n_masked)",
    "2. replace_length 1: \"words\" are replaced with a single MASK",
    "print(f\"whole word single mask: {masked} / {tokens}\")",
    "len(masked) depend on number of tokens in select word",
    "3. replace_length -1: all tokens in \"words\" are replaced with MASK",
    "print(f\"whole word multi mask: {masked} / {tokens}\")",
    "number of mask_tok depend on number of tokens in selected word",
    "number of MASK_TOK can be greater than n_masked",
    "insert_ratio=0.5,",
    "random_ratio=0.3,",
    "Defalt: full_stop_token=[\".\", \"?\", \"!\"]",
    "start token of word are identified using subword marker",
    "n_words = sum(token_starts)",
    "n_masked = math.ceil(n_words * bart_noise.mask_ratio)",
    "print(f\"Text Span Infilling: {infillied} / {tokens}\")",
    "print(n_words, n_masked)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "NOTE: stride (if needed) is handled at the",
    "generator (train_iter) level",
    "Move batch to correspond device_id when consumer iterate",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "add init_token and eos_token according to src construction",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "this is a hack: appears quicker to apply it here",
    "than in the ParallelCorpusIterator",
    "NOTE: moved to DatasetAdapter._process method in iterator.py",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "NOTE: not support nfeats > 0 yet",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "import onmt.opts as opts",
    "Set sharing strategy manually instead of default based on the OS.",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "Report src and tgt vocab sizes",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "This does not work if we merge with the first loop, not sure why",
    "Get the iterator to generate from",
    "Once training is done, we can terminate the producers",
    "magic indices",
    "result caching",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "hack [min_len_batch-1:] because expect <bos>",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "2.1.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Avoid functionality on inference",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Update vocabulary embeddings with checkpoint embeddings",
    "Embedding layers",
    "Just for debugging purposes",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Update model embeddings with those from the checkpoint after initialization",
    "Remove old vocabulary associated embeddings",
    "Embedding layers",
    "!/usr/bin/env python",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "Override checkpoint's update_embeddings as it defaults to false",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Move batch to specified device",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "no dummy prefix",
    "no dummy prefix",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "NOTE: stride (if needed) is handled at the",
    "generator (train_iter) level",
    "Move batch to correspond device_id when consumer iterate",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "add init_token and eos_token according to src construction",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "this is a hack: appears quicker to apply it here",
    "than in the ParallelCorpusIterator",
    "NOTE: moved to DatasetAdapter._process method in iterator.py",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "NOTE: not support nfeats > 0 yet",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "import onmt.opts as opts",
    "Set sharing strategy manually instead of default based on the OS.",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "Report src and tgt vocab sizes",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "This does not work if we merge with the first loop, not sure why",
    "Get the iterator to generate from",
    "Once training is done, we can terminate the producers",
    "magic indices",
    "result caching",
    "fix length constraint and remove eos from count",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "hack [min_len_batch-1:] because expect <bos>",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "2.0.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Move batch to specified device",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "The following options (bridge_extra_node to n_steps) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Length penalty options",
    "Coverage penalty options",
    "Decoding Length constraint",
    "Decoding content constraint",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Token embedding",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "NOTE: stride (if needed) is handled at the",
    "generator (train_iter) level",
    "Move batch to correspond device_id when consumer iterate",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "add init_token and eos_token according to src construction",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "this is a hack: appears quicker to apply it here",
    "than in the ParallelCorpusIterator",
    "NOTE: moved to DatasetAdapter._process method in iterator.py",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "NOTE: not support nfeats > 0 yet",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "import onmt.opts as opts",
    "Set sharing strategy manually instead of default based on the OS.",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "Report src and tgt vocab sizes",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "This does not work if we merge with the first loop, not sure why",
    "Get the iterator to generate from",
    "Once training is done, we can terminate the producers",
    "magic indices",
    "result caching",
    "fix length constraint",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "hack [min_len_batch-1:] because expect <bos>",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "2.0.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Build embeddings.",
    "Build encoder.",
    "Build embeddings.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "for back compat when attention_dropout was not defined",
    "Build Model",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "ensure tensorboard output is written in the directory",
    "of previous checkpoints",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Move batch to specified device",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Model Task Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "The following options (bridge_extra_node to src_vocab) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "finish one beam",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "finish example in last batch",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "BoolTensor was introduced in pytorch 1.2",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "masking is necessary when sequence length is greater than one",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "NOTE: stride (if needed) is handled at the",
    "generator (train_iter) level",
    "Move batch to correspond device_id when consumer iterate",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Check Transforms",
    "Check path",
    "tgt is src for LM task",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "add init_token and eos_token according to src construction",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "this is a hack: appears quicker to apply it here",
    "than in the ParallelCorpusIterator",
    "NOTE: moved to DatasetAdapter._process method in iterator.py",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "NOTE: not support nfeats > 0 yet",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "No encoder in LM, seq2seq count formatting kept",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "import onmt.opts as opts",
    "Set sharing strategy manually instead of default based on the OS.",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "Report src and tgt vocab sizes",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "This does not work if we merge with the first loop, not sure why",
    "Get the iterator to generate from",
    "Once training is done, we can terminate the producers",
    "magic indices",
    "result caching",
    "fix length constraint",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "keep indices until overflowing p",
    "Set all logits that are not in the top-p to -10000.",
    "This puts the probabilities close to 0.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "TODO: support these blacklisted features",
    "hack [min_len_batch-1:] because expect <bos>",
    "(0) Prep the components of the search.",
    "(1) split src into src and target_prefix to avoid padding.",
    "(2) init decoder",
    "(3) prep decode_strategy. Possibly repeat src objects.",
    "(4) Begin decoding step by step:",
    "Reorder states.",
    "select indexes in model state/cache",
    "beam parameters",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "in LM task memory_lengths is associated with currently generated src",
    "and therefore needs to follow the generation",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "2.0.0rc2": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "build_base_model expects updated and validated opts",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "for back compat when attention_dropout was not defined",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Move batch to specified device",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "The following options (bridge_extra_node to src_vocab) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Freeze word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "subword vocabulary restriction options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are freezed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "BoolTensor was introduced in pytorch 1.2",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "NOTE: stride (if needed) is handled at the",
    "generator (train_iter) level",
    "Move batch to correspond device_id when consumer iterate",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Check Transforms",
    "Check path",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "validation when train:",
    "Check embeddings stuff",
    "Backward compatibility with \"fix_word_vecs_*\" opts",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "this is a hack: appears quicker to apply it here",
    "than in the ParallelCorpusIterator",
    "NOTE: moved to DatasetAdapter._process method in iterator.py",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "NOTE: not support nfeats > 0 yet",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "import onmt.opts as opts",
    "Set sharing strategy manually instead of default based on the OS.",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "Report src and tgt vocab sizes",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "This does not work if we merge with the first loop, not sure why",
    "Get the iterator to generate from",
    "Once training is done, we can terminate the producers",
    "magic indices",
    "result caching",
    "fix length constraint",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "beam parameters",
    "result caching",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "2.0.0rc1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "converts a SentencePiece vocabulary to the format expected by dynamic data",
    "(essentially converts float expected counts to \"fixed precision\" int pseudo",
    "counts)",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "for back compat when attention_dropout was not defined",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Move batch to specified device",
    "Use Tensorboard for visualization during training",
    "Options only during inference",
    "Truncation options, for text corpus",
    "as for False, this will be added in _add_train_general_opts",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "The following options (bridge_extra_node to src_vocab) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "options relate to data preprare",
    "options relate to train",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Adding options relate to decoding strategy",
    "Adding option for logging",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "Some utilitary functions for pretrained embeddings",
    "is this reachable?",
    "Write to file",
    "set the opt in place",
    "set the opt in place",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "Auto import python files in this directory",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. sample corrupted values",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. Drop token on chosen position",
    "1. sample number of tokens to corrupt",
    "2. sample positions to corrput",
    "3. mask word on chosen position",
    "Sharing options among `TokenizerTransform`s, same name conflict in",
    "this scope will be resolved by remove previous occurrence in parser",
    "subword regularization(or BPE dropout) options:",
    "derterministic subwording",
    "subword sampling when nbest_size > 1 or -1",
    "alpha should be 0.0 < alpha < 1.0",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "view each subword as word start / input is word level token",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert is_word_start[-1] == 0",
    "assert tokens_length - 1 not in indices",
    "keep index, but replace it with [MASK]",
    "acts as a long length, so spans don't go over the end of doc",
    "next position from each word_start",
    "delete token: 1 mask/remove per span",
    "keep index, but replace it with [MASK]: 1 mask per token",
    "A bit faster when all lengths are 1",
    "to cover whole token",
    "delete token",
    "keep index, but replace it with [MASK]",
    "assert tokens_length - 1 not in indices",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Inject some dummy training options that may needed when build fields",
    "Remove the generated *pt files.",
    "Remove the generated data samples",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "BoolTensor was introduced in pytorch 1.2",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "NOTE: stride (if needed) is handled at the",
    "generator (train_iter) level",
    "Move batch to correspond device_id when consumer iterate",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Check Transforms",
    "Check path",
    "Check prefix: will be used when use prefix transform",
    "Check weight",
    "Check embeddings stuff",
    "encoder and decoder should be same sizes",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "This one is needed for various tranfroms",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "this is a hack: appears quicker to apply it here",
    "than in the ParallelCorpusIterator",
    "NOTE: moved to DatasetAdapter._process method in iterator.py",
    "item = self.transform.apply(",
    "example, is_train=self.infinitely, corpus_name=self.cid)",
    "empty example: skip",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "NOTE: not support nfeats > 0 yet",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "_check_save_model_path",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "import onmt.opts as opts",
    "Set sharing strategy manually instead of default based on the OS.",
    "maybe prepare pretrained embeddings, if any",
    "Load checkpoint if we resume from a previous training.",
    "Report src and tgt vocab sizes",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "This does not work if we merge with the first loop, not sure why",
    "Get the iterator to generate from",
    "Once training is done, we can terminate the producers",
    "magic indices",
    "result caching",
    "fix length constraint",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "TODO: maybe add dynamic part",
    "Statistics",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "beam parameters",
    "result caching",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "1.2.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "degenerate case",
    "cache the features",
    "mp queues don't work well between procs unless they're from a manager",
    "each device has its own saver so that reconstructing is easier",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for back compat when attention_dropout was not defined",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "patch for fields that may be missing in old data/model",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Move batch to specified device",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "The following options (bridge_extra_node to src_vocab) are used",
    "for training with --encoder_type ggnn (Gated Graph Neural Network).",
    "The ggnn uses src_vocab during training because the graph is built",
    "using edge information which requires parsing the input sequence.",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "if you want to pass an existing vocab.pt file, pass it to",
    "-src_vocab alone as it already contains tgt vocab.",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options for experimental source noising (BART style)",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use Tensorboard for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "incoming and outgoing edge embedding",
    "Find vocab data for tree builting",
    "Propogation Model",
    "Initialize the bridge layer",
    "Initialize graph using formatted input sequence",
    "Number of flagged nodes defines node count for this sample",
    "(Nodes can have no flags on them, but must be in 'flags' list).",
    "The total number of integers in the vocab should allow",
    "for all features and edges to be defined.",
    "Use first extra node as only source for decoder init",
    "Average all nodes to get bridge input",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "noise_skip = batch.noise_skip",
    "aeq(len(batch.noise_skip) == source.size(1))",
    "source is [src_len x bs x feats]",
    "source might increase length so we need to resize the whole",
    "tensor",
    "remove useless pad",
    "def s(self, tokens):",
    "prob = self.prob",
    "r = torch.rand([len(tokens)])",
    "mask = False",
    "masked = []",
    "for i, tok in enumerate(tokens):",
    "if tok.startswith(subword_prefix):",
    "if r[i].item() <= prob:",
    "masked.append(mask_tok)",
    "mask = True",
    "else:",
    "masked.append(tok)",
    "mask = False",
    "else:",
    "if mask:",
    "pass",
    "else:",
    "masked.append(tok)",
    "return masked",
    "aeq(source.size(0), length)",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "aeq(source.size(0), length)",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "fairseq/data/denoising_dataset.py",
    "print(\"src size: \", source.size())",
    "print(\"ws size: \", self.word_start_mask.size())",
    "print(\"max: \", source.max())",
    "assert source.max() < self.word_start_mask.size(0)",
    "assert source.min() >= 0",
    "assert source.size() == is_word_start.size()",
    "aeq(source.eq(self.pad_idx).long().sum(), 0)",
    "we manually add this hypothesis since it's required for the rest",
    "of the function and kindof make sense",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert (lengths > 0).all()",
    "assert is_word_start[-1] == 0",
    "TODO why?",
    "assert source_length - 1 not in indices",
    "acts as a long length, so spans don't go over the end of doc",
    "keep index, but replace it with [MASK]",
    "random ratio disabled",
    "source[indices[mask_random]] = torch.randint(",
    "1, len(self.vocab), size=(mask_random.sum(),))",
    "if self.mask_span_distribution is not None:",
    "assert len(lengths.size()) == 1",
    "assert lengths.size() == indices.size()",
    "assert lengths.size() == indices.size()",
    "mask_random = mask_random[uncompleted]",
    "delete token",
    "keep index, but replace it with [MASK]",
    "random ratio disabled",
    "source[indices[mask_random]] = torch.randint(",
    "1, len(self.vocab), size=(mask_random.sum(),))",
    "else:",
    "# A bit faster when all lengths are 1",
    "while indices.size(0) > 0:",
    "uncompleted = is_word_start[indices + 1] == 0",
    "indices = indices[uncompleted] + 1",
    "mask_random = mask_random[uncompleted]",
    "if self.replace_length != -1:",
    "# delete token",
    "to_keep[indices] = 0",
    "else:",
    "# keep index, but replace it with [MASK]",
    "source[indices] = self.mask_idx",
    "source[indices[mask_random]] = torch.randint(",
    "1, len(self.vocab), size=(mask_random.sum(),))",
    "assert source_length - 1 not in indices",
    "aeq(source.eq(self.pad_idx).long().sum(), 0)",
    "random ratio disabled",
    "num_random = int(math.ceil(n * self.random_ratio))",
    "result[noise_indices[:num_random]] = torch.randint(",
    "low=1, high=len(self.vocab), size=(num_random,))",
    "assert (result >= 0).all()",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "when reasonable, set audio_enc_pooling to 2",
    "Need lengths >= audio_enc_pooling**n_layers.",
    "That condition is unrealistic for large n_layers,",
    "so leave audio_enc_pooling at 1.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "BoolTensor was introduced in pytorch 1.2",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "unscaled optimizer's gradients (already done therefore skip),",
    "skips optimizer.step() if gradients contain infs/NaNs.",
    "Updates the scale for next iteration.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "List[Tuple[str, Vocab]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "Dict[str, List[Tuple[str, Field]]]",
    "doesn't change structure - don't return early.",
    "Dict[str, List[Tuple[str, Field]]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "self.weights = opt.data_weights",
    "Temporarily load one shard to retrieve sort_key for data_type",
    "NOTE: This is causing some issues for consumer/producer,",
    "as we may still have some of those examples in some queue",
    "cur_dataset.examples = None",
    "gc.collect()",
    "del cur_dataset",
    "gc.collect()",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "create one counter per shard",
    "every corpus has shards, no new one",
    "patch corpus_id",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Fix CPU tensor sharing strategy",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "patch for fields that may be missing in old data/model",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "generator_to_serve = iter(generator_to_serve)",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "magic indices",
    "result caching",
    "fix length constraint",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "pickups: Tensor where specified index were set to 1, others 0",
    "dropdowns: opposite of pickups, 1 for those shouldn't pick",
    "Minus dropdowns to log_probs making probabilities of",
    "unspecified index close to 0",
    "prediction step have surpass length of given target_prefix,",
    "no need to further change this attr",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "maybe fix some prediction at this step by modifying log_probs",
    "shape: (sum(~ self.is_finished), 1)",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "corpus_id field is useless here",
    "Statistics",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "beam parameters",
    "result caching",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "maybe fix some prediction at this step by modifying log_probs",
    "Flatten probs into a list of possibilities.",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Pick up candidate token by curr_scores",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "load can be called multiple times: modify copy",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "1.1.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "degenerate case",
    "cache the features",
    "mp queues don't work well between procs unless they're from a manager",
    "each device has its own saver so that reconstructing is easier",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for back compat when attention_dropout was not defined",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "if you want to pass an existing vocab.pt file, pass it to",
    "-src_vocab alone as it already contains tgt vocab.",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options for experimental source noising (BART style)",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use Tensorboard for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "noise_skip = batch.noise_skip",
    "aeq(len(batch.noise_skip) == source.size(1))",
    "source is [src_len x bs x feats]",
    "source might increase length so we need to resize the whole",
    "tensor",
    "remove useless pad",
    "def s(self, tokens):",
    "prob = self.prob",
    "r = torch.rand([len(tokens)])",
    "mask = False",
    "masked = []",
    "for i, tok in enumerate(tokens):",
    "if tok.startswith(subword_prefix):",
    "if r[i].item() <= prob:",
    "masked.append(mask_tok)",
    "mask = True",
    "else:",
    "masked.append(tok)",
    "mask = False",
    "else:",
    "if mask:",
    "pass",
    "else:",
    "masked.append(tok)",
    "return masked",
    "aeq(source.size(0), length)",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "aeq(source.size(0), length)",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "fairseq/data/denoising_dataset.py",
    "print(\"src size: \", source.size())",
    "print(\"ws size: \", self.word_start_mask.size())",
    "print(\"max: \", source.max())",
    "assert source.max() < self.word_start_mask.size(0)",
    "assert source.min() >= 0",
    "assert source.size() == is_word_start.size()",
    "aeq(source.eq(self.pad_idx).long().sum(), 0)",
    "we manually add this hypothesis since it's required for the rest",
    "of the function and kindof make sense",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert (lengths > 0).all()",
    "assert is_word_start[-1] == 0",
    "TODO why?",
    "assert source_length - 1 not in indices",
    "acts as a long length, so spans don't go over the end of doc",
    "keep index, but replace it with [MASK]",
    "random ratio disabled",
    "source[indices[mask_random]] = torch.randint(",
    "1, len(self.vocab), size=(mask_random.sum(),))",
    "if self.mask_span_distribution is not None:",
    "assert len(lengths.size()) == 1",
    "assert lengths.size() == indices.size()",
    "assert lengths.size() == indices.size()",
    "mask_random = mask_random[uncompleted]",
    "delete token",
    "keep index, but replace it with [MASK]",
    "random ratio disabled",
    "source[indices[mask_random]] = torch.randint(",
    "1, len(self.vocab), size=(mask_random.sum(),))",
    "else:",
    "# A bit faster when all lengths are 1",
    "while indices.size(0) > 0:",
    "uncompleted = is_word_start[indices + 1] == 0",
    "indices = indices[uncompleted] + 1",
    "mask_random = mask_random[uncompleted]",
    "if self.replace_length != -1:",
    "# delete token",
    "to_keep[indices] = 0",
    "else:",
    "# keep index, but replace it with [MASK]",
    "source[indices] = self.mask_idx",
    "source[indices[mask_random]] = torch.randint(",
    "1, len(self.vocab), size=(mask_random.sum(),))",
    "assert source_length - 1 not in indices",
    "aeq(source.eq(self.pad_idx).long().sum(), 0)",
    "random ratio disabled",
    "num_random = int(math.ceil(n * self.random_ratio))",
    "result[noise_indices[:num_random]] = torch.randint(",
    "low=1, high=len(self.vocab), size=(num_random,))",
    "assert (result >= 0).all()",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "when reasonable, set audio_enc_pooling to 2",
    "Need lengths >= audio_enc_pooling**n_layers.",
    "That condition is unrealistic for large n_layers,",
    "so leave audio_enc_pooling at 1.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "BoolTensor was introduced in pytorch 1.2",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the new AMP API from apex",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "List[Tuple[str, Vocab]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "Dict[str, List[Tuple[str, Field]]]",
    "doesn't change structure - don't return early.",
    "Dict[str, List[Tuple[str, Field]]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Temporarily load one shard to retrieve sort_key for data_type",
    "NOTE: This is causing some issues for consumer/producer,",
    "as we may still have some of those examples in some queue",
    "cur_dataset.examples = None",
    "gc.collect()",
    "del cur_dataset",
    "gc.collect()",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "create one counter per shard",
    "every corpus has shards, no new one",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "generator_to_serve = iter(generator_to_serve)",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "magic indices",
    "result caching",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "shape: (sum(~ self.is_finished), 1)",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "corpus_id field is useless here",
    "Statistics",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "beam parameters",
    "result caching",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "1.1.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "degenerate case",
    "cache the features",
    "mp queues don't work well between procs unless they're from a manager",
    "each device has its own saver so that reconstructing is easier",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for back compat when attention_dropout was not defined",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "if you want to pass an existing vocab.pt file, pass it to",
    "-src_vocab alone as it already contains tgt vocab.",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options for experimental source noising (BART style)",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use Tensorboard for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "noise_skip = batch.noise_skip",
    "aeq(len(batch.noise_skip) == source.size(1))",
    "source is [src_len x bs x feats]",
    "source might increase length so we need to resize the whole",
    "tensor",
    "remove useless pad",
    "def s(self, tokens):",
    "prob = self.prob",
    "r = torch.rand([len(tokens)])",
    "mask = False",
    "masked = []",
    "for i, tok in enumerate(tokens):",
    "if tok.startswith(subword_prefix):",
    "if r[i].item() <= prob:",
    "masked.append(mask_tok)",
    "mask = True",
    "else:",
    "masked.append(tok)",
    "mask = False",
    "else:",
    "if mask:",
    "pass",
    "else:",
    "masked.append(tok)",
    "return masked",
    "aeq(source.size(0), length)",
    "Pretend it ends with a full stop so last span is a sentence",
    "Tokens that are full stops, where the previous token is not",
    "aeq(source.size(0), length)",
    "-1: keep everything (i.e. 1 mask per token)",
    "0: replace everything (i.e. no mask)",
    "1: 1 mask per span",
    "fairseq/data/denoising_dataset.py",
    "print(\"src size: \", source.size())",
    "print(\"ws size: \", self.word_start_mask.size())",
    "print(\"max: \", source.max())",
    "assert source.max() < self.word_start_mask.size(0)",
    "assert source.min() >= 0",
    "assert source.size() == is_word_start.size()",
    "aeq(source.eq(self.pad_idx).long().sum(), 0)",
    "we manually add this hypothesis since it's required for the rest",
    "of the function and kindof make sense",
    "Make sure we have enough to mask",
    "Trim to masking budget",
    "Handle 0-length mask (inserts) separately",
    "assert (lengths > 0).all()",
    "assert is_word_start[-1] == 0",
    "TODO why?",
    "assert source_length - 1 not in indices",
    "acts as a long length, so spans don't go over the end of doc",
    "keep index, but replace it with [MASK]",
    "random ratio disabled",
    "source[indices[mask_random]] = torch.randint(",
    "1, len(self.vocab), size=(mask_random.sum(),))",
    "if self.mask_span_distribution is not None:",
    "assert len(lengths.size()) == 1",
    "assert lengths.size() == indices.size()",
    "assert lengths.size() == indices.size()",
    "mask_random = mask_random[uncompleted]",
    "delete token",
    "keep index, but replace it with [MASK]",
    "random ratio disabled",
    "source[indices[mask_random]] = torch.randint(",
    "1, len(self.vocab), size=(mask_random.sum(),))",
    "else:",
    "# A bit faster when all lengths are 1",
    "while indices.size(0) > 0:",
    "uncompleted = is_word_start[indices + 1] == 0",
    "indices = indices[uncompleted] + 1",
    "mask_random = mask_random[uncompleted]",
    "if self.replace_length != -1:",
    "# delete token",
    "to_keep[indices] = 0",
    "else:",
    "# keep index, but replace it with [MASK]",
    "source[indices] = self.mask_idx",
    "source[indices[mask_random]] = torch.randint(",
    "1, len(self.vocab), size=(mask_random.sum(),))",
    "assert source_length - 1 not in indices",
    "aeq(source.eq(self.pad_idx).long().sum(), 0)",
    "random ratio disabled",
    "num_random = int(math.ceil(n * self.random_ratio))",
    "result[noise_indices[:num_random]] = torch.randint(",
    "low=1, high=len(self.vocab), size=(num_random,))",
    "assert (result >= 0).all()",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "when reasonable, set audio_enc_pooling to 2",
    "Need lengths >= audio_enc_pooling**n_layers.",
    "That condition is unrealistic for large n_layers,",
    "so leave audio_enc_pooling at 1.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "BoolTensor was introduced in pytorch 1.2",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the new AMP API from apex",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "No alignment if not exist valid tgt token",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "List[Tuple[str, Vocab]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "Dict[str, List[Tuple[str, Field]]]",
    "doesn't change structure - don't return early.",
    "Dict[str, List[Tuple[str, Field]]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Temporarily load one shard to retrieve sort_key for data_type",
    "NOTE: This is causing some issues for consumer/producer,",
    "as we may still have some of those examples in some queue",
    "cur_dataset.examples = None",
    "gc.collect()",
    "del cur_dataset",
    "gc.collect()",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "create one counter per shard",
    "every corpus has shards, no new one",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "generator_to_serve = iter(generator_to_serve)",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "magic indices",
    "result caching",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "shape: (sum(~ self.is_finished), 1)",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "corpus_id field is useless here",
    "Statistics",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "beam parameters",
    "result caching",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "perform a first request to initialize everything",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "every segment becomes a dict for flexibility purposes",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "1.0.2": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "degenerate case",
    "cache the features",
    "mp queues don't work well between procs unless they're from a manager",
    "each device has its own saver so that reconstructing is easier",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for back compat when attention_dropout was not defined",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "if you want to pass an existing vocab.pt file, pass it to",
    "-src_vocab alone as it already contains tgt vocab.",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use Tensorboard for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "when reasonable, set audio_enc_pooling to 2",
    "Need lengths >= audio_enc_pooling**n_layers.",
    "That condition is unrealistic for large n_layers,",
    "so leave audio_enc_pooling at 1.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "BoolTensor was introduced in pytorch 1.2",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the new AMP API from apex",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "List[Tuple[str, Vocab]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "Dict[str, List[Tuple[str, Field]]]",
    "doesn't change structure - don't return early.",
    "Dict[str, List[Tuple[str, Field]]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Temporarily load one shard to retrieve sort_key for data_type",
    "NOTE: This is causing some issues for consumer/producer,",
    "as we may still have some of those examples in some queue",
    "cur_dataset.examples = None",
    "gc.collect()",
    "del cur_dataset",
    "gc.collect()",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "create one counter per shard",
    "every corpus has shards, no new one",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "generator_to_serve = iter(generator_to_serve)",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "magic indices",
    "result caching",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "shape: (sum(~ self.is_finished), 1)",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "Statistics",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "beam parameters",
    "result caching",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "1.0.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "degenerate case",
    "cache the features",
    "mp queues don't work well between procs unless they're from a manager",
    "each device has its own saver so that reconstructing is easier",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for back compat when attention_dropout was not defined",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "if you want to pass an existing vocab.pt file, pass it to",
    "-src_vocab alone as it already contains tgt vocab.",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use Tensorboard for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "when reasonable, set audio_enc_pooling to 2",
    "Need lengths >= audio_enc_pooling**n_layers.",
    "That condition is unrealistic for large n_layers,",
    "so leave audio_enc_pooling at 1.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "T: could be 1 in the case of stepwise decoding or tgt_len",
    "BoolTensor was introduced in pytorch 1.2",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the new AMP API from apex",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "List[Tuple[str, Vocab]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "Dict[str, List[Tuple[str, Field]]]",
    "doesn't change structure - don't return early.",
    "Dict[str, List[Tuple[str, Field]]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Temporarily load one shard to retrieve sort_key for data_type",
    "NOTE: This is causing some issues for consumer/producer,",
    "as we may still have some of those examples in some queue",
    "cur_dataset.examples = None",
    "gc.collect()",
    "del cur_dataset",
    "gc.collect()",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "create one counter per shard",
    "every corpus has shards, no new one",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "generator_to_serve = iter(generator_to_serve)",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "magic indices",
    "result caching",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "shape: (sum(~ self.is_finished), 1)",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "Statistics",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "beam parameters",
    "result caching",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "1.0.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "degenerate case",
    "cache the features",
    "mp queues don't work well between procs unless they're from a manager",
    "each device has its own saver so that reconstructing is easier",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for back compat when attention_dropout was not defined",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Alignement options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "if you want to pass an existing vocab.pt file, pass it to",
    "-src_vocab alone as it already contains tgt vocab.",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use Tensorboard for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "swap model params w/ moving average",
    "(and keep the original parameters)",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return multi-head attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "before repeat, scores are either 0 or -inf",
    "on repeat, `repeat_idx` score is BLOCKED_SCORE",
    "(but it's still the best score, thus we have",
    "[BLOCKED_SCORE, -inf, -inf, -inf, -inf]",
    "repetitions keeps maximizing score",
    "index 0 has been blocked, so repeating=>+0.0 score",
    "other indexes are -inf so repeating=>BLOCKED_SCORE",
    "which is higher",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "inp_lens is tiled in initialize, reassign to make attn match",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "when reasonable, set audio_enc_pooling to 2",
    "Need lengths >= audio_enc_pooling**n_layers.",
    "That condition is unrealistic for large n_layers,",
    "so leave audio_enc_pooling at 1.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "return _, (B, Q_len, K_len)",
    "layer average attention across heads, get ``(B, Q, K)``",
    "Case 1: no full_context, no align heads -> layer avg baseline",
    "Case 2: no full_context, 1 align heads -> guided align",
    "Case 3: full_context, 1 align heads -> full cte guided align",
    "TODO: change 1 to T as T could be 1 or tgt_len",
    "BoolTensor was introduced in pytorch 1.2",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "attns[\"align\"] = torch.stack(attn_aligns, 0).mean(0)  # All avg",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the new AMP API from apex",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "attn_align should be in (batch_size, pad_tgt_size, pad_src_size)",
    "align_idx should be a Tensor in size([N, 3]), N is total number",
    "of align src-tgt pair in current batch, each as",
    "['sent_N\u00b0_in_batch', 'tgt_id+1', 'src_id'] (check AlignField)",
    "NOTE: tgt-src ref alignement that in range_ of shard",
    "(coherent with batch.tgt)",
    "align_head contains value in [0, 1) presenting attn prob,",
    "0 was resulted by the context attention src_pad_mask",
    "So, the correspand position in ref_align should also be 0",
    "Therefore, clip align_head to > 1e-18 should be bias free.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "threshold on 1 to avoid div by 0",
    "treat alignment matrix one by one as each have different lengths",
    "get valid alignment (sub-matrix from full paded aligment matrix)",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "we need to check the model path + any tokenizer path",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "+1 for tgt side to keep coherent after \"bos\" padding,",
    "register ['N\u00b0_in_batch', 'tgt_id+1', 'src_id']",
    "List[Tuple[str, Vocab]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "Dict[str, List[Tuple[str, Field]]]",
    "doesn't change structure - don't return early.",
    "Dict[str, List[Tuple[str, Field]]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Temporarily load one shard to retrieve sort_key for data_type",
    "NOTE: This is causing some issues for consumer/producer,",
    "as we may still have some of those examples in some queue",
    "cur_dataset.examples = None",
    "gc.collect()",
    "del cur_dataset",
    "gc.collect()",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "create one counter per shard",
    "every corpus has shards, no new one",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "generator_to_serve = iter(generator_to_serve)",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "magic indices",
    "result caching",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "we don't block nothing if the user doesn't want it",
    "we can't block nothing beam's too short",
    "we check paths one by one",
    "we don't forbid nothing if the user doesn't want it",
    "we can't forbid nothing if beam's too short",
    "Reordering forbidden_tokens following beam selection",
    "We rebuild a dict to ensure we get the value and not the pointer",
    "Grabing the newly selected tokens and associated ngram",
    "skip the blocking if any token in current_ngram is excluded",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "shape: (sum(~ self.is_finished), 1)",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "Statistics",
    "(0) add BOS and padding to tgt prediction",
    "(1) Encoder forward.",
    "(2) Repeat src objects `n_best` times.",
    "We use batch_size x n_best, get ``(src_len, batch * n_best, nfeat)``",
    "(3) Init decoder with n_best src,",
    "reshape tgt to ``(len, batch * n_best, nfeat)``",
    "masked_select",
    "get aligned src id for each prediction's valid tgt tokens",
    "TODO: support these blacklisted features",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) prep decode_strategy. Possibly repeat src objects.",
    "(3) Begin decoding step by step:",
    "Reorder states.",
    "beam parameters",
    "result caching",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "\"global state\" of the old beam",
    "buffers for the topk scores and 'backpointer'",
    "for testing",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Avoid any direction that would repeat unwanted ngrams",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "build back results with empty texts",
    "output contain alignment",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "1.0.0.rc1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "degenerate case",
    "cache the features",
    "mp queues don't work well between procs unless they're from a manager",
    "each device has its own saver so that reconstructing is easier",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for back compat when attention_dropout was not defined",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "if you want to pass an existing vocab.pt file, pass it to",
    "-src_vocab alone as it already contains tgt vocab.",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use Tensorboard for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "first beam finished had length beam.min_length",
    "first beam finished was 0",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "[2, 5, 3, 6, 0], so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010]",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0], so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "predict repeat_idx over and over again",
    "batch 0 and 7 will repeat, the rest will advance",
    "predict the same thing in batch 0 and 7 every i",
    "push around what the other batches predict",
    "now batch 0 and 7 die",
    "batch 0 will repeat excluded idx, batch 1 will repeat",
    "now batch 1 dies",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "when reasonable, set audio_enc_pooling to 2",
    "Need lengths >= audio_enc_pooling**n_layers.",
    "That condition is unrealistic for large n_layers,",
    "so leave audio_enc_pooling at 1.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "BoolTensor was introduced in pytorch 1.2",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "we use here a FusedAdam() copy of an old Apex repo",
    "In this case use the new AMP API from apex",
    "In this case use the old FusedAdam with FP16_optimizer wrapper",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "backward compatibility",
    "assuming a list/generator of parameter means single group",
    "compute combined scale factor for this group",
    "norm is in fact norm*scale",
    "note: p.grad should not ever be set for correct operation of",
    "mixed precision optimizer that sometimes sends None gradients",
    "State initialization",
    "Exponential moving average of gradient values",
    "Exponential moving average of squared gradient values",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "List[Tuple[str, Vocab]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "Dict[str, List[Tuple[str, Field]]]",
    "doesn't change structure - don't return early.",
    "Dict[str, List[Tuple[str, Field]]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Temporarily load one shard to retrieve sort_key for data_type",
    "NOTE: This is causing some issues for consumer/producer,",
    "as we may still have some of those examples in some queue",
    "cur_dataset.examples = None",
    "gc.collect()",
    "del cur_dataset",
    "gc.collect()",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "create one counter per shard",
    "every corpus has shards, no new one",
    "!/usr/bin/env python",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "generator_to_serve = iter(generator_to_serve)",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "assumes there are len(word_probs) predictions OTHER",
    "than EOS that are greater than -1e20",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "shape: (sum(~ self.is_finished), 1)",
    "magic indices",
    "result caching",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "skip BOS",
    "Last n tokens, n = block_ngram_repeat",
    "skip the blocking if any token in gram is excluded",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "Statistics",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Shape: (1, B, 1)",
    "Reorder states.",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "TODO: support these blacklisted features.",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use batch_size x beam_size",
    "(0) pt 2, prep the beam object",
    "Reorder states.",
    "This is left in the code for now, but unsued",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use now  batch_size x beam_size (same as fast mode)",
    "(3) run the decoder to generate sentences, using beam search.",
    "(a) Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "(b) Decode and forward",
    "(c) Advance each beam.",
    "Loop over the batch_size number of beam",
    "(4) Extract sentences from beam.",
    "Rollback pointer to the beginning.",
    "beam parameters",
    "result caching",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "buffers for the topk scores and 'backpointer'",
    "\"global state\" of the old beam",
    "for testing",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "0.9.2": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "generator_to_serve = iter(generator_to_serve)",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "degenerate case",
    "cache the features",
    "mp queues don't work well between procs unless they're from a manager",
    "each device has its own saver so that reconstructing is easier",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for back compat when attention_dropout was not defined",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "if you want to pass an existing vocab.pt file, pass it to",
    "-src_vocab alone as it already contains tgt vocab.",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use Tensorboard for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "first beam finished had length beam.min_length",
    "first beam finished was 0",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "[2, 5, 3, 6, 0], so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010]",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0], so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "predict repeat_idx over and over again",
    "batch 0 and 7 will repeat, the rest will advance",
    "predict the same thing in batch 0 and 7 every i",
    "push around what the other batches predict",
    "now batch 0 and 7 die",
    "batch 0 will repeat excluded idx, batch 1 will repeat",
    "now batch 1 dies",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "when reasonable, set audio_enc_pooling to 2",
    "Need lengths >= audio_enc_pooling**n_layers.",
    "That condition is unrealistic for large n_layers,",
    "so leave audio_enc_pooling at 1.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "BoolTensor was introduced in pytorch 1.2",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "List[Tuple[str, Vocab]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "Dict[str, List[Tuple[str, Field]]]",
    "doesn't change structure - don't return early.",
    "Dict[str, List[Tuple[str, Field]]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Temporarily load one shard to retrieve sort_key for data_type",
    "NOTE: This is causing some issues for consumer/producer,",
    "as we may still have some of those examples in some queue",
    "cur_dataset.examples = None",
    "gc.collect()",
    "del cur_dataset",
    "gc.collect()",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "assumes there are len(word_probs) predictions OTHER",
    "than EOS that are greater than -1e20",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "shape: (sum(~ self.is_finished), 1)",
    "magic indices",
    "result caching",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "skip BOS",
    "Last n tokens, n = block_ngram_repeat",
    "skip the blocking if any token in gram is excluded",
    "!/usr/bin/env python",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "max_tgt_in_batch = 0",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "for debugging",
    "Statistics",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Shape: (1, B, 1)",
    "Reorder states.",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "TODO: support these blacklisted features.",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use batch_size x beam_size",
    "(0) pt 2, prep the beam object",
    "Reorder states.",
    "This is left in the code for now, but unsued",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use now  batch_size x beam_size (same as fast mode)",
    "(3) run the decoder to generate sentences, using beam search.",
    "(a) Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "(b) Decode and forward",
    "(c) Advance each beam.",
    "Loop over the batch_size number of beam",
    "(4) Extract sentences from beam.",
    "Rollback pointer to the beginning.",
    "beam parameters",
    "result caching",
    "beam state",
    "BoolTensor was introduced in pytorch 1.2",
    "buffers for the topk scores and 'backpointer'",
    "\"global state\" of the old beam",
    "for testing",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting",
    "Chinese segmentation",
    "Chinese simplify -> Chinese traditional standard",
    "Chinese simplify -> Chinese traditional (HongKong)",
    "Chinese simplify -> Chinese traditional (Taiwan)",
    "Chinese traditional -> Chinese simplify (v1)",
    "Chinese traditional -> Chinese simplify (v2)"
  ],
  "0.9.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "generator_to_serve = iter(generator_to_serve)",
    "hack to dodge unpicklable `dict_keys`",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "if you want to pass an existing vocab.pt file, pass it to",
    "-src_vocab alone as it already contains tgt vocab.",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "first beam finished had length beam.min_length",
    "first beam finished was 0",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "[2, 5, 3, 6, 0], so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010]",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0], so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "predict repeat_idx over and over again",
    "batch 0 and 7 will repeat, the rest will advance",
    "predict the same thing in batch 0 and 7 every i",
    "push around what the other batches predict",
    "now batch 0 and 7 die",
    "batch 0 will repeat excluded idx, batch 1 will repeat",
    "now batch 1 dies",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "when reasonable, set audio_enc_pooling to 2",
    "Need lengths >= audio_enc_pooling**n_layers.",
    "That condition is unrealistic for large n_layers,",
    "so leave audio_enc_pooling at 1.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "List[Tuple[str, Vocab]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "Dict[str, List[Tuple[str, Field]]]",
    "doesn't change structure - don't return early.",
    "Dict[str, List[Tuple[str, Field]]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Temporarily load one shard to retrieve sort_key for data_type",
    "NOTE: This is causing some issues for consumer/producer,",
    "as we may still have some of those examples in some queue",
    "cur_dataset.examples = None",
    "gc.collect()",
    "del cur_dataset",
    "gc.collect()",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "NOTE: We need to trim the vocab to remove any unk tokens that",
    "were not originally here.",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "assumes there are len(word_probs) predictions OTHER",
    "than EOS that are greater than -1e20",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "shape: (sum(~ self.is_finished), 1)",
    "magic indices",
    "result caching",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "skip BOS",
    "Last n tokens, n = block_ngram_repeat",
    "skip the blocking if any token in gram is excluded",
    "!/usr/bin/env python",
    "for debugging",
    "Statistics",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Shape: (1, B, 1)",
    "Reorder states.",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "TODO: support these blacklisted features.",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use batch_size x beam_size",
    "(0) pt 2, prep the beam object",
    "Reorder states.",
    "This is left in the code for now, but unsued",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use now  batch_size x beam_size (same as fast mode)",
    "(3) run the decoder to generate sentences, using beam search.",
    "(a) Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "(b) Decode and forward",
    "(c) Advance each beam.",
    "Loop over the batch_size number of beam",
    "(4) Extract sentences from beam.",
    "Rollback pointer to the beginning.",
    "beam parameters",
    "result caching",
    "beam state",
    "buffers for the topk scores and 'backpointer'",
    "\"global state\" of the old beam",
    "for testing",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting"
  ],
  "0.9.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "Read in embeddings",
    "Write to file",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "if you want to pass an existing vocab.pt file, pass it to",
    "-src_vocab alone as it already contains tgt vocab.",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "UPDATE DROPOUT",
    "Run patience mechanism",
    "If the patience has reached the limit, stop training",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "we avoid padding while mean pooling",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "first beam finished had length beam.min_length",
    "first beam finished was 0",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "[2, 5, 3, 6, 0], so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010]",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0], so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "predict repeat_idx over and over again",
    "batch 0 and 7 will repeat, the rest will advance",
    "predict the same thing in batch 0 and 7 every i",
    "push around what the other batches predict",
    "now batch 0 and 7 die",
    "batch 0 will repeat excluded idx, batch 1 will repeat",
    "now batch 1 dies",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "when reasonable, set audio_enc_pooling to 2",
    "Need lengths >= audio_enc_pooling**n_layers.",
    "That condition is unrealistic for large n_layers,",
    "so leave audio_enc_pooling at 1.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "TODO: clean this up when APEX unify its optimizer API.",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Don't do anything",
    "Update best score of each criteria",
    "Reset tolerance",
    "Update current status",
    "Decrease tolerance",
    "Log",
    "Log",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "List[Tuple[str, Vocab]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "Dict[str, List[Tuple[str, Field]]]",
    "doesn't change structure - don't return early.",
    "Dict[str, List[Tuple[str, Field]]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "return vocab to dump with standard name",
    "empty train_dataset_files so that vocab is only loaded from",
    "given paths in src_vocab_path, tgt_vocab_path",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "fast-forward if loaded from state",
    "NOTE: `rnn.pack_padded_sequence` requires that a",
    "minibatch be sorted by decreasing order, which",
    "requires reversing relative to typical sort keys",
    "Temporarily load one shard to retrieve sort_key for data_type",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "assumes there are len(word_probs) predictions OTHER",
    "than EOS that are greater than -1e20",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "shape: (sum(~ self.is_finished), 1)",
    "magic indices",
    "result caching",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "skip BOS",
    "Last n tokens, n = block_ngram_repeat",
    "skip the blocking if any token in gram is excluded",
    "!/usr/bin/env python",
    "for debugging",
    "Statistics",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Shape: (1, B, 1)",
    "Reorder states.",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "TODO: support these blacklisted features.",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use batch_size x beam_size",
    "(0) pt 2, prep the beam object",
    "Reorder states.",
    "This is left in the code for now, but unsued",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use now  batch_size x beam_size (same as fast mode)",
    "(3) run the decoder to generate sentences, using beam search.",
    "(a) Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "(b) Decode and forward",
    "(c) Advance each beam.",
    "Loop over the batch_size number of beam",
    "(4) Extract sentences from beam.",
    "Rollback pointer to the beginning.",
    "beam parameters",
    "result caching",
    "beam state",
    "buffers for the topk scores and 'backpointer'",
    "\"global state\" of the old beam",
    "for testing",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting"
  ],
  "0.8.2": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Show base classes",
    "Use \"variables\" section for Attributes instead of weird block things",
    "mimicking the function style.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "NOTE: It's important that ``opt`` has been validated and updated",
    "at this point.",
    "Load checkpoint if we resume from a previous training.",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "first beam finished had length beam.min_length",
    "first beam finished was 0",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "[2, 5, 3, 6, 0], so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010]",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0], so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "predict repeat_idx over and over again",
    "batch 0 and 7 will repeat, the rest will advance",
    "predict the same thing in batch 0 and 7 every i",
    "push around what the other batches predict",
    "now batch 0 and 7 die",
    "batch 0 will repeat excluded idx, batch 1 will repeat",
    "now batch 1 dies",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "this could be considered an integration test because it touches",
    "the filesystem for the config file (and the models)",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "when reasonable, set audio_enc_pooling to 2",
    "Need lengths >= audio_enc_pooling**n_layers.",
    "That condition is unrealistic for large n_layers,",
    "so leave audio_enc_pooling at 1.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "TODO: clean this up when APEX unify its optimizer API.",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load default opt values, then overwrite with the opts in",
    "the checkpoint. That way, if there are new options added,",
    "the defaults are used.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "fields needs to have only keys that examples have as attrs",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "List[Tuple[str, Vocab]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "Dict[str, List[Tuple[str, Field]]]",
    "doesn't change structure - don't return early.",
    "Dict[str, List[Tuple[str, Field]]] -> List[Tuple[str, Field]]",
    "-> dict[str, Field]",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "assumes there are len(word_probs) predictions OTHER",
    "than EOS that are greater than -1e20",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "shape: (sum(~ self.is_finished), 1)",
    "magic indices",
    "result caching",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "skip BOS",
    "Last n tokens, n = block_ngram_repeat",
    "skip the blocking if any token in gram is excluded",
    "!/usr/bin/env python",
    "for debugging",
    "Statistics",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Shape: (1, B, 1)",
    "Reorder states.",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "TODO: support these blacklisted features.",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use batch_size x beam_size",
    "(0) pt 2, prep the beam object",
    "Reorder states.",
    "This is left in the code for now, but unsued",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use now  batch_size x beam_size (same as fast mode)",
    "(3) run the decoder to generate sentences, using beam search.",
    "(a) Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "(b) Decode and forward",
    "(c) Advance each beam.",
    "Loop over the batch_size number of beam",
    "(4) Extract sentences from beam.",
    "Rollback pointer to the beginning.",
    "beam parameters",
    "result caching",
    "beam state",
    "buffers for the topk scores and 'backpointer'",
    "\"global state\" of the old beam",
    "for testing",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "!/usr/bin/env python",
    "semaphore doesn't have a timeout arg in Python 2.7",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting"
  ],
  "0.8.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for backward compatibility",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load checkpoint if we resume from a previous training.",
    "Load default opts values then overwrite it with opts from",
    "the checkpoint. It's usefull in order to re-train a model",
    "after adding a new option (not set in checkpoint)",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "this line is kind of a temporary kludge because different objects expect",
    "fields to have a different structure",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "first beam finished had length beam.min_length",
    "first beam finished was 0",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "[2, 5, 3, 6, 0], so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010]",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0], so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "predict repeat_idx over and over again",
    "batch 0 and 7 will repeat, the rest will advance",
    "predict the same thing in batch 0 and 7 every i",
    "push around what the other batches predict",
    "now batch 0 and 7 die",
    "batch 0 will repeat excluded idx, batch 1 will repeat",
    "now batch 1 dies",
    "batch 0 will always predict EOS. The other batches will predict",
    "non-eos scores.",
    "\"best\" prediction is eos - that should be blocked",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "now batch 0 has ended and no others have",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "initial step",
    "batch 0 dies on step 0",
    "include at least one prediction OTHER than EOS",
    "that is greater than -1e20",
    "step 2",
    "(old) batch 8 dies on step 1",
    "step 3",
    "everything dies",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "no top beams are finished yet",
    "beam 1 dies on min_length",
    "no top beams are finished yet",
    "beam 0 dies on the step after beam 1 dies",
    "top beam is finished now so there are attentions",
    "two beams are finished in each batch",
    "second dim is cut down to the non-padded src length",
    "first dim is equal to the time of death",
    "(beam 0 died at current step - adjust for SOS)",
    "(beam 1 died at last step - adjust for SOS)",
    "behavior gets weird when beam is already done so just stop",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "TODO: clean this up when APEX unify its optimizer API.",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "the dataset's self.fields should have the same attributes as examples",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "assumes there are len(word_probs) predictions OTHER",
    "than EOS that are greater than -1e20",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -10000.",
    "This puts the probabilities close to 0.",
    "shape: (sum(~ self.is_finished), 1)",
    "magic indices",
    "result caching",
    "add one to account for BOS. Don't account for EOS because hitting",
    "this implies it hasn't been found.",
    "skip BOS",
    "Last n tokens, n = block_ngram_repeat",
    "skip the blocking if any token in gram is excluded",
    "!/usr/bin/env python",
    "for debugging",
    "Statistics",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Shape: (1, B, 1)",
    "Reorder states.",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "TODO: support these blacklisted features.",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use batch_size x beam_size",
    "(0) pt 2, prep the beam object",
    "Reorder states.",
    "This is left in the code for now, but unsued",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use now  batch_size x beam_size (same as fast mode)",
    "(3) run the decoder to generate sentences, using beam search.",
    "(a) Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "(b) Decode and forward",
    "(c) Advance each beam.",
    "Loop over the batch_size number of beam",
    "(4) Extract sentences from beam.",
    "Rollback pointer to the beginning.",
    "beam parameters",
    "result caching",
    "beam state",
    "buffers for the topk scores and 'backpointer'",
    "\"global state\" of the old beam",
    "for testing",
    "using integer division to get an integer _B without casting",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and map to batch index flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "!/usr/bin/env python",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting"
  ],
  "0.8.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for backward compatibility",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load checkpoint if we resume from a previous training.",
    "Load default opts values then overwrite it with opts from",
    "the checkpoint. It's usefull in order to re-train a model",
    "after adding a new option (not set in checkpoint)",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "this line is kind of a temporary kludge because different objects expect",
    "fields to have a different structure",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "1 or key_len x key_len",
    "1 or key_len x key_len x dim_per_head",
    "1 or key_len x key_len x dim_per_head",
    "2) Calculate and scale scores.",
    "batch x num_heads x query_len x key_len",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "beam includes start token in cur_len count.",
    "Add one to its min_length to compensate",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "first beam finished had length beam.min_length",
    "first beam finished was 0",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "beam includes start token in cur_len count.",
    "Add one to its min_length to compensate",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "[2, 5, 3, 6, 0], so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010]",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0], so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "initialize fields at the top of each unit test to prevent",
    "any undesired stateful effects",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "write utf-8 bytes",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-*- coding: utf-8 -*-",
    "tests pad and numericalize integration",
    "tests pad and numericalize integration",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to audio data",
    "file to hold audio paths relative to _AUDIO_DATA_DIR (i.e. file names)",
    "it's ok if non-audio files co-exist with audio files in the data dir",
    "dividing gets the noise in [-1, 1]",
    "this test touches the file system, so it could be considered an",
    "integration test",
    "file to hold full paths to image data",
    "file to hold image paths relative to _IMG_DATA_DIR (i.e. file names)",
    "it's ok if non-image files co-exist with image files in the data dir",
    "all beams repeat (beam >= 1 repeat dummy scores)",
    "predict repeat_idx over and over again",
    "beam 0 and beam >=2 will repeat (beam >= 2 repeat dummy scores)",
    "non-interesting beams are going to get dummy values",
    "on initial round, only predicted scores for beam 0",
    "matter. Make two predictions. Top one will be repeated",
    "in beam zero, second one will live on in beam 1.",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "now beam 0 dies (along with the others), beam 1 -> beam 0",
    "beam 0 and beam >= 2 will repeat (beam 2 repeats excluded idx)",
    "non-interesting beams are going to get dummy values",
    "predict the same thing in beam 0",
    "continue pushing around what beam 1 predicts",
    "predict the allowed-repeat again in beam 2",
    "now beam 0 dies, beam 1 -> beam 0, beam 2 -> beam 1",
    "and the rest die",
    "since all preds after i=0 are 0, we can check",
    "that the beam is the correct idx by checking that",
    "the curr score is the initial score",
    "beam 0 will always predict EOS. The other beams will predict",
    "non-eos scores.",
    "beam includes start token in cur_len count.",
    "Add one to its min_length to compensate",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 0",
    "provide beam_sz other good predictions",
    "now the top beam has ended and no others have",
    "not of interest, but want to make sure it keeps running",
    "since only beam 0 terminates and n_best = 2",
    "this is also a test that when block_ngram_repeat=0,",
    "repeating is acceptable",
    "beam includes start token in cur_len count.",
    "Add one to its min_length to compensate",
    "non-interesting beams are going to get dummy values",
    "\"best\" prediction is eos - that should be blocked",
    "include at least beam_sz predictions OTHER than EOS",
    "that are greater than -1e20",
    "predict eos in beam 1",
    "provide beam_sz other good predictions in other beams",
    "provide beam_sz other good predictions in other beams",
    "beam 1 dies on min_length",
    "beam 0 dies on the step after beam 1 dies",
    "this is just test_beam.TestBeamAgainstReferenceCase repeated",
    "in each batch.",
    "init_preds: [4, 3, 5, 6, 7] - no EOS's",
    "no EOS's yet",
    "[5, 3, 2, 6, 0], so beam 2 predicts EOS!",
    "assumes beam 2 finished on last step",
    "ended beam 2 shouldn't continue",
    "[2, 5, 3, 6, 0] repeat self.BATCH_SZ, so beam 0 predicts EOS!",
    "[-2.4879, -3.8910, -4.1010, -4.2010, -4.4010] repeat self.BATCH_SZ",
    "another beam is finished in all batches",
    "new beam 0 finished",
    "new beam 0 is old beam 3",
    "assumes beam 0 finished on last step",
    "[5, 2, 6, 1, 0] repeat self.BATCH_SZ, so beam 1 predicts EOS!",
    "new beam 1 finished",
    "new beam 1 is old beam 4",
    "this could be considered an integration test because it tests",
    "interactions between the GNMT scorer and the beam",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "TODO: clean this up when APEX unify its optimizer API.",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Shift values to be >= 0",
    "coding: utf-8",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "the dataset's self.fields should have the same attributes as examples",
    "avoid infinite recursion when fields isn't defined",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "monkey-patch to make torchtext Vocab's pickleable",
    "if tgt isn't using TextMultiField, then no text field is.",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "Cycle through the shards indefinitely.",
    "When the dataset is not repeated, we might need to ensure that",
    "the number of returned batches is the multiple of a given value.",
    "This is important for multi GPU training to ensure that all",
    "workers have the same number of batches to process.",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wM <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "assumes there are len(word_probs) predictions OTHER",
    "than EOS that are greater than -1e20",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "these warnings indicate that either the alpha/beta",
    "forces a penalty to be a no-op, or a penalty is a no-op but",
    "the alpha/beta would suggest otherwise.",
    "using some length penalty",
    "using some coverage penalty",
    "!/usr/bin/env python",
    "for debugging",
    "Statistics",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -1000.",
    "This puts the probabilities close to 0.",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "seq_so_far contains chosen tokens; on each step, dim 1 grows by one.",
    "Note that what this code calls log_probs are actually logits.",
    "Append last prediction.",
    "Store finished hypotheses for this batch. Unlike in beam search,",
    "there will only ever be 1 hypothesis per example.",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "TODO: support these blacklisted features.",
    "(0) Prep the components of the search.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use batch_size x beam_size",
    "(0) pt 2, prep the beam object",
    "Reorder states.",
    "This is left in the code for now, but unsued",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use now  batch_size x beam_size (same as fast mode)",
    "(3) run the decoder to generate sentences, using beam search.",
    "(a) Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "(b) Decode and forward",
    "(c) Advance each beam.",
    "Loop over the batch_size number of beam",
    "(4) Extract sentences from beam.",
    "Rollback pointer to the beginning.",
    "magic indices",
    "beam parameters",
    "result caching",
    "beam state",
    "\"global state\" of the old beam",
    "for testing",
    "force the output to be longer than self.min_length",
    "Multiply probs by the beam probability.",
    "block ngram repeats",
    "iterate over all batches, over all beams",
    "Last n tokens, n = block_ngram_repeat",
    "skip the blocking if any token in gram is excluded",
    "if the sequence ends now, then the penalty is the current",
    "length + 1, to include the EOS token",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Length penalty is just a scalar. It doesn't matter if it's applied",
    "before or after the topk.",
    "Resolve beam origin and true word ids.",
    "Map beam_index to batch_index in the flat representation.",
    "Append last prediction.",
    "update global state (step == 1)",
    "update global state (step > 1)",
    "shape: (batch_size x beam_size, 1)",
    "Penalize beams that finished.",
    "on real data (newstest2017) with the pretrained transformer,",
    "it's faster to not move this back to the original device",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "!/usr/bin/env python",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Below are all the different penalty terms implemented so far.",
    "Subtract coverage penalty from topk log probs.",
    "Divide topk log probs by length penalty.",
    "Sorting"
  ],
  "0.7.2": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for backward compatibility",
    "Build embeddings.",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load checkpoint if we resume from a previous training.",
    "Load default opts values then overwrite it with opts from",
    "the checkpoint. It's usefull in order to re-train a model",
    "after adding a new option (not set in checkpoint)",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "this line is kind of a temporary kludge because different objects expect",
    "fields to have a different structure",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "Run the forward pass of every layer of the tranformer.",
    "why is the model_opt.__dict__ check necessary?",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "features must use word_vec_size",
    "features will use feat_vec_size",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "2) Calculate and scale scores.",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "first check there's nothing unexpectedly not trainable",
    "ok: word embeddings shouldn't be trainable",
    "if word vecs are fixed",
    "ok: positional encodings shouldn't be trainable",
    "then check nothing unexpectedly trainable",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Check",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Decoder State",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separate copy attention layer if needed.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Register self.mask as a buffer in TransformerDecoderLayer, so",
    "it gets TransformerDecoderLayer's cuda behavior automatically.",
    "Decoder State",
    "previously, there was a GlobalAttention module here for copy",
    "attention. But it was never actually used -- the \"copy\" attention",
    "just reuses the context attention.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "this assumes src_field and tgt_field are both text",
    "the dataset's self.fields should have the same attributes as examples",
    "avoid infinite recursion when fields isn't defined",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "if tgt isn't using TextMultiField, then no text field is.",
    "there is a truncate argument as well, but it was never set to",
    "anything besides None before",
    "the second conjunct means nothing will be filtered at translation time",
    "if there is no target data",
    "this is basically copy-pasted from torchtext.",
    "counters changes in place",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: [<bos> w1 ... wN <eos>]",
    "Tgt: [w1 ... wN <eos>]",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "batch (list(list(list))): batch_size x len(self.fields) x seq_len",
    "lengths: batch_size",
    "data: seq_len x batch_size x len(self.fields)",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "!/usr/bin/env python",
    "for debugging",
    "Statistics",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -1000.",
    "This puts the probabilities close to 0.",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "seq_so_far contains chosen tokens; on each step, dim 1 grows by one.",
    "Note that what this code calls log_probs are actually logits.",
    "Append last prediction.",
    "Store finished hypotheses for this batch. Unlike in beam search,",
    "there will only ever be 1 hypothesis per example.",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Tile states and memory beam_size times.",
    "Give full probability to the first beam on the first step.",
    "Structure that holds finished hypotheses.",
    "Multiply probs by the beam probability.",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Resolve beam origin and true word ids.",
    "Map beam_index to batch_index in the flat representation.",
    "Append last prediction.",
    "Save finished hypotheses.",
    "Penalize beams that finished.",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Reorder states.",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "Define a set of tokens to exclude from ngram-blocking",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use now  batch_size x beam_size (same as fast mode)",
    "(3) run the decoder to generate sentences, using beam search.",
    "(a) Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "(b) Decode and forward",
    "(c) Advance each beam.",
    "Loop over the batch_size number of beam",
    "(4) Extract sentences from beam.",
    "Rollback pointer to the beginning.",
    "!/usr/bin/env python",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Sorting"
  ],
  "0.7.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "is this reachable?",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for backward compatibility",
    "Build encoder.",
    "why is build_encoder not used here?",
    "why is the model_opt.__dict__ check necessary?",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "Load checkpoint if we resume from a previous training.",
    "Load default opts values then overwrite it with opts from",
    "the checkpoint. It's usefull in order to re-train a model",
    "after adding a new option (not set in checkpoint)",
    "check for code where vocab is saved instead of fields",
    "(in the future this will be done in a smarter way)",
    "Report src and tgt vocab sizes, including for features",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "this line is kind of a temporary kludge because different objects expect",
    "fields to have a different structure",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "this method unsqueezes its input",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "from onmt.utils.misc import aeq",
    "Run the forward pass of every layer of the tranformer.",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "2) Calculate and scale scores.",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Basic attributes.",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "Set up a separated copy attention layer, if needed.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Run the forward pass of the RNN.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Initialize local and return variables.",
    "Run the forward pass of the RNN.",
    "Check",
    "END",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Initialize local and return variables.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Run the forward pass of the copy attention layer.",
    "Return result.",
    "Basic attributes.",
    "Decoder State",
    "Build the CNN.",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "NOTE: memory_lengths is only here for compatibility reasons",
    "with onmt.modules.RNNDecoderBase.forward()",
    "Initialize return variables.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Run the forward pass of the CNNDecoder.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Register self.mask as a buffer in TransformerDecoderLayer, so",
    "it gets TransformerDecoderLayer's cuda behavior automatically.",
    "Basic attributes.",
    "Decoder State",
    "Build TransformerDecoder.",
    "TransformerDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "Initialize return variables.",
    "Run the forward pass of the TransformerDecoder.",
    "Process the result and update the attentions.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "TODO: Find a better way to check for sparse gradients.",
    "Load everything from the checkpoint.",
    "Build everything from scratch.",
    "Reset optimizer, keep options.",
    "Reset options, keep optimizer.",
    "State can be partially restored.",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "coding: utf-8",
    "several data readers need optional dependencies. There's no",
    "appropriate builtin exception",
    "self.src_vocabs is used in collapse_copy_scores and Translator.py",
    "the dataset's self.fields should have the same attributes as examples",
    "avoid infinite recursion when fields isn't defined",
    "make a small vocab containing just the tokens in the source sequence",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "backwards compatibility",
    "cat together layers, producing a 3d output tensor for src text",
    "and for tgt (which is assumed to be text)",
    "there is a truncate argument as well, but it was never set to",
    "anything besides None before",
    "the second conjunct means nothing will be filtered at translation time",
    "if there is no target data",
    "this is basically copy-pasted from torchtext.",
    "Load vocabulary",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "Drop the none-using from memory but keep the last",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "temporary fix: See #1196",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: <bos> w1 ... wN <eos>",
    "Tgt: w1 ... wN <eos>",
    "-*- coding: utf-8 -*-",
    "imports of datatype-specific dependencies",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "domain specific dependencies",
    "-*- coding: utf-8 -*-",
    "mix this with partial",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "!/usr/bin/env python",
    "for debugging",
    "Statistics",
    "For temp=0.0, take the argmax to avoid divide-by-zero errors.",
    "keep_topk=1 is also equivalent to argmax.",
    "Set all logits that are not in the top-k to -1000.",
    "This puts the probabilities close to 0.",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "seq_so_far contains chosen tokens; on each step, dim 1 grows by one.",
    "Note that what this code calls log_probs are actually logits.",
    "Append last prediction.",
    "Store finished hypotheses for this batch. Unlike in beam search,",
    "there will only ever be 1 hypothesis per example.",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Tile states and memory beam_size times.",
    "Give full probability to the first beam on the first step.",
    "Structure that holds finished hypotheses.",
    "Multiply probs by the beam probability.",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Resolve beam origin and true word ids.",
    "Map beam_index to batch_index in the flat representation.",
    "Append last prediction.",
    "Save finished hypotheses.",
    "Penalize beams that finished.",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Reorder states.",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "Define a set of tokens to exclude from ngram-blocking",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use now  batch_size x beam_size (same as fast mode)",
    "(3) run the decoder to generate sentences, using beam search.",
    "(a) Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "(b) Decode and forward",
    "(c) Advance each beam.",
    "Loop over the batch_size number of beam",
    "(4) Extract sentences from beam.",
    "Rollback pointer to the beginning.",
    "!/usr/bin/env python",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Sorting"
  ],
  "0.7.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "for backward compatibility",
    "Build encoder.",
    "why is build_encoder not used here?",
    "why is the model_opt.__dict__ check necessary?",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "!/usr/bin/env python",
    "this check is here because audio allows the encoder and decoder to",
    "be different sizes, but other model types do not yet",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Load checkpoint if we resume from a previous training.",
    "Load default opts values then overwrite it with opts from",
    "the checkpoint. It's usefull in order to re-train a model",
    "after adding a new option (not set in checkpoint)",
    "Load a shard dataset to determine the data_type.",
    "(All datasets have the same data_type).",
    "this should be refactored out of existence reasonably soon",
    "Load fields generated from preprocess phase.",
    "Report src/tgt features.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "dec_state = None",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss in shards for memory efficiency.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "from onmt.utils.misc import aeq",
    "Run the forward pass of every layer of the tranformer.",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "2) Calculate and scale scores.",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probability of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-data option is required, but not used in this test, so dummy.",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Basic attributes.",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "Set up a separated copy attention layer, if needed.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Run the forward pass of the RNN.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Initialize local and return variables.",
    "Run the forward pass of the RNN.",
    "Check",
    "END",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Initialize local and return variables.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Run the forward pass of the copy attention layer.",
    "Return result.",
    "Basic attributes.",
    "Decoder State",
    "Build the CNN.",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "NOTE: memory_lengths is only here for compatibility reasons",
    "with onmt.modules.RNNDecoderBase.forward()",
    "Initialize return variables.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Run the forward pass of the CNNDecoder.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Register self.mask as a buffer in TransformerDecoderLayer, so",
    "it gets TransformerDecoderLayer's cuda behavior automatically.",
    "Basic attributes.",
    "Decoder State",
    "Build TransformerDecoder.",
    "TransformerDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "Initialize return variables.",
    "Run the forward pass of the TransformerDecoder.",
    "Process the result and update the attentions.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "We need to save a copy of optim.optimizer.state_dict() for setting",
    "the, optimizer state later on in Stage 2 in this method, since",
    "the method optim.set_parameters(model) will overwrite",
    "optim.optimizer, and with ith the values stored in",
    "optim.optimizer.state_dict()",
    "Stage 1:",
    "Essentially optim.set_parameters (re-)creates and optimizer using",
    "model.paramters() as parameters that will be stored in the",
    "optim.optimizer.param_groups field of the torch optimizer class.",
    "Importantly, this method does not yet load the optimizer state, as",
    "essentially it builds a new optimizer with empty optimizer state and",
    "parameters from the model.",
    "Stage 2: In this stage, which is only performed when loading an",
    "optimizer from a checkpoint, we load the saved_optimizer_state_dict",
    "into the re-created optimizer, to set the optim.optimizer.state",
    "field, which was previously empty. For this, we use the optimizer",
    "state saved in the \"saved_optimizer_state_dict\" variable for",
    "this purpose.",
    "See also: https://github.com/pytorch/pytorch/issues/2830",
    "Convert back the state values to cuda type if applicable",
    "We want to make sure that indeed we have a non-empty optimizer state",
    "when we loaded an existing model. This should be at least the case",
    "for Adam, which saves \"exp_avg\" and \"exp_avg_sq\" state",
    "(Exponential moving average of gradient and squared gradient values)",
    "TODO: Find a better way to check for sparse gradients.",
    "Decay method used in tensor2tensor.",
    "Decay based on start_decay_steps every decay_steps",
    "Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf",
    "inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch",
    "default value from paper",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "coding: utf-8",
    "This is a hack. Something is broken with torch pickle.",
    "Each element of an example is a dictionary whose keys represents",
    "at minimum the src tokens and their indices and potentially also",
    "the src and tgt features and alignment information.",
    "self.src_vocabs is used in collapse_copy_scores and in Translator.py",
    "Peek at the first to see which fields are used.",
    "why do we need to use different keys from the ones passed in?",
    "why does this exist?",
    "it would not be necessary to pass unk and pad if the method were",
    "called after fields becomes an attribute of self",
    "Map source tokens to indices in the dynamic dict.",
    "-*- coding: utf-8 -*-",
    "only audio has src_lengths",
    "everything except audio has src_map and alignment",
    "below this: things defined no matter what the data source type is",
    "there is a truncate argument as well, but it was never set to",
    "anything besides None before",
    "the second conjunct means nothing will be filtered at translation time",
    "if there is no target data",
    "Prop src from field to get lower memory using when training with image",
    "Load vocabulary",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "Drop the none-using from memory but keep the last",
    "All datasets have same num of n_tgt_features,",
    "getting the last one is OK.",
    "All datasets have same num of n_src_features,",
    "getting the last one is OK.",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "in the long run, shouldn't it be possible to do this by calling",
    "build_vocab with both the src and tgt data?",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: <bos> w1 ... wN <eos>",
    "Tgt: w1 ... wN <eos>",
    "-*- coding: utf-8 -*-",
    "torchaudio loading options recently changed. It's probably",
    "straightforward to rewrite the audio handling to make use of",
    "up-to-date torchaudio, but in the meantime there is a legacy",
    "method which uses the old defaults",
    "STFT",
    "-*- coding: utf-8 -*-",
    "-*- coding: utf-8 -*-",
    "the implicit assumption here is that data that does not come",
    "from a file is already at least semi-tokenized, i.e. split on",
    "whitespace. We cannot do modular/user-specified tokenization",
    "until that is no longer the case. The fields should handle this.",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "!/usr/bin/env python",
    "for debugging",
    "Statistics",
    "Turn any copied words into UNKs.",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "TODO: faster code path for beam_size == 1.",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Tile states and memory beam_size times.",
    "Give full probability to the first beam on the first step.",
    "Structure that holds finished hypotheses.",
    "Multiply probs by the beam probability.",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Resolve beam origin and true word ids.",
    "Map beam_index to batch_index in the flat representation.",
    "Append last prediction.",
    "Save finished hypotheses.",
    "Penalize beams that finished.",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Reorder states.",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "Define a set of tokens to exclude from ngram-blocking",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use now  batch_size x beam_size (same as fast mode)",
    "(3) run the decoder to generate sentences, using beam search.",
    "(a) Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "(b) Decode and forward",
    "(c) Advance each beam.",
    "Loop over the batch_size number of beam",
    "(4) Extract sentences from beam.",
    "Rollback pointer to the beginning.",
    "!/usr/bin/env python",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Sorting"
  ],
  "0.6.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "We will use glob.glob() to find sharded {train|valid}.[0-9]*.pt",
    "when training, so check to avoid tampering with existing pt files",
    "or mixing them up.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "For data_type == 'img' or 'audio', currently we don't do",
    "preprocess sharding. We only build a monolithic dataset.",
    "But since the interfaces are uniform, it would be not hard",
    "to do this should users need this feature.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "Can't save fields, so remove/reconstruct at training time.",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "\"rnn\" or \"brnn\"",
    "for backward compatibility",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "This preserves backward-compat for models using customed layernorm",
    "end of patch for backward compatibility",
    "Add generator to model (this registers it as parameter of model).",
    "!/usr/bin/env python",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Load checkpoint if we resume from a previous training.",
    "Load default opts values then overwrite it with opts from",
    "the checkpoint. It's usefull in order to re-train a model",
    "after adding a new option (not set in checkpoint)",
    "Peek the first dataset to determine the data_type.",
    "(All datasets have the same data_type).",
    "Load fields generated from preprocess phase.",
    "Report src/tgt features.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Do training.",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add('--residual', '-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Get the key 'value' in the dict, or just use 'value'",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "dec_state = None",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss in shards for memory efficiency.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "TO CHECK",
    "if dec_state is not None:",
    "dec_state.detach()",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "from onmt.utils.misc import aeq",
    "Run the forward pass of every layer of the tranformer.",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "2) Calculate and scale scores.",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probibility of not copying: p_{word}(w) * (1 - p(z))",
    "probabilities assigned by the model to the gold targets",
    "probability of tokens copied from source",
    "Set scores for unk to 0 and add eps",
    "find the indices in which you do not use the copy mechanism",
    "Drop padding.",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "this block does not depend on the loss value computed above",
    "and is used only for stats",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "this part looks like it belongs in CopyGeneratorLoss",
    "Compute Loss as NLL divided by seq length",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-data option is required, but not used in this test, so dummy.",
    "Helper to generate a vocabulary",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "4 specicials + 2 words (since we pass 2 to merge_vocabs)",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Basic attributes.",
    "Decoder state",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "Set up a separated copy attention layer, if needed.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Init the input feed.",
    "Run the forward pass of the RNN.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: dec_outs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Initialize local and return variables.",
    "Run the forward pass of the RNN.",
    "Check",
    "END",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Initialize local and return variables.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Run the forward pass of the copy attention layer.",
    "Return result.",
    "Basic attributes.",
    "Decoder State",
    "Build the CNN.",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "NOTE: memory_lengths is only here for compatibility reasons",
    "with onmt.modules.RNNDecoderBase.forward()",
    "Initialize return variables.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Run the forward pass of the CNNDecoder.",
    "Process the result and update the attentions.",
    "Update the state.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Register self.mask as a buffer in TransformerDecoderLayer, so",
    "it gets TransformerDecoderLayer's cuda behavior automatically.",
    "Basic attributes.",
    "Decoder State",
    "Build TransformerDecoder.",
    "TransformerDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "Initialize return variables.",
    "Run the forward pass of the TransformerDecoder.",
    "Process the result and update the attentions.",
    "TODO change the way attns is returned dict => list or tuple (onnx)",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "We need to save a copy of optim.optimizer.state_dict() for setting",
    "the, optimizer state later on in Stage 2 in this method, since",
    "the method optim.set_parameters(model.parameters()) will overwrite",
    "optim.optimizer, and with ith the values stored in",
    "optim.optimizer.state_dict()",
    "Stage 1:",
    "Essentially optim.set_parameters (re-)creates and optimizer using",
    "model.paramters() as parameters that will be stored in the",
    "optim.optimizer.param_groups field of the torch optimizer class.",
    "Importantly, this method does not yet load the optimizer state, as",
    "essentially it builds a new optimizer with empty optimizer state and",
    "parameters from the model.",
    "Stage 2: In this stage, which is only performed when loading an",
    "optimizer from a checkpoint, we load the saved_optimizer_state_dict",
    "into the re-created optimizer, to set the optim.optimizer.state",
    "field, which was previously empty. For this, we use the optimizer",
    "state saved in the \"saved_optimizer_state_dict\" variable for",
    "this purpose.",
    "See also: https://github.com/pytorch/pytorch/issues/2830",
    "Convert back the state values to cuda type if applicable",
    "We want to make sure that indeed we have a non-empty optimizer state",
    "when we loaded an existing model. This should be at least the case",
    "for Adam, which saves \"exp_avg\" and \"exp_avg_sq\" state",
    "(Exponential moving average of gradient and squared gradient values)",
    "Decay method used in tensor2tensor.",
    "Decay based on start_decay_steps every decay_steps",
    "-*- coding: utf-8 -*-",
    "if the loss function operates on vectors of raw logits instead of",
    "probabilities, only the first part of the generator needs to be",
    "passed to the NMTLossCompute. At the moment, the only supported",
    "loss function of this kind is the sparsemax loss.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "coding: utf-8",
    "Below are helper functions for intra-class use only.",
    "-*- coding: utf-8 -*-",
    "Hack. Can't pickle defaultdict :(",
    "For all data types, the tgt side corpus is in form of text.",
    "Prop src from field to get lower memory using when training with image",
    "Load vocabulary",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "Drop the none-using from memory but keep the last",
    "All datasets have same num of n_tgt_features,",
    "getting the last one is OK.",
    "All datasets have same num of n_src_features,",
    "getting the last one is OK.",
    "Merge the input and output vocabularies.",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "We have at least one dataset.",
    "We return the len of cur_dataset, otherwise we need to load",
    "all datasets to determine the real len, which loses the benefit",
    "of lazy loading.",
    "Drop the current dataset for decreasing memory",
    "We clear `fields` when saving, restore when loading.",
    "Sort batch by decreasing lengths of sentence required by pytorch.",
    "sort=False means \"Use dataset's sortkey instead of iterator's\".",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: <bos> w1 ... wN <eos>",
    "Tgt: w1 ... wN <eos>",
    "Sort the glob output by file name (by increasing indexes).",
    "Only one inputters.*Dataset, simple!",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "STFT",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "-*- coding: utf-8 -*-",
    "self.src_vocabs: mutated in dynamic_dict, used in",
    "collapse_copy_scores and in Translator.py",
    "Each element of an example is a dictionary whose keys represents",
    "at minimum the src tokens and their indices and potentially also",
    "the src and tgt features and alignment information.",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "Default to a balanced sort, prioritizing tgt len match.",
    "TODO: make this configurable.",
    "All examples have same number of features, so we peek first one",
    "to get the num_feats.",
    "Chain back the first element - we only want to peek it.",
    "Below are helper functions for intra-class use only.",
    "Mapping source tokens to indices in the dynamic dict.",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "This part of check is time consuming on Py2 (but",
    "it is quite fast on Py3, weird!). So we don't bother",
    "to check for very line. Instead we chekc every 64",
    "lines. Thus we are not dividing exactly per",
    "`shard_size`, but it is not too much difference.",
    "All examples must have same number of features.",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "!/usr/bin/env python",
    "for debugging",
    "Statistics",
    "Debug attention.",
    "Turn any copied words to UNKs (index 0).",
    "Decoder forward, takes [tgt_len, batch, nfeats] as input",
    "and [src_len, batch, hidden] as memory_bank",
    "in case of inference tgt_len = 1, batch = beam times batch_size",
    "in case of Gold Scoring tgt_len = actual length, batch = 1 batch",
    "Generator forward.",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "here we have scores [tgt_lenxbatch, vocab] or [beamxbatch, vocab]",
    "returns [(batch_size x beam_size) , vocab ] when 1 step",
    "or [ tgt_len, batch_size, vocab ] when full sentence",
    "TODO: faster code path for beam_size == 1.",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Tile states and memory beam_size times.",
    "Give full probability to the first beam on the first step.",
    "Structure that holds finished hypotheses.",
    "Multiply probs by the beam probability.",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Resolve beam origin and true word ids.",
    "Map beam_index to batch_index in the flat representation.",
    "Append last prediction.",
    "Save finished hypotheses.",
    "Penalize beams that finished.",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Reorder states.",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "Define a list of tokens to exclude from ngram-blocking",
    "exclusion_list = [\"<t>\", \"</t>\", \".\"]",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "We use now  batch_size x beam_size (same as fast mode)",
    "(3) run the decoder to generate sentences, using beam search.",
    "(a) Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "(b) Decode and forward",
    "(c) Advance each beam.",
    "Loop over the batch_size number of beam",
    "(4) Extract sentences from beam.",
    "Rollback pointer to the beginning.",
    "!/usr/bin/env python",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Sorting"
  ],
  "0.5.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "We will use glob.glob() to find sharded {train|valid}.[0-9]*.pt",
    "when training, so check to avoid tampering with existing pt files",
    "or mixing them up.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "For data_type == 'img' or 'audio', currently we don't do",
    "preprocess sharding. We only build a monolithic dataset.",
    "But since the interfaces are uniform, it would be not hard",
    "to do this should users need this feature.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "Can't save fields, so remove/reconstruct at training time.",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Add in default model arguments, possibly added since training.",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "\"rnn\" or \"brnn\"",
    "for backward compatibility",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "Add generator to model (this registers it as parameter of model).",
    "!/usr/bin/env python",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Load checkpoint if we resume from a previous training.",
    "Peek the first dataset to determine the data_type.",
    "(All datasets have the same data_type).",
    "Load fields generated from preprocess phase.",
    "Report src/tgt features.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Do training.",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add_argument('-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss in shards for memory efficiency.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "from onmt.utils.misc import aeq",
    "Run the forward pass of every layer of the tranformer.",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "2) Calculate and scale scores.",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probibility of not copying: p_{word}(w) * (1 - p(z))",
    "Compute unks in align and target for readability",
    "Copy probability of tokens in source",
    "Set scores for unk to 0 and add eps",
    "Get scores for tokens in target",
    "Regular prob (no unks and unks that can't be copied)",
    "Add score for non-unks in target",
    "Add score for when word is unk in both align and tgt",
    "Forced copy. Add only probability for not-copied tokens",
    "Drop padding.",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "Compute Loss as NLL divided by seq length",
    "Compute Sequence Lengths",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-data option is required, but not used in this test, so dummy.",
    "Helper to generate a vocabulary",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "4 specicials + 2 words (since we pass 2 to merge_vocabs)",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Basic attributes.",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "Set up a separated copy attention layer, if needed.",
    "Check",
    "tgt.size() returns tgt length and batch",
    "END",
    "Run the forward pass of the RNN.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: decoder_outputs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Initialize local and return variables.",
    "Run the forward pass of the RNN.",
    "Check",
    "END",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Initialize local and return variables.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Run the forward pass of the copy attention layer.",
    "Return result.",
    "Init the input feed.",
    "Basic attributes.",
    "Build the CNN.",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "NOTE: memory_lengths is only here for compatibility reasons",
    "with onmt.modules.RNNDecoderBase.forward()",
    "CHECKS",
    "END CHECKS",
    "Initialize return variables.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Run the forward pass of the CNNDecoder.",
    "Process the result and update the attentions.",
    "Update the state.",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Register self.mask as a buffer in TransformerDecoderLayer, so",
    "it gets TransformerDecoderLayer's cuda behavior automatically.",
    "Basic attributes.",
    "Build TransformerDecoder.",
    "TransformerDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "Initialize return variables.",
    "Run the forward pass of the TransformerDecoder.",
    "Process the result and update the attentions.",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "We need to save a copy of optim.optimizer.state_dict() for setting",
    "the, optimizer state later on in Stage 2 in this method, since",
    "the method optim.set_parameters(model.parameters()) will overwrite",
    "optim.optimizer, and with ith the values stored in",
    "optim.optimizer.state_dict()",
    "Stage 1:",
    "Essentially optim.set_parameters (re-)creates and optimizer using",
    "model.paramters() as parameters that will be stored in the",
    "optim.optimizer.param_groups field of the torch optimizer class.",
    "Importantly, this method does not yet load the optimizer state, as",
    "essentially it builds a new optimizer with empty optimizer state and",
    "parameters from the model.",
    "Stage 2: In this stage, which is only performed when loading an",
    "optimizer from a checkpoint, we load the saved_optimizer_state_dict",
    "into the re-created optimizer, to set the optim.optimizer.state",
    "field, which was previously empty. For this, we use the optimizer",
    "state saved in the \"saved_optimizer_state_dict\" variable for",
    "this purpose.",
    "See also: https://github.com/pytorch/pytorch/issues/2830",
    "Convert back the state values to cuda type if applicable",
    "We want to make sure that indeed we have a non-empty optimizer state",
    "when we loaded an existing model. This should be at least the case",
    "for Adam, which saves \"exp_avg\" and \"exp_avg_sq\" state",
    "(Exponential moving average of gradient and squared gradient values)",
    "Decay method used in tensor2tensor.",
    "Decay based on start_decay_steps every decay_steps",
    "-*- coding: utf-8 -*-",
    "for sparsemax loss, the loss function operates on the raw output",
    "vector, not a probability vector. Hence it's only necessary to",
    "apply the first part of the generator here.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "coding: utf-8",
    "Below are helper functions for intra-class use only.",
    "-*- coding: utf-8 -*-",
    "Hack. Can't pickle defaultdict :(",
    "For all data types, the tgt side corpus is in form of text.",
    "Prop src from field to get lower memory using when training with image",
    "Load vocabulary",
    "keep the order of tokens specified in the vocab file by",
    "adding them to the counter with decreasing counting values",
    "Drop the none-using from memory but keep the last",
    "All datasets have same num of n_tgt_features,",
    "getting the last one is OK.",
    "All datasets have same num of n_src_features,",
    "getting the last one is OK.",
    "Merge the input and output vocabularies.",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "We have at least one dataset.",
    "We return the len of cur_dataset, otherwise we need to load",
    "all datasets to determine the real len, which loses the benefit",
    "of lazy loading.",
    "Drop the current dataset for decreasing memory",
    "We clear `fields` when saving, restore when loading.",
    "Sort batch by decreasing lengths of sentence required by pytorch.",
    "sort=False means \"Use dataset's sortkey instead of iterator's\".",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: <bos> w1 ... wN <eos>",
    "Tgt: w1 ... wN <eos>",
    "Sort the glob output by file name (by increasing indexes).",
    "Only one inputters.*Dataset, simple!",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "STFT",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "-*- coding: utf-8 -*-",
    "self.src_vocabs: mutated in dynamic_dict, used in",
    "collapse_copy_scores and in Translator.py",
    "Each element of an example is a dictionary whose keys represents",
    "at minimum the src tokens and their indices and potentially also",
    "the src and tgt features and alignment information.",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "Default to a balanced sort, prioritizing tgt len match.",
    "TODO: make this configurable.",
    "All examples have same number of features, so we peek first one",
    "to get the num_feats.",
    "Chain back the first element - we only want to peek it.",
    "Below are helper functions for intra-class use only.",
    "Mapping source tokens to indices in the dynamic dict.",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "This part of check is time consuming on Py2 (but",
    "it is quite fast on Py3, weird!). So we don't bother",
    "to check for very line. Instead we chekc every 64",
    "lines. Thus we are not dividing exactly per",
    "`shard_size`, but it is not too much difference.",
    "All examples must have same number of features.",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "Not yet supported on multi-gpu",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "!/usr/bin/env python",
    "use ensemble decoding if more than one model is specified",
    "for debugging",
    "Statistics",
    "Debug attention.",
    "TODO: faster code path for beam_size == 1.",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Tile states and memory beam_size times.",
    "Give full probability to the first beam on the first step.",
    "Structure that holds finished hypotheses.",
    "Decoder forward.",
    "Generator forward.",
    "Multiply probs by the beam probability.",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Resolve beam origin and true word ids.",
    "Map beam_index to batch_index in the flat representation.",
    "Append last prediction.",
    "Save finished hypotheses.",
    "Penalize beams that finished.",
    "Store finished hypotheses for this batch.",
    "End condition is the top beam finished and we can return",
    "n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Reorder states.",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "Define a list of tokens to exclude from ngram-blocking",
    "exclusion_list = [\"<t>\", \"</t>\", \".\"]",
    "Help functions for working with beams and batches",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "(3) run the decoder to generate sentences, using beam search.",
    "Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "Turn any copied words to UNKs",
    "0 is unk",
    "Temporary kludge solution to handle changed dim expectation",
    "in the decoder",
    "Run one step.",
    "dec_out: beam x rnn_size",
    "(b) Compute a vector of batch x beam word scores.",
    "beam x tgt_vocab",
    "beam x (tgt_vocab + extra_vocab)",
    "beam x tgt_vocab",
    "(c) Advance each beam.",
    "(4) Extract sentences from beam.",
    "(1) run the encoder on the src",
    "(2) if a target is specified, compute the 'goldScore'",
    "(i.e. log likelihood) of the target under the model",
    "Log prob of each word.",
    "Rollback pointer to the beginning.",
    "!/usr/bin/env python",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Sorting"
  ],
  "0.4.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "We will use glob.glob() to find sharded {train|valid}.[0-9]*.pt",
    "when training, so check to avoid tampering with existing pt files",
    "or mixing them up.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "For data_type == 'img' or 'audio', currently we don't do",
    "preprocess sharding. We only build a monolithic dataset.",
    "But since the interfaces are uniform, it would be not hard",
    "to do this should users need this feature.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "Can't save fields, so remove/reconstruct at training time.",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "Add in default model arguments, possibly added since training.",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "\"rnn\" or \"brnn\"",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "Add generator to model (this registers it as parameter of model).",
    "!/usr/bin/env python",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Load checkpoint if we resume from a previous training.",
    "Peek the first dataset to determine the data_type.",
    "(All datasets have the same data_type).",
    "Load fields generated from preprocess phase.",
    "Report src/tgt features.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Do training.",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add_argument('-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss in shards for memory efficiency.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "from onmt.utils.misc import aeq",
    "Run the forward pass of every layer of the tranformer.",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "2) Calculate and scale scores.",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probibility of not copying: p_{word}(w) * (1 - p(z))",
    "Compute unks in align and target for readability",
    "Copy probability of tokens in source",
    "Set scores for unk to 0 and add eps",
    "Get scores for tokens in target",
    "Regular prob (no unks and unks that can't be copied)",
    "Add score for non-unks in target",
    "Add score for when word is unk in both align and tgt",
    "Forced copy. Add only probability for not-copied tokens",
    "Drop padding.",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "Compute Loss as NLL divided by seq length",
    "Compute Sequence Lengths",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-data option is required, but not used in this test, so dummy.",
    "Helper to generate a vocabulary",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "4 specicials + 2 words (since we pass 2 to merge_vocabs)",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Basic attributes.",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "Set up a separated copy attention layer, if needed.",
    "Check",
    "tgt.size() returns tgt length and batch",
    "END",
    "Run the forward pass of the RNN.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: decoder_outputs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Initialize local and return variables.",
    "Run the forward pass of the RNN.",
    "Check",
    "END",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Initialize local and return variables.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Run the forward pass of the copy attention layer.",
    "Return result.",
    "Init the input feed.",
    "Basic attributes.",
    "Build the CNN.",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "NOTE: memory_lengths is only here for compatibility reasons",
    "with onmt.modules.RNNDecoderBase.forward()",
    "CHECKS",
    "END CHECKS",
    "Initialize return variables.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Run the forward pass of the CNNDecoder.",
    "Process the result and update the attentions.",
    "Update the state.",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Register self.mask as a buffer in TransformerDecoderLayer, so",
    "it gets TransformerDecoderLayer's cuda behavior automatically.",
    "Basic attributes.",
    "Build TransformerDecoder.",
    "TransformerDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "Initialize return variables.",
    "Run the forward pass of the TransformerDecoder.",
    "Process the result and update the attentions.",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "We need to save a copy of optim.optimizer.state_dict() for setting",
    "the, optimizer state later on in Stage 2 in this method, since",
    "the method optim.set_parameters(model.parameters()) will overwrite",
    "optim.optimizer, and with ith the values stored in",
    "optim.optimizer.state_dict()",
    "Stage 1:",
    "Essentially optim.set_parameters (re-)creates and optimizer using",
    "model.paramters() as parameters that will be stored in the",
    "optim.optimizer.param_groups field of the torch optimizer class.",
    "Importantly, this method does not yet load the optimizer state, as",
    "essentially it builds a new optimizer with empty optimizer state and",
    "parameters from the model.",
    "Stage 2: In this stage, which is only performed when loading an",
    "optimizer from a checkpoint, we load the saved_optimizer_state_dict",
    "into the re-created optimizer, to set the optim.optimizer.state",
    "field, which was previously empty. For this, we use the optimizer",
    "state saved in the \"saved_optimizer_state_dict\" variable for",
    "this purpose.",
    "See also: https://github.com/pytorch/pytorch/issues/2830",
    "Convert back the state values to cuda type if applicable",
    "We want to make sure that indeed we have a non-empty optimizer state",
    "when we loaded an existing model. This should be at least the case",
    "for Adam, which saves \"exp_avg\" and \"exp_avg_sq\" state",
    "(Exponential moving average of gradient and squared gradient values)",
    "Decay method used in tensor2tensor.",
    "Decay based on start_decay_steps every decay_steps",
    "-*- coding: utf-8 -*-",
    "for sparsemax loss, the loss function operates on the raw output",
    "vector, not a probability vector. Hence it's only necessary to",
    "apply the first part of the generator here.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "coding: utf-8",
    "Below are helper functions for intra-class use only.",
    "-*- coding: utf-8 -*-",
    "Hack. Can't pickle defaultdict :(",
    "For all data types, the tgt side corpus is in form of text.",
    "Prop src from field to get lower memory using when training with image",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "All datasets have same num of n_tgt_features,",
    "getting the last one is OK.",
    "All datasets have same num of n_src_features,",
    "getting the last one is OK.",
    "Merge the input and output vocabularies.",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "We have at least one dataset.",
    "We return the len of cur_dataset, otherwise we need to load",
    "all datasets to determine the real len, which loses the benefit",
    "of lazy loading.",
    "Drop the current dataset for decreasing memory",
    "We clear `fields` when saving, restore when loading.",
    "Sort batch by decreasing lengths of sentence required by pytorch.",
    "sort=False means \"Use dataset's sortkey instead of iterator's\".",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: <bos> w1 ... wN <eos>",
    "Tgt: w1 ... wN <eos>",
    "Sort the glob output by file name (by increasing indexes).",
    "Only one inputters.*Dataset, simple!",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "STFT",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "-*- coding: utf-8 -*-",
    "self.src_vocabs: mutated in dynamic_dict, used in",
    "collapse_copy_scores and in Translator.py",
    "Each element of an example is a dictionary whose keys represents",
    "at minimum the src tokens and their indices and potentially also",
    "the src and tgt features and alignment information.",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "Default to a balanced sort, prioritizing tgt len match.",
    "TODO: make this configurable.",
    "All examples have same number of features, so we peek first one",
    "to get the num_feats.",
    "Chain back the first element - we only want to peek it.",
    "Below are helper functions for intra-class use only.",
    "Mapping source tokens to indices in the dynamic dict.",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "This part of check is time consuming on Py2 (but",
    "it is quite fast on Py3, weird!). So we don't bother",
    "to check for very line. Instead we chekc every 64",
    "lines. Thus we are not dividing exactly per",
    "`shard_size`, but it is not too much difference.",
    "All examples must have same number of features.",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "Not yet supported on multi-gpu",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "!/usr/bin/env python",
    "use ensemble decoding if more than one model is specified",
    "for debugging",
    "Statistics",
    "Debug attention.",
    "TODO: faster code path for beam_size == 1.",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Tile states and memory beam_size times.",
    "Give full probability to the first beam on the first step.",
    "Structure that holds finished hypotheses.",
    "Decoder forward.",
    "Generator forward.",
    "Multiply probs by the beam probability.",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Resolve beam origin and true word ids.",
    "Map beam_index to batch_index in the flat representation.",
    "Append last prediction.",
    "End condition is top beam is finished.",
    "Save finished hypotheses.",
    "Store finished hypotheses for this batch.",
    "If the batch reached the end, save the n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Reorder states.",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "Define a list of tokens to exclude from ngram-blocking",
    "exclusion_list = [\"<t>\", \"</t>\", \".\"]",
    "Help functions for working with beams and batches",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "(3) run the decoder to generate sentences, using beam search.",
    "Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "Turn any copied words to UNKs",
    "0 is unk",
    "Temporary kludge solution to handle changed dim expectation",
    "in the decoder",
    "Run one step.",
    "dec_out: beam x rnn_size",
    "(b) Compute a vector of batch x beam word scores.",
    "beam x tgt_vocab",
    "beam x (tgt_vocab + extra_vocab)",
    "beam x tgt_vocab",
    "(c) Advance each beam.",
    "(4) Extract sentences from beam.",
    "(1) run the encoder on the src",
    "(2) if a target is specified, compute the 'goldScore'",
    "(i.e. log likelihood) of the target under the model",
    "Log prob of each word.",
    "Rollback pointer to the beginning.",
    "!/usr/bin/env python",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Sorting"
  ],
  "0.4.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "We will use glob.glob() to find sharded {train|valid}.[0-9]*.pt",
    "when training, so check to avoid tampering with existing pt files",
    "or mixing them up.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "For data_type == 'img' or 'audio', currently we don't do",
    "preprocess sharding. We only build a monolithic dataset.",
    "But since the interfaces are uniform, it would be not hard",
    "to do this should users need this feature.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "Can't save fields, so remove/reconstruct at training time.",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "Add in default model arguments, possibly added since training.",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "\"rnn\" or \"brnn\"",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "Add generator to model (this registers it as parameter of model).",
    "!/usr/bin/env python",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Load checkpoint if we resume from a previous training.",
    "Peek the first dataset to determine the data_type.",
    "(All datasets have the same data_type).",
    "Load fields generated from preprocess phase.",
    "Report src/tgt features.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Do training.",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add_argument('-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss in shards for memory efficiency.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "s_len, batch, emb_dim = emb.size()",
    "from onmt.utils.misc import aeq",
    "Run the forward pass of every layer of the tranformer.",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "2) Calculate and scale scores.",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probibility of not copying: p_{word}(w) * (1 - p(z))",
    "Compute unks in align and target for readability",
    "Copy probability of tokens in source",
    "Set scores for unk to 0 and add eps",
    "Get scores for tokens in target",
    "Regular prob (no unks and unks that can't be copied)",
    "Add score for non-unks in target",
    "Add score for when word is unk in both align and tgt",
    "Forced copy. Add only probability for not-copied tokens",
    "Drop padding.",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "Compute Loss as NLL divided by seq length",
    "Compute Sequence Lengths",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-data option is required, but not used in this test, so dummy.",
    "Helper to generate a vocabulary",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "4 specicials + 2 words (since we pass 2 to merge_vocabs)",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Basic attributes.",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "Set up a separated copy attention layer, if needed.",
    "Check",
    "tgt.size() returns tgt length and batch",
    "END",
    "Run the forward pass of the RNN.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: decoder_outputs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Initialize local and return variables.",
    "Run the forward pass of the RNN.",
    "Check",
    "END",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Initialize local and return variables.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Run the forward pass of the copy attention layer.",
    "Return result.",
    "Init the input feed.",
    "Basic attributes.",
    "Build the CNN.",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "NOTE: memory_lengths is only here for compatibility reasons",
    "with onmt.modules.RNNDecoderBase.forward()",
    "CHECKS",
    "END CHECKS",
    "Initialize return variables.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Run the forward pass of the CNNDecoder.",
    "Process the result and update the attentions.",
    "Update the state.",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Register self.mask as a buffer in TransformerDecoderLayer, so",
    "it gets TransformerDecoderLayer's cuda behavior automatically.",
    "Basic attributes.",
    "Build TransformerDecoder.",
    "TransformerDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "Initialize return variables.",
    "Run the forward pass of the TransformerDecoder.",
    "Process the result and update the attentions.",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "We need to save a copy of optim.optimizer.state_dict() for setting",
    "the, optimizer state later on in Stage 2 in this method, since",
    "the method optim.set_parameters(model.parameters()) will overwrite",
    "optim.optimizer, and with ith the values stored in",
    "optim.optimizer.state_dict()",
    "Stage 1:",
    "Essentially optim.set_parameters (re-)creates and optimizer using",
    "model.paramters() as parameters that will be stored in the",
    "optim.optimizer.param_groups field of the torch optimizer class.",
    "Importantly, this method does not yet load the optimizer state, as",
    "essentially it builds a new optimizer with empty optimizer state and",
    "parameters from the model.",
    "Stage 2: In this stage, which is only performed when loading an",
    "optimizer from a checkpoint, we load the saved_optimizer_state_dict",
    "into the re-created optimizer, to set the optim.optimizer.state",
    "field, which was previously empty. For this, we use the optimizer",
    "state saved in the \"saved_optimizer_state_dict\" variable for",
    "this purpose.",
    "See also: https://github.com/pytorch/pytorch/issues/2830",
    "Convert back the state values to cuda type if applicable",
    "We want to make sure that indeed we have a non-empty optimizer state",
    "when we loaded an existing model. This should be at least the case",
    "for Adam, which saves \"exp_avg\" and \"exp_avg_sq\" state",
    "(Exponential moving average of gradient and squared gradient values)",
    "Decay method used in tensor2tensor.",
    "Decay based on start_decay_steps every decay_steps",
    "-*- coding: utf-8 -*-",
    "for sparsemax loss, the loss function operates on the raw output",
    "vector, not a probability vector. Hence it's only necessary to",
    "apply the first part of the generator here.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "coding: utf-8",
    "Below are helper functions for intra-class use only.",
    "-*- coding: utf-8 -*-",
    "Hack. Can't pickle defaultdict :(",
    "For all data types, the tgt side corpus is in form of text.",
    "Prop src from field to get lower memory using when training with image",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "All datasets have same num of n_tgt_features,",
    "getting the last one is OK.",
    "All datasets have same num of n_src_features,",
    "getting the last one is OK.",
    "Merge the input and output vocabularies.",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "We have at least one dataset.",
    "We return the len of cur_dataset, otherwise we need to load",
    "all datasets to determine the real len, which loses the benefit",
    "of lazy loading.",
    "Drop the current dataset for decreasing memory",
    "We clear `fields` when saving, restore when loading.",
    "Sort batch by decreasing lengths of sentence required by pytorch.",
    "sort=False means \"Use dataset's sortkey instead of iterator's\".",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: <bos> w1 ... wN <eos>",
    "Tgt: w1 ... wN <eos>",
    "Sort the glob output by file name (by increasing indexes).",
    "Only one inputters.*Dataset, simple!",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "STFT",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "-*- coding: utf-8 -*-",
    "self.src_vocabs: mutated in dynamic_dict, used in",
    "collapse_copy_scores and in Translator.py",
    "Each element of an example is a dictionary whose keys represents",
    "at minimum the src tokens and their indices and potentially also",
    "the src and tgt features and alignment information.",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "Default to a balanced sort, prioritizing tgt len match.",
    "TODO: make this configurable.",
    "All examples have same number of features, so we peek first one",
    "to get the num_feats.",
    "Chain back the first element - we only want to peek it.",
    "Below are helper functions for intra-class use only.",
    "Mapping source tokens to indices in the dynamic dict.",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "This part of check is time consuming on Py2 (but",
    "it is quite fast on Py3, weird!). So we don't bother",
    "to check for very line. Instead we chekc every 64",
    "lines. Thus we are not dividing exactly per",
    "`shard_size`, but it is not too much difference.",
    "All examples must have same number of features.",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "Not yet supported on multi-gpu",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "!/usr/bin/env python",
    "use ensemble decoding if more than one model is specified",
    "for debugging",
    "Statistics",
    "Debug attention.",
    "TODO: faster code path for beam_size == 1.",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Tile states and memory beam_size times.",
    "Give full probability to the first beam on the first step.",
    "Structure that holds finished hypotheses.",
    "Decoder forward.",
    "Generator forward.",
    "Multiply probs by the beam probability.",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Resolve beam origin and true word ids.",
    "Map beam_index to batch_index in the flat representation.",
    "Append last prediction.",
    "End condition is top beam is finished.",
    "Save finished hypotheses.",
    "Store finished hypotheses for this batch.",
    "If the batch reached the end, save the n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Reorder states.",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "Define a list of tokens to exclude from ngram-blocking",
    "exclusion_list = [\"<t>\", \"</t>\", \".\"]",
    "Help functions for working with beams and batches",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "(3) run the decoder to generate sentences, using beam search.",
    "Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "Turn any copied words to UNKs",
    "0 is unk",
    "Temporary kludge solution to handle changed dim expectation",
    "in the decoder",
    "Run one step.",
    "dec_out: beam x rnn_size",
    "(b) Compute a vector of batch x beam word scores.",
    "beam x tgt_vocab",
    "beam x (tgt_vocab + extra_vocab)",
    "beam x tgt_vocab",
    "(c) Advance each beam.",
    "(4) Extract sentences from beam.",
    "(1) run the encoder on the src",
    "(2) if a target is specified, compute the 'goldScore'",
    "(i.e. log likelihood) of the target under the model",
    "Log prob of each word.",
    "Rollback pointer to the beginning.",
    "!/usr/bin/env python",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Sorting"
  ],
  "0.3.0": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "We will use glob.glob() to find sharded {train|valid}.[0-9]*.pt",
    "when training, so check to avoid tampering with existing pt files",
    "or mixing them up.",
    "We save fields in vocab.pt separately, so make it empty.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "Currently we only do preprocess sharding for corpus: data_type=='text'.",
    "For data_type == 'img' or 'audio', currently we don't do",
    "preprocess sharding. We only build a monolithic dataset.",
    "But since the interfaces are uniform, it would be not hard",
    "to do this should users need this feature.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "Can't save fields, so remove/reconstruct at training time.",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "Add in default model arguments, possibly added since training.",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "\"rnn\" or \"brnn\"",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "Add generator to model (this registers it as parameter of model).",
    "!/usr/bin/env python",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "some cudnn methods can be random even after fixing the seed",
    "unless you tell it to be deterministic",
    "These ensure same initialization in multi gpu mode",
    "Load checkpoint if we resume from a previous training.",
    "Peek the first dataset to determine the data_type.",
    "(All datasets have the same data_type).",
    "Load fields generated from preprocess phase.",
    "Report src/tgt features.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Do training.",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add_argument('-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Option most relevant to image input",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "Option most relevant to image input",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss in shards for memory efficiency.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "(batch_size, 1, nfft, t)",
    "layer 1",
    "(batch_size, 32, nfft/2, t/2)",
    "(batch_size, 32, nfft/2/2, t/2)",
    "layer 2",
    "(batch_size, 32, nfft/2/2, t/2)",
    "s_len, batch, emb_dim = emb.size()",
    "from onmt.utils.misc import aeq",
    "Run the forward pass of every layer of the tranformer.",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "2) Calculate and scale scores.",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probibility of not copying: p_{word}(w) * (1 - p(z))",
    "Compute unks in align and target for readability",
    "Copy probability of tokens in source",
    "Set scores for unk to 0 and add eps",
    "Get scores for tokens in target",
    "Regular prob (no unks and unks that can't be copied)",
    "Add score for non-unks in target",
    "Add score for when word is unk in both align and tgt",
    "Forced copy. Add only probability for not-copied tokens",
    "Drop padding.",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "Compute Loss as NLL divided by seq length",
    "Compute Sequence Lengths",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-data option is required, but not used in this test, so dummy.",
    "Helper to generate a vocabulary",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16),",
    "('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "4 specicials + 2 words (since we pass 2 to merge_vocabs)",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Basic attributes.",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "Set up a separated copy attention layer, if needed.",
    "Check",
    "tgt.size() returns tgt length and batch",
    "END",
    "Run the forward pass of the RNN.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: decoder_outputs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Initialize local and return variables.",
    "Run the forward pass of the RNN.",
    "Check",
    "END",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Initialize local and return variables.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Run the forward pass of the copy attention layer.",
    "Return result.",
    "Init the input feed.",
    "Basic attributes.",
    "Build the CNN.",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "NOTE: memory_lengths is only here for compatibility reasons",
    "with onmt.modules.RNNDecoderBase.forward()",
    "CHECKS",
    "END CHECKS",
    "Initialize return variables.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Run the forward pass of the CNNDecoder.",
    "Process the result and update the attentions.",
    "Update the state.",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Register self.mask as a buffer in TransformerDecoderLayer, so",
    "it gets TransformerDecoderLayer's cuda behavior automatically.",
    "Basic attributes.",
    "Build TransformerDecoder.",
    "TransformerDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "Initialize return variables.",
    "Run the forward pass of the TransformerDecoder.",
    "Process the result and update the attentions.",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "We need to save a copy of optim.optimizer.state_dict() for setting",
    "the, optimizer state later on in Stage 2 in this method, since",
    "the method optim.set_parameters(model.parameters()) will overwrite",
    "optim.optimizer, and with ith the values stored in",
    "optim.optimizer.state_dict()",
    "Stage 1:",
    "Essentially optim.set_parameters (re-)creates and optimizer using",
    "model.paramters() as parameters that will be stored in the",
    "optim.optimizer.param_groups field of the torch optimizer class.",
    "Importantly, this method does not yet load the optimizer state, as",
    "essentially it builds a new optimizer with empty optimizer state and",
    "parameters from the model.",
    "Stage 2: In this stage, which is only performed when loading an",
    "optimizer from a checkpoint, we load the saved_optimizer_state_dict",
    "into the re-created optimizer, to set the optim.optimizer.state",
    "field, which was previously empty. For this, we use the optimizer",
    "state saved in the \"saved_optimizer_state_dict\" variable for",
    "this purpose.",
    "See also: https://github.com/pytorch/pytorch/issues/2830",
    "Convert back the state values to cuda type if applicable",
    "We want to make sure that indeed we have a non-empty optimizer state",
    "when we loaded an existing model. This should be at least the case",
    "for Adam, which saves \"exp_avg\" and \"exp_avg_sq\" state",
    "(Exponential moving average of gradient and squared gradient values)",
    "Decay method used in tensor2tensor.",
    "Decay based on start_decay_steps every decay_steps",
    "-*- coding: utf-8 -*-",
    "for sparsemax loss, the loss function operates on the raw output",
    "vector, not a probability vector. Hence it's only necessary to",
    "apply the first part of the generator here.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "coding: utf-8",
    "Below are helper functions for intra-class use only.",
    "-*- coding: utf-8 -*-",
    "Hack. Can't pickle defaultdict :(",
    "For all data types, the tgt side corpus is in form of text.",
    "Prop src from field to get lower memory using when training with image",
    "Load vocabulary",
    "Drop the none-using from memory but keep the last",
    "All datasets have same num of n_tgt_features,",
    "getting the last one is OK.",
    "All datasets have same num of n_src_features,",
    "getting the last one is OK.",
    "Merge the input and output vocabularies.",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "We have at least one dataset.",
    "We return the len of cur_dataset, otherwise we need to load",
    "all datasets to determine the real len, which loses the benefit",
    "of lazy loading.",
    "Drop the current dataset for decreasing memory",
    "We clear `fields` when saving, restore when loading.",
    "Sort batch by decreasing lengths of sentence required by pytorch.",
    "sort=False means \"Use dataset's sortkey instead of iterator's\".",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: <bos> w1 ... wN <eos>",
    "Tgt: w1 ... wN <eos>",
    "Sort the glob output by file name (by increasing indexes).",
    "Only one inputters.*Dataset, simple!",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "STFT",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "-*- coding: utf-8 -*-",
    "self.src_vocabs: mutated in dynamic_dict, used in",
    "collapse_copy_scores and in Translator.py",
    "Each element of an example is a dictionary whose keys represents",
    "at minimum the src tokens and their indices and potentially also",
    "the src and tgt features and alignment information.",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "Default to a balanced sort, prioritizing tgt len match.",
    "TODO: make this configurable.",
    "All examples have same number of features, so we peek first one",
    "to get the num_feats.",
    "Chain back the first element - we only want to peek it.",
    "Below are helper functions for intra-class use only.",
    "Mapping source tokens to indices in the dynamic dict.",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "This part of check is time consuming on Py2 (but",
    "it is quite fast on Py3, weird!). So we don't bother",
    "to check for very line. Instead we chekc every 64",
    "lines. Thus we are not dividing exactly per",
    "`shard_size`, but it is not too much difference.",
    "All examples must have same number of features.",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "Not yet supported on multi-gpu",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "!/usr/bin/env python",
    "use ensemble decoding if more than one model is specified",
    "for debugging",
    "Statistics",
    "Debug attention.",
    "TODO: faster code path for beam_size == 1.",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Tile states and memory beam_size times.",
    "Give full probability to the first beam on the first step.",
    "Structure that holds finished hypotheses.",
    "Decoder forward.",
    "Generator forward.",
    "Multiply probs by the beam probability.",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Resolve beam origin and true word ids.",
    "Map beam_index to batch_index in the flat representation.",
    "Append last prediction.",
    "End condition is top beam is finished.",
    "Save finished hypotheses.",
    "Store finished hypotheses for this batch.",
    "If the batch reached the end, save the n_best hypotheses.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Reorder states.",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "Define a list of tokens to exclude from ngram-blocking",
    "exclusion_list = [\"<t>\", \"</t>\", \".\"]",
    "Help functions for working with beams and batches",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "(3) run the decoder to generate sentences, using beam search.",
    "Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "Turn any copied words to UNKs",
    "0 is unk",
    "Temporary kludge solution to handle changed dim expectation",
    "in the decoder",
    "Run one step.",
    "dec_out: beam x rnn_size",
    "(b) Compute a vector of batch x beam word scores.",
    "beam x tgt_vocab",
    "beam x (tgt_vocab + extra_vocab)",
    "beam x tgt_vocab",
    "(c) Advance each beam.",
    "(4) Extract sentences from beam.",
    "(1) run the encoder on the src",
    "(2) if a target is specified, compute the 'goldScore'",
    "(i.e. log likelihood) of the target under the model",
    "Log prob of each word.",
    "Rollback pointer to the beginning.",
    "!/usr/bin/env python",
    "backwards compatibility for confs",
    "load can be called multiple times: modify copy",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Sorting"
  ],
  "0.2.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "We will use glob.glob() to find sharded {train|valid}.[0-9]*.pt",
    "when training, so check to avoid tampering with existing pt files",
    "or mixing them up.",
    "We save fields in vocab.pt separately, so make it empty.",
    "Currently we only do preprocess sharding for corpus: data_type=='text'.",
    "For data_type == 'img' or 'audio', currently we don't do",
    "preprocess sharding. We only build a monolithic dataset.",
    "But since the interfaces are uniform, it would be not hard",
    "to do this should users need this feature.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "Can't save fields, so remove/reconstruct at training time.",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "Add in default model arguments, possibly added since training.",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "\"rnn\" or \"brnn\"",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "Add generator to model (this registers it as parameter of model).",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "These ensure same initialization in multi gpu mode",
    "Load checkpoint if we resume from a previous training.",
    "Peek the first dataset to determine the data_type.",
    "(All datasets have the same data_type).",
    "Load fields generated from preprocess phase.",
    "Report src/tgt features.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Do training.",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add_argument('-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss in shards for memory efficiency.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "(batch_size, 1, nfft, t)",
    "layer 1",
    "(batch_size, 32, nfft/2, t/2)",
    "(batch_size, 32, nfft/2/2, t/2)",
    "layer 2",
    "(batch_size, 32, nfft/2/2, t/2)",
    "s_len, batch, emb_dim = emb.size()",
    "from onmt.utils.misc import aeq",
    "Run the forward pass of every layer of the tranformer.",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "2) Calculate and scale scores.",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probibility of not copying: p_{word}(w) * (1 - p(z))",
    "Compute unks in align and target for readability",
    "Copy probability of tokens in source",
    "Set scores for unk to 0 and add eps",
    "Get scores for tokens in target",
    "Regular prob (no unks and unks that can't be copied)",
    "Add score for non-unks in target",
    "Add score for when word is unk in both align and tgt",
    "Forced copy. Add only probability for not-copied tokens",
    "Drop padding.",
    "We lazily load datasets when there are more than one, so postpone",
    "the setting of cur_dataset.",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "Compute Loss as NLL divided by seq length",
    "Compute Sequence Lengths",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-data option is required, but not used in this test, so dummy.",
    "Helper to generate a vocabulary",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16),",
    "('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "4 specicials + 2 words (since we pass 2 to merge_vocabs)",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Basic attributes.",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "Set up a separated copy attention layer, if needed.",
    "Check",
    "tgt.size() returns tgt length and batch",
    "END",
    "Run the forward pass of the RNN.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: decoder_outputs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Initialize local and return variables.",
    "Run the forward pass of the RNN.",
    "Check",
    "END",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Initialize local and return variables.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Run the forward pass of the copy attention layer.",
    "Return result.",
    "Init the input feed.",
    "Basic attributes.",
    "Build the CNN.",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "NOTE: memory_lengths is only here for compatibility reasons",
    "with onmt.modules.RNNDecoderBase.forward()",
    "CHECKS",
    "END CHECKS",
    "Initialize return variables.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Run the forward pass of the CNNDecoder.",
    "Process the result and update the attentions.",
    "Update the state.",
    "Memory_lengths is a single tensor shared between all models.",
    "This assumption will not hold if Translator is modified",
    "to calculate memory_lengths as something other than the length",
    "of the input.",
    "Register self.mask as a buffer in TransformerDecoderLayer, so",
    "it gets TransformerDecoderLayer's cuda behavior automatically.",
    "Basic attributes.",
    "Build TransformerDecoder.",
    "TransformerDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "Initialize return variables.",
    "Run the forward pass of the TransformerDecoder.",
    "Process the result and update the attentions.",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "We need to save a copy of optim.optimizer.state_dict() for setting",
    "the, optimizer state later on in Stage 2 in this method, since",
    "the method optim.set_parameters(model.parameters()) will overwrite",
    "optim.optimizer, and with ith the values stored in",
    "optim.optimizer.state_dict()",
    "Stage 1:",
    "Essentially optim.set_parameters (re-)creates and optimizer using",
    "model.paramters() as parameters that will be stored in the",
    "optim.optimizer.param_groups field of the torch optimizer class.",
    "Importantly, this method does not yet load the optimizer state, as",
    "essentially it builds a new optimizer with empty optimizer state and",
    "parameters from the model.",
    "Stage 2: In this stage, which is only performed when loading an",
    "optimizer from a checkpoint, we load the saved_optimizer_state_dict",
    "into the re-created optimizer, to set the optim.optimizer.state",
    "field, which was previously empty. For this, we use the optimizer",
    "state saved in the \"saved_optimizer_state_dict\" variable for",
    "this purpose.",
    "See also: https://github.com/pytorch/pytorch/issues/2830",
    "Convert back the state values to cuda type if applicable",
    "We want to make sure that indeed we have a non-empty optimizer state",
    "when we loaded an existing model. This should be at least the case",
    "for Adam, which saves \"exp_avg\" and \"exp_avg_sq\" state",
    "(Exponential moving average of gradient and squared gradient values)",
    "Decay method used in tensor2tensor.",
    "Decay based on start_decay_steps every decay_steps",
    "-*- coding: utf-8 -*-",
    "for sparsemax loss, the loss function operates on the raw output",
    "vector, not a probability vector. Hence it's only necessary to",
    "apply the first part of the generator here.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "coding: utf-8",
    "Below are helper functions for intra-class use only.",
    "-*- coding: utf-8 -*-",
    "Hack. Can't pickle defaultdict :(",
    "For all data types, the tgt side corpus is in form of text.",
    "Load vocabulary",
    "All datasets have same num of n_tgt_features,",
    "getting the last one is OK.",
    "All datasets have same num of n_src_features,",
    "getting the last one is OK.",
    "Merge the input and output vocabularies.",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "We have at least one dataset.",
    "We return the len of cur_dataset, otherwise we need to load",
    "all datasets to determine the real len, which loses the benefit",
    "of lazy loading.",
    "We clear `fields` when saving, restore when loading.",
    "Sort batch by decreasing lengths of sentence required by pytorch.",
    "sort=False means \"Use dataset's sortkey instead of iterator's\".",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: <bos> w1 ... wN <eos>",
    "Tgt: w1 ... wN <eos>",
    "device = opt.device_id if opt.gpuid else -1",
    "breaking change torchtext 0.3",
    "Sort the glob output by file name (by increasing indexes).",
    "Only one inputters.*Dataset, simple!",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "STFT",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "-*- coding: utf-8 -*-",
    "self.src_vocabs: mutated in dynamic_dict, used in",
    "collapse_copy_scores and in Translator.py",
    "Each element of an example is a dictionary whose keys represents",
    "at minimum the src tokens and their indices and potentially also",
    "the src and tgt features and alignment information.",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "Default to a balanced sort, prioritizing tgt len match.",
    "TODO: make this configurable.",
    "All examples have same number of features, so we peek first one",
    "to get the num_feats.",
    "Chain back the first element - we only want to peek it.",
    "Below are helper functions for intra-class use only.",
    "Mapping source tokens to indices in the dynamic dict.",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "This part of check is time consuming on Py2 (but",
    "it is quite fast on Py3, weird!). So we don't bother",
    "to check for very line. Instead we chekc every 64",
    "lines. Thus we are not dividing exactly per",
    "`shard_size`, but it is not too much difference.",
    "All examples must have same number of features.",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "Not yet supported on multi-gpu",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "!/usr/bin/env python",
    "use ensemble decoding if more than one model is specified",
    "for debugging",
    "Statistics",
    "Debug attention.",
    "TODO: faster code path for beam_size == 1.",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Tile states and memory beam_size times.",
    "Give full probability to the first beam on the first step.",
    "Decoder forward.",
    "Generator forward.",
    "Multiply probs by the beam probability.",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Resolve beam origin and true word ids.",
    "Map beam_index to batch_index in the flat representation.",
    "End condition is the top beam reached end_token.",
    "Save result of finished sentences.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Select and reorder alive batches.",
    "Append last prediction.",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "Define a list of tokens to exclude from ngram-blocking",
    "exclusion_list = [\"<t>\", \"</t>\", \".\"]",
    "Help functions for working with beams and batches",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "(3) run the decoder to generate sentences, using beam search.",
    "Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "Turn any copied words to UNKs",
    "0 is unk",
    "Temporary kludge solution to handle changed dim expectation",
    "in the decoder",
    "Run one step.",
    "dec_out: beam x rnn_size",
    "(b) Compute a vector of batch x beam word scores.",
    "beam x tgt_vocab",
    "beam x (tgt_vocab + extra_vocab)",
    "beam x tgt_vocab",
    "(c) Advance each beam.",
    "(4) Extract sentences from beam.",
    "(1) run the encoder on the src",
    "(2) if a target is specified, compute the 'goldScore'",
    "(i.e. log likelihood) of the target under the model",
    "Log prob of each word.",
    "Rollback pointer to the beginning.",
    "!/usr/bin/env python",
    "backwards compatibility for confs",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Sorting"
  ],
  "v0.2": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "We will use glob.glob() to find sharded {train|valid}.[0-9]*.pt",
    "when training, so check to avoid tampering with existing pt files",
    "or mixing them up.",
    "We save fields in vocab.pt separately, so make it empty.",
    "Currently we only do preprocess sharding for corpus: data_type=='text'.",
    "For data_type == 'img' or 'audio', currently we don't do",
    "preprocess sharding. We only build a monolithic dataset.",
    "But since the interfaces are uniform, it would be not hard",
    "to do this should users need this feature.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "Can't save fields, so remove/reconstruct at training time.",
    "!/usr/bin/env python",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "\"rnn\" or \"brnn\"",
    "Build encoder.",
    "Build decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Build NMTModel(= encoder + decoder).",
    "Build Generator.",
    "Load the model states from checkpoint or initialize them.",
    "Add generator to model (this registers it as parameter of model).",
    "!/usr/bin/env python",
    "Create a thread to listen for errors in the child processes.",
    "Train with multiprocessing.",
    "propagate exception to parent process, keeping original traceback",
    "!/usr/bin/env python",
    "this one is needed for torchtext random call (shuffled iterator)",
    "in multi gpu it ensures datasets are read in the same order",
    "These ensure same initialization in multi gpu mode",
    "Load checkpoint if we resume from a previous training.",
    "Peek the first dataset to determine the data_type.",
    "(All datasets have the same data_type).",
    "Load fields generated from preprocess phase.",
    "Report src/tgt features.",
    "Build model.",
    "Build optimizer.",
    "Build model saver",
    "Do training.",
    "Embedding Options",
    "Encoder-Decoder Options",
    "group.add_argument('-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Generator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "Basic attributes.",
    "Set model in training mode.",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT: reminder not compatible with accum > 1",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss in shards for memory efficiency.",
    "4. Update the parameters and statistics.",
    "Multi GPU gradient gather",
    "If truncated, don't backprop fully.",
    "in case of multi step gradient accumulation,",
    "update only after accum batches",
    "For Flake",
    "Initialize the bridge layer",
    "s_len, batch, emb_dim = emb.size()",
    "Lengths data is wrapped inside a Tensor.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "(batch_size, 1, nfft, t)",
    "layer 1",
    "(batch_size, 32, nfft/2, t/2)",
    "(batch_size, 32, nfft/2/2, t/2)",
    "layer 2",
    "(batch_size, 32, nfft/2/2, t/2)",
    "s_len, batch, emb_dim = emb.size()",
    "from onmt.utils.misc import aeq",
    "Run the forward pass of every layer of the tranformer.",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "This class is mainly used by decoder.py for RNNs but also",
    "by the CNN / transformer decoder when copy attention is used",
    "CNN has its own attention mechanism ConvMultiStepAttention",
    "Transformer has its own MultiHeadedAttention",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax or sparsemax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "clamping necessary because of numerical errors: loss should be lower",
    "bounded by zero, but negative values near zero are possible without",
    "the clamp",
    "from onmt.utils.misc import aeq",
    "CHECKS",
    "batch, k_len, d = key.size()",
    "batch_, k_len_, d_ = value.size()",
    "aeq(batch, batch_)",
    "aeq(k_len, k_len_)",
    "aeq(d, d_)",
    "batch_, q_len, d_ = query.size()",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "aeq(self.model_dim % 8, 0)",
    "if mask is not None:",
    "batch_, q_len_, k_len_ = mask.size()",
    "aeq(batch_, batch)",
    "aeq(k_len_, k_len)",
    "aeq(q_len_ == q_len)",
    "END CHECKS",
    "1) Project key, value, and query.",
    "2) Calculate and scale scores.",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "batch_, q_len_, d_ = output.size()",
    "aeq(q_len, q_len_)",
    "aeq(batch, batch_)",
    "aeq(d, d_)",
    "Return one attn",
    "At the moment this class is only used by embeddings.Embeddings look-up tables",
    "-*- coding: utf-8 -*-",
    "checks",
    "batch, channel, height, width = base_target_emb.size()",
    "batch_, channel_, height_, width_ = input_from_dec.size()",
    "enc_batch, enc_channel, enc_height = encoder_out_top.size()",
    "enc_batch_, enc_channel_, enc_height_ = encoder_out_combine.size()",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "This is used nowhere in the code at the moment (Vincent Nguyen 05/18/2018)",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "store roots on diagonal",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probibility of not copying: p_{word}(w) * (1 - p(z))",
    "Compute unks in align and target for readability",
    "Copy probability of tokens in source",
    "Set scores for unk to 0 and add eps",
    "Get scores for tokens in target",
    "Regular prob (no unks and unks that can't be copied)",
    "Add score for non-unks in target",
    "Add score for when word is unk in both align and tgt",
    "Forced copy. Add only probability for not-copied tokens",
    "Drop padding.",
    "We lazily load datasets when there are more than one, so postpone",
    "the setting of cur_dataset.",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "Compute Loss as NLL divided by seq length",
    "Compute Sequence Lengths",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-data option is required, but not used in this test, so dummy.",
    "Helper to generate a vocabulary",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16),",
    "('rnn_size', 16)],",
    "\"\"\" Only do SRU test if requirment is safisfied. \"\"\"",
    "SRU doesn't support input_feed.",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Remove the generated *pt files.",
    "4 specicials + 2 words (since we pass 2 to merge_vocabs)",
    "Test image preprocessing",
    "Test audio preprocessing",
    "Basic attributes.",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "Set up a separated copy attention layer, if needed.",
    "Check",
    "tgt.size() returns tgt length and batch",
    "END",
    "Run the forward pass of the RNN.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "NOTE: v0.3 to 0.4: decoder_outputs / attns[*] may not be list",
    "(in particular in case of SRU) it was not raising error in 0.3",
    "since stack(Variable) was allowed.",
    "In 0.4, SRU returns a tensor that shouldn't be stacke",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Initialize local and return variables.",
    "Run the forward pass of the RNN.",
    "Check",
    "END",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Initialize local and return variables.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Run the forward pass of the copy attention layer.",
    "Return result.",
    "Init the input feed.",
    "Basic attributes.",
    "Build the CNN.",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "NOTE: memory_lengths is only here for compatibility reasons",
    "with onmt.modules.RNNDecoderBase.forward()",
    "CHECKS",
    "END CHECKS",
    "Initialize return variables.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Run the forward pass of the CNNDecoder.",
    "Process the result and update the attentions.",
    "Update the state.",
    "Register self.mask as a buffer in TransformerDecoderLayer, so",
    "it gets TransformerDecoderLayer's cuda behavior automatically.",
    "Basic attributes.",
    "Build TransformerDecoder.",
    "TransformerDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "Initialize return variables.",
    "Run the forward pass of the TransformerDecoder.",
    "Process the result and update the attentions.",
    "buffer size in bytes, determine equiv. # of elements based on data type",
    "copy tensors into buffer_t",
    "all-reduce and rescale",
    "copy all-reduced buffer back into tensors",
    "tensor is bigger than buffer, all-reduce and rescale directly",
    "buffer is full, all-reduce and replace buffer with grad",
    "add tensor to buffer",
    "We need to save a copy of optim.optimizer.state_dict() for setting",
    "the, optimizer state later on in Stage 2 in this method, since",
    "the method optim.set_parameters(model.parameters()) will overwrite",
    "optim.optimizer, and with ith the values stored in",
    "optim.optimizer.state_dict()",
    "Stage 1:",
    "Essentially optim.set_parameters (re-)creates and optimizer using",
    "model.paramters() as parameters that will be stored in the",
    "optim.optimizer.param_groups field of the torch optimizer class.",
    "Importantly, this method does not yet load the optimizer state, as",
    "essentially it builds a new optimizer with empty optimizer state and",
    "parameters from the model.",
    "Stage 2: In this stage, which is only performed when loading an",
    "optimizer from a checkpoint, we load the saved_optimizer_state_dict",
    "into the re-created optimizer, to set the optim.optimizer.state",
    "field, which was previously empty. For this, we use the optimizer",
    "state saved in the \"saved_optimizer_state_dict\" variable for",
    "this purpose.",
    "See also: https://github.com/pytorch/pytorch/issues/2830",
    "Convert back the state values to cuda type if applicable",
    "We want to make sure that indeed we have a non-empty optimizer state",
    "when we loaded an existing model. This should be at least the case",
    "for Adam, which saves \"exp_avg\" and \"exp_avg_sq\" state",
    "(Exponential moving average of gradient and squared gradient values)",
    "Decay method used in tensor2tensor.",
    "Decay based on start_decay_steps every decay_steps",
    "-*- coding: utf-8 -*-",
    "for sparsemax loss, the loss function operates on the raw output",
    "vector, not a probability vector. Hence it's only necessary to",
    "apply the first part of the generator here.",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "Log the progress using the number of batches on the x-axis.",
    "Get a list of world_size lists with len(stat_list) Statistics objects",
    "SRU doesn't support PackedSequence.",
    "-*- coding: utf-8 -*-",
    "coding: utf-8",
    "Below are helper functions for intra-class use only.",
    "-*- coding: utf-8 -*-",
    "Hack. Can't pickle defaultdict :(",
    "For all data types, the tgt side corpus is in form of text.",
    "Load vocabulary",
    "All datasets have same num of n_tgt_features,",
    "getting the last one is OK.",
    "All datasets have same num of n_src_features,",
    "getting the last one is OK.",
    "Merge the input and output vocabularies.",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "We have at least one dataset.",
    "We return the len of cur_dataset, otherwise we need to load",
    "all datasets to determine the real len, which loses the benefit",
    "of lazy loading.",
    "We clear `fields` when saving, restore when loading.",
    "Sort batch by decreasing lengths of sentence required by pytorch.",
    "sort=False means \"Use dataset's sortkey instead of iterator's\".",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: <bos> w1 ... wN <eos>",
    "Tgt: w1 ... wN <eos>",
    "device = opt.device_id if opt.gpuid else -1",
    "breaking change torchtext 0.3",
    "Sort the glob output by file name (by increasing indexes).",
    "Only one inputters.*Dataset, simple!",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "STFT",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "-*- coding: utf-8 -*-",
    "self.src_vocabs: mutated in dynamic_dict, used in",
    "collapse_copy_scores and in Translator.py",
    "Each element of an example is a dictionary whose keys represents",
    "at minimum the src tokens and their indices and potentially also",
    "the src and tgt features and alignment information.",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "Default to a balanced sort, prioritizing tgt len match.",
    "TODO: make this configurable.",
    "All examples have same number of features, so we peek first one",
    "to get the num_feats.",
    "Chain back the first element - we only want to peek it.",
    "Below are helper functions for intra-class use only.",
    "Mapping source tokens to indices in the dynamic dict.",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "This part of check is time consuming on Py2 (but",
    "it is quite fast on Py3, weird!). So we don't bother",
    "to check for very line. Instead we chekc every 64",
    "lines. Thus we are not dividing exactly per",
    "`shard_size`, but it is not too much difference.",
    "All examples must have same number of features.",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "Not yet supported on multi-gpu",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this",
    "!/usr/bin/env python",
    "for debugging",
    "Statistics",
    "Debug attention.",
    "TODO: faster code path for beam_size == 1.",
    "TODO: support these blacklisted features.",
    "Encoder forward.",
    "Tile states and memory beam_size times.",
    "Give full probability to the first beam on the first step.",
    "Decoder forward.",
    "Generator forward.",
    "Multiply probs by the beam probability.",
    "Flatten probs into a list of possibilities.",
    "Recover log probs.",
    "Resolve beam origin and true word ids.",
    "Map beam_index to batch_index in the flat representation.",
    "End condition is the top beam reached end_token.",
    "Save result of finished sentences.",
    "If all sentences are translated, no need to go further.",
    "Remove finished batches for the next step.",
    "Select and reorder alive batches.",
    "Append last prediction.",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "Define a list of tokens to exclude from ngram-blocking",
    "exclusion_list = [\"<t>\", \"</t>\", \".\"]",
    "Help functions for working with beams and batches",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "(3) run the decoder to generate sentences, using beam search.",
    "Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "Turn any copied words to UNKs",
    "0 is unk",
    "Temporary kludge solution to handle changed dim expectation",
    "in the decoder",
    "Run one step.",
    "dec_out: beam x rnn_size",
    "(b) Compute a vector of batch x beam word scores.",
    "beam x tgt_vocab",
    "beam x (tgt_vocab + extra_vocab)",
    "beam x tgt_vocab",
    "(c) Advance each beam.",
    "(4) Extract sentences from beam.",
    "(1) run the encoder on the src",
    "(2) if a target is specified, compute the 'goldScore'",
    "(i.e. log likelihood) of the target under the model",
    "Log prob of each word.",
    "Rollback pointer to the beginning.",
    "!/usr/bin/env python",
    "NOTE: translator returns lists of `n_best` list",
    "we can ignore that (i.e. flatten lists) only because",
    "we restrict `n_best=1`",
    "build back results with empty texts",
    "Sorting"
  ],
  "v0.1": [
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "We will use glob.glob() to find sharded {train|valid}.[0-9]*.pt",
    "when training, so check to avoid tampering with existing pt files",
    "or mixing them up.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "Currently we only do preprocess sharding for corpus: data_type=='text'.",
    "For data_type == 'img' or 'audio', currently we don't do",
    "preprocess sharding. We only build a monolithic dataset.",
    "But since the interfaces are uniform, it would be not hard",
    "to do this should users need this feature.",
    "We save fields in vocab.pt seperately, so make it empty.",
    "Can't save fields, so remove/reconstruct at training time.",
    "!/usr/bin/env python",
    "onmt.opts.py",
    "Set up the Crayon logging server.",
    "Log the progress using the number of batches on the x-axis.",
    "We have at least one dataset.",
    "We return the len of cur_dataset, otherwise we need to load",
    "all datasets to determine the real len, which loses the benefit",
    "of lazy loading.",
    "We clear `fields` when saving, restore when loading.",
    "Sort batch by decreasing lengths of sentence required by pytorch.",
    "sort=False means \"Use dataset's sortkey instead of iterator's\".",
    "In token batching scheme, the number of sequences is limited",
    "such that the total number of src/tgt tokens (including padding)",
    "in a batch <= batch_size",
    "Maintains the longest src and tgt length in the current batch",
    "Reset current longest length at a new batch (count=1)",
    "Src: <bos> w1 ... wN <eos>",
    "Tgt: w1 ... wN <eos>",
    "1. Train for one epoch on the training set.",
    "2. Validate on the validation set.",
    "3. Log to remote server.",
    "4. Update the learning rate",
    "5. Drop a checkpoint if needed.",
    "Sort the glob output by file name (by increasing indexes).",
    "Only one onmt.io.*Dataset, simple!",
    "We need to save a copy of optim.optimizer.state_dict() for setting",
    "the, optimizer state later on in Stage 2 in this method, since",
    "the method optim.set_parameters(model.parameters()) will overwrite",
    "optim.optimizer, and with ith the values stored in",
    "optim.optimizer.state_dict()",
    "Stage 1:",
    "Essentially optim.set_parameters (re-)creates and optimizer using",
    "model.paramters() as parameters that will be stored in the",
    "optim.optimizer.param_groups field of the torch optimizer class.",
    "Importantly, this method does not yet load the optimizer state, as",
    "essentially it builds a new optimizer with empty optimizer state and",
    "parameters from the model.",
    "Stage 2: In this stage, which is only performed when loading an",
    "optimizer from a checkpoint, we load the saved_optimizer_state_dict",
    "into the re-created optimizer, to set the optim.optimizer.state",
    "field, which was previously empty. For this, we use the optimizer",
    "state saved in the \"saved_optimizer_state_dict\" variable for",
    "this purpose.",
    "See also: https://github.com/pytorch/pytorch/issues/2830",
    "Convert back the state values to cuda type if applicable",
    "We want to make sure that indeed we have a non-empty optimizer state",
    "when we loaded an existing model. This should be at least the case",
    "for Adam, which saves \"exp_avg\" and \"exp_avg_sq\" state",
    "(Exponential moving average of gradient and squared gradient values)",
    "Debugging method for showing the optimizer state",
    "Load checkpoint if we resume from a previous training.",
    "I don't like reassigning attributes of opt: it's not clear.",
    "Peek the fisrt dataset to determine the data_type.",
    "(All datasets have the same data_type).",
    "Load fields generated from preprocess phase.",
    "Report src/tgt features.",
    "Build model.",
    "Build optimizer.",
    "Do training.",
    "If using tensorboard for logging, close the writer after training.",
    "illegal_weights_mask = torch.ByteTensor([",
    "[0, 0, 0, 0, 0, 0, 0],",
    "[0, 0, 0, 1, 1, 1, 1],",
    "[0, 0, 0, 0, 0, 1, 1],",
    "[0, 0, 1, 1, 1, 1, 1]])",
    "TODO: fix for pytorch 0.3",
    "illegal_weights = alignments.masked_select(illegal_weights_mask)",
    "self.assertEqual(0.0, illegal_weights.data.sum())",
    "-data option is required, but not used in this test, so dummy.",
    "Helper to generate a vocabulary",
    "len x batch x nfeat",
    "batch x c x h x w",
    "batch x 1 x nfft x t",
    "Initialize vectors to compare size with",
    "Ensure correct sizes and types",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "Make sure that output has the correct size and type",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16), ('rnn_size', 16)],",
    "[('encoder_type', 'transformer'),",
    "('word_vec_size', 16),",
    "('rnn_size', 16)],",
    "SRU doesn't support input_feed.",
    "Remove the generated *pt files.",
    "4 specicials + 2 words (since we pass 2 to merge_vocabs)",
    "Test image preprocessing",
    "Test audio preprocessing",
    "!/usr/bin/env python3",
    "-*- coding: utf-8 -*-",
    "",
    "OpenNMT-py documentation build configuration file, created by",
    "sphinx-quickstart on Sun Dec 17 12:07:14 2017.",
    "",
    "This file is execfile()d with the current directory set to its",
    "containing dir.",
    "",
    "Note that not all possible configuration values are present in this",
    "autogenerated file.",
    "",
    "All configuration values have a default; values that are commented out",
    "serve to show the default.",
    "If extensions (or modules to document with autodoc) are in another directory,",
    "add these directories to sys.path here. If the directory is relative to the",
    "documentation root, use os.path.abspath to make it absolute, like shown here.",
    "",
    "import os",
    "import sys",
    "sys.path.insert(0, os.path.abspath('.'))",
    "-- General configuration ------------------------------------------------",
    "If your documentation needs a minimal Sphinx version, state it here.",
    "",
    "needs_sphinx = '1.0'",
    "Add any Sphinx extension module names here, as strings. They can be",
    "extensions coming with Sphinx (named 'sphinx.ext.*') or your custom",
    "ones.",
    "Add any paths that contain templates here, relative to this directory.",
    "The suffix(es) of source filenames.",
    "You can specify multiple suffix as a list of string:",
    "",
    "source_suffix = ['.rst', '.md']",
    "The master toctree document.",
    "General information about the project.",
    "The version info for the project you're documenting, acts as replacement for",
    "|version| and |release|, also used in various other places throughout the",
    "built documents.",
    "",
    "The short X.Y version.",
    "The full version, including alpha/beta/rc tags.",
    "The language for content autogenerated by Sphinx. Refer to documentation",
    "for a list of supported languages.",
    "",
    "This is also used if you do content translation via gettext catalogs.",
    "Usually you set \"language\" from the command line for these cases.",
    "List of patterns, relative to source directory, that match files and",
    "directories to ignore when looking for source files.",
    "This patterns also effect to html_static_path and html_extra_path",
    "The name of the Pygments (syntax highlighting) style to use.",
    "If true, `todo` and `todoList` produce output, else they produce nothing.",
    "-- Options for HTML output ----------------------------------------------",
    "The theme to use for HTML and HTML Help pages.  See the documentation for",
    "a list of builtin themes.",
    "",
    "html_theme = 'sphinx_materialdesign_theme'",
    "html_theme_path = [sphinx_materialdesign_theme.get_path()]",
    "Theme options are theme-specific and customize the look and feel of a theme",
    "further.  For a list of options available for each theme, see the",
    "documentation.",
    "",
    "html_theme_options = {}",
    "Add any paths that contain custom static files (such as style sheets) here,",
    "relative to this directory. They are copied after the builtin static files,",
    "so a file named \"default.css\" will overwrite the builtin \"default.css\".",
    "Custom sidebar templates, must be a dictionary that maps document names",
    "to template names.",
    "",
    "This is required for the alabaster theme",
    "refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars",
    "-- Options for HTMLHelp output ------------------------------------------",
    "Output file base name for HTML help builder.",
    "-- Options for LaTeX output ---------------------------------------------",
    "The paper size ('letterpaper' or 'a4paper').",
    "",
    "'papersize': 'letterpaper',",
    "The font size ('10pt', '11pt' or '12pt').",
    "",
    "'pointsize': '10pt',",
    "Additional stuff for the LaTeX preamble.",
    "",
    "'preamble': '',",
    "Latex figure (float) alignment",
    "",
    "'figure_align': 'htbp',",
    "Grouping the document tree into LaTeX files. List of tuples",
    "(source start file, target name, title,",
    "author, documentclass [howto, manual, or own class]).",
    "-- Options for manual page output ---------------------------------------",
    "One entry per manual page. List of tuples",
    "(source start file, name, description, authors, manual section).",
    "-- Options for Texinfo output -------------------------------------------",
    "Grouping the document tree into Texinfo files. List of tuples",
    "(source start file, target name, title, author,",
    "dir menu entry, description, category)",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "the vocab object is a list of tuple (name, torchtext.Vocab)",
    "we iterate over this list and associate vocabularies based on the name",
    "Add in default model arguments, possibly added since training.",
    "-*- encoding: utf-8 -*-",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "check version information",
    "some hacking to deal with duplicates (only consider first instance)",
    "don't print end-of-word symbols",
    "sys.stderr.write('cannot split {0} further.\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "sys.stderr.write('OOV: {0}\\n'.format(segment))",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "!/usr/bin/env python",
    "-*- coding: utf-8 -*-",
    "Author: Rico Sennrich",
    "flake8: noqa",
    "This file is retrieved from https://github.com/rsennrich/subword-nmt",
    "hack for python2/3 compatibility",
    "find all instances of pair, and update frequency/indices around it",
    "find first symbol",
    "if first symbol is followed by second symbol, we've found an occurrence of pair (old_word[i:i+2])",
    "assuming a symbol sequence \"A B C\", if \"B C\" is merged, reduce the frequency of \"A B\"",
    "assuming a symbol sequence \"A B C B\", if \"B C\" is merged, reduce the frequency of \"C B\".",
    "however, skip this if the sequence is A B C B C, because the frequency of \"C B\" will be reduced by the previous code block",
    "find new pair",
    "assuming a symbol sequence \"A BC D\", if \"B C\" is merged, increase the frequency of \"A BC\"",
    "assuming a symbol sequence \"A BC B\", if \"B C\" is merged, increase the frequency of \"BC B\"",
    "however, if the sequence is A BC BC, skip this step because the count of \"BC BC\" will be incremented by the previous code block",
    "data structure of pair frequencies",
    "index from pairs to words",
    "version 0.2 changes the handling of the end-of-word token ('</w>');",
    "version numbering allows bckward compatibility",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "we probably missed the best pair because of pruning; go back to full statistics",
    "threshold is inspired by Zipfian assumption, but should only affect speed",
    "python 2/3 compatibility",
    "read/write files as UTF-8",
    "!/usr/bin/env python",
    "Use pytorch version when available.",
    "SRU doesn't support PackedSequence.",
    "Initialize the bridge layer",
    "Lengths data is wrapped inside a Variable.",
    "LSTM has hidden and cell state, other only one",
    "Total number of states",
    "Build a linear layer for each",
    "Basic attributes.",
    "Build the RNN.",
    "Set up the context gate.",
    "Set up the standard attention.",
    "Set up a separated copy attention layer, if needed.",
    "Check",
    "END",
    "Run the forward pass of the RNN.",
    "Update the state with the result.",
    "Concatenates sequence of tensors along a new dimension.",
    "The encoder hidden is  (layers*directions) x batch x dim.",
    "We need to convert it to layers x batch x (directions*dim).",
    "Initialize local and return variables.",
    "Run the forward pass of the RNN.",
    "Check",
    "END",
    "Calculate the attention.",
    "Calculate the context gate.",
    "Additional args check.",
    "END Additional args check.",
    "Initialize local and return variables.",
    "Input feed concatenates hidden state with",
    "input at every time step.",
    "TODO: context gate should be employed",
    "instead of second RNN transform.",
    "Update the coverage attention.",
    "Run the forward pass of the copy attention layer.",
    "Return result.",
    "Not yet supported on multi-gpu",
    "Init the input feed.",
    "Embedding Options",
    "Encoder-Deocder Options",
    "group.add_argument('-residual',   action=\"store_true\",",
    "help=\"Add residual connections between RNN layers.\")",
    "Attention options",
    "Genenerator and loss options.",
    "Data options",
    "Dictionary options, for text corpus",
    "Truncation options, for text corpus",
    "Data processing options",
    "Options most relevant to speech",
    "Model loading/saving options",
    "GPU",
    "Init options",
    "Pretrained word vectors",
    "Fixed word vectors",
    "Optimization options",
    "learning rate",
    "Use TensorboardX for visualization during training",
    "Options most relevant to speech",
    "Options most relevant to summarization.",
    "Alpha and Beta values for Google Length + Coverage penalty",
    "Described here: https://arxiv.org/pdf/1609.08144.pdf, Section 7",
    "Options most relevant to speech.",
    "MARKDOWN boilerplate",
    "Copyright 2016 The Chromium Authors. All rights reserved.",
    "Use of this source code is governed by a BSD-style license that can be",
    "found in the LICENSE file.",
    "**section heading**:",
    "# **--argument-one**",
    "When label smoothing is turned on,",
    "KL-divergence between q_{smoothed ground truth prob.}(w)",
    "and p_{prob. computed by model}(w) is minimized.",
    "If label smoothing value is set to zero, the loss",
    "is equivalent to NLLLoss or CrossEntropyLoss.",
    "All non-true labels are uniformly set to low-confidence.",
    "Default: report smoothed ppl.",
    "loss_data = -log_likelihood.sum(0)",
    "non_none: the subdict of the state dictionary where the values",
    "are not None.",
    "Now, the iteration:",
    "state is a dictionary of sequences of tensor-like but we",
    "want a sequence of dictionaries of tensors.",
    "First, unzip the dictionary into a sequence of keys and a",
    "sequence of tensor-like sequences.",
    "Now, yield a dictionary for each shard. The keys are always",
    "the same. values is a sequence of length #keys where each",
    "element is a sequence of length #shards. We want to iterate",
    "over the shards, not over the keys: therefore, the values need",
    "to be re-zipped by shard and then each shard can be paired",
    "with the keys.",
    "Assumed backprop'd",
    "We use the default parameters for Adam that are suggested by",
    "the original paper https://arxiv.org/pdf/1412.6980.pdf",
    "These values are also used by other established implementations,",
    "e.g. https://www.tensorflow.org/api_docs/python/tf/train/AdamOptimizer",
    "https://keras.io/optimizers/",
    "Recently there are slightly different values used in the paper",
    "\"Attention is all you need\"",
    "https://arxiv.org/pdf/1706.03762.pdf, particularly the value beta2=0.98",
    "was used there however, beta2=0.999 is still arguably the more",
    "established value, so we use that here as well",
    "Decay method used in tensor2tensor.",
    "For flake8 compatibility",
    "Basic attributes.",
    "Set model in training mode.",
    "Dynamic batching",
    "Set model in validating mode.",
    "F-prop through the model.",
    "Compute loss.",
    "Update statistics.",
    "Set model back to training mode.",
    "Truncated BPTT",
    "1. Create truncated target.",
    "2. F-prop all but generator.",
    "3. Compute loss in shards for memory efficiency.",
    "4. Update the parameters and statistics.",
    "If truncated, don't backprop fully.",
    "\"rnn\" or \"brnn\"",
    "Make encoder.",
    "Make decoder.",
    "Share the embedding matrix - preprocess with share_vocab required.",
    "src/tgt vocab should be the same if `-share_vocab` is specified.",
    "Make NMTModel(= encoder + decoder).",
    "Make Generator.",
    "Load the model states from checkpoint or initialize them.",
    "Add generator to model (this registers it as parameter of model).",
    "Make the whole model leverage GPU if indicated to do so.",
    "linear transform for 3-d tensor",
    "checks",
    "flake8: noqa",
    "For command-line option parsing",
    "Check pass, set the args.",
    "This SRU version implements its own cuda-level optimization,",
    "so it requires that:",
    "1. `cupy` and `pynvrtc` python package installed.",
    "2. pytorch is built with cuda support.",
    "3. library path set: export LD_LIBRARY_PATH=<cuda lib path>.",
    "Check 1.",
    "Check 2.",
    "Check 3.",
    "This cuda() is important, it sets up device to use.",
    "-> directions x batch x dim",
    "For DEBUG",
    "size = (length, batch, x.size(-1)) \\",
    "if x.dim() == 3 else (batch, x.size(-1))",
    "grad_x = x.new(*x.size()) if k_ == 3 else x.new(*size).zero_()",
    "Normal use",
    "An entry check here, will catch on train side and translate side",
    "if requirements are not satisfied.",
    "RNNDecoderState wraps hidden as a tuple.",
    "fh -> (layers*directions) x batch x dim",
    "mlp wants it with bias",
    "Check input sizes",
    "(batch, t_len, d) x (batch, d, s_len) --> (batch, t_len, s_len)",
    "(batch, t_len, s_len, d)",
    "one step input",
    "compute attention scores, as in Luong et al.",
    "Softmax to normalize attention weights",
    "each context vector c_t is the weighted average",
    "over all the source hidden states",
    "concatenate",
    "Check output sizes",
    "Check output sizes",
    "Basic attributes.",
    "Build the CNN.",
    "CNNDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "CHECKS",
    "END CHECKS",
    "Initialize return variables.",
    "The output of CNNEncoder.",
    "The combination of output of CNNEncoder and source embeddings.",
    "Run the forward pass of the CNNDecoder.",
    "Process the result and update the attentions.",
    "Update the state.",
    "Save a little memory, by doing inplace.",
    "CHECKS",
    "END CHECKS",
    "Make mask.",
    "Run the forward pass of every layer of the tranformer.",
    "Register self.mask as a buffer in TransformerDecoderLayer, so",
    "it gets TransformerDecoderLayer's cuda behavior automatically.",
    "Args Checks",
    "aeq(t_len, t_len_, t_len__, input_len)",
    "END Args Checks",
    "CHECKS",
    "END CHECKS",
    "Basic attributes.",
    "Build TransformerDecoder.",
    "TransformerDecoder has its own attention mechanism.",
    "Set up a separated copy attention layer, if needed.",
    "CHECKS",
    "END CHECKS",
    "Initialize return variables.",
    "Run the forward pass of the TransformerDecoder.",
    "Process the result and update the attentions.",
    "Update the state.",
    "utility for retrieving polyak averaged params",
    "Update average",
    "utility for retrieving polyak averaged params",
    "out_features * in_features",
    "norm is out_features * 1",
    "batch_size * out_features",
    "out_features",
    "out_features",
    "batch_size * out_features",
    "out_channels, in_channels // groups, * kernel_size",
    "out_features",
    "in_channels, out_channels, *kernel_size",
    "in_channels, out_channels, *kernel_size",
    "self.out_channels, 1",
    "out_features",
    "out_features",
    "CHECKS",
    "Original probabilities.",
    "Probability of copying p(z=1) batch.",
    "Probibility of not copying: p_{word}(w) * (1 - p(z))",
    "Compute unks in align and target for readability",
    "Copy probability of tokens in source",
    "Set scores for unk to 0 and add eps",
    "Get scores for tokens in target",
    "Regular prob (no unks and unks that can't be copied)",
    "Add score for non-unks in target",
    "Add score for when word is unk in both align and tgt",
    "Forced copy. Add only probability for not-copied tokens",
    "Drop padding.",
    "We lazily load datasets when there are more than one, so postpone",
    "the setting of cur_dataset.",
    "Correct target copy token instead of <unk>",
    "tgt[i] = align[i] + len(tgt_vocab)",
    "for i such that tgt[i] == 0 and align[i] != 0",
    "Compute sum of perplexities for stats",
    "Compute Loss as NLL divided by seq length",
    "Compute Sequence Lengths",
    "Compute Total Loss per sequence in batch",
    "Divide by length of each sequence and sum",
    "store roots on diagonal",
    "We must wrap the self.pe in Variable to compute, not the other",
    "way - unwrap emb(i.e. emb.data). Otherwise the computation",
    "wouldn't be watched to build the compute graph.",
    "Dimensions and padding for constructing the word embedding matrix",
    "Dimensions and padding for feature embedding matrices",
    "(these have no effect if feat_vocab_sizes is empty)",
    "The embedding matrix look-up tables. The first look-up table",
    "is for words. Subsequent ones are for features, if any exist.",
    "The final output size of word + feature vectors. This can vary",
    "from the word vector size if and only if features are defined.",
    "This is the attribute you should access if you need to know",
    "how big your embeddings are going to be.",
    "The sequence of operations that converts the input sequence",
    "into a sequence of embeddings. At minimum this consists of",
    "looking up the embeddings for each word and feature in the",
    "input. Model parameters may require the sequence to contain",
    "additional operations as well.",
    "For flake8 compatibility.",
    "Pass in needed options only when modify function definition.",
    "(batch_size, 1, nfft, t)",
    "layer 1",
    "(batch_size, 32, nfft/2, t/2)",
    "(batch_size, 32, nfft/2/2, t/2)",
    "layer 2",
    "(batch_size, 32, nfft/2/2, t/2)",
    "CHECKS",
    "END CHECKS",
    "1) Project key, value, and query.",
    "2) Calculate and scale scores.",
    "3) Apply attention dropout and compute context vectors.",
    "CHECK",
    "Return one attn",
    "END CHECK",
    "Pass in needed options only when modify function definition.",
    "(batch_size, 64, imgH, imgW)",
    "layer 1",
    "(batch_size, 64, imgH/2, imgW/2)",
    "(batch_size, 128, imgH/2, imgW/2)",
    "layer 2",
    "(batch_size, 128, imgH/2/2, imgW/2/2)",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer 3",
    "batch norm 1",
    "(batch_size, 256, imgH/2/2, imgW/2/2)",
    "layer4",
    "(batch_size, 256, imgH/2/2/2, imgW/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2)",
    "layer 5",
    "batch norm 2",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "(batch_size, 512, imgH/2/2/2, imgW/2/2/2)",
    "# (batch_size, 512, H, W)",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "-*- coding: utf-8 -*-",
    "Hack. Can't pickle defaultdict :(",
    "Build src/tgt examples iterator from corpus files, also extract",
    "number of features.",
    "For all data types, the tgt side corpus is in form of text.",
    "Load vocabulary",
    "All datasets have same num of n_tgt_features,",
    "getting the last one is OK.",
    "All datasets have same num of n_src_features,",
    "getting the last one is OK.",
    "Merge the input and output vocabularies.",
    "`tgt_vocab_size` is ignored when sharing vocabularies",
    "-*- coding: utf-8 -*-",
    "Below are helper functions for intra-class use only.",
    "-*- coding: utf-8 -*-",
    "self.src_vocabs: mutated in dynamic_dict, used in",
    "collapse_copy_scores and in Translator.py",
    "Each element of an example is a dictionary whose keys represents",
    "at minimum the src tokens and their indices and potentially also",
    "the src and tgt features and alignment information.",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "Default to a balanced sort, prioritizing tgt len match.",
    "TODO: make this configurable.",
    "All examples have same number of features, so we peek first one",
    "to get the num_feats.",
    "Chain back the first element - we only want to peek it.",
    "Below are helper functions for intra-class use only.",
    "Mapping source tokens to indices in the dynamic dict.",
    "The codecs module seems to have bugs with seek()/tell(),",
    "so we use io.open().",
    "We have associate iterator, just yields tuples",
    "util we run parallel with it.",
    "Yield tuples util this shard's size reaches the threshold.",
    "This part of check is time consuming on Py2 (but",
    "it is quite fast on Py3, weird!). So we don't bother",
    "to check for very line. Instead we chekc every 64",
    "lines. Thus we are not dividing exactly per",
    "`shard_size`, but it is not too much difference.",
    "We peek the first line and seek back to",
    "the beginning of the file.",
    "All examples must have same number of features.",
    "-*- coding: utf-8 -*-",
    "Peek at the first to see which fields are used.",
    "If out_examples is a generator, we need to save the filter_pred",
    "function in serialization too, which would cause a problem when",
    "`torch.save()`. Thus we materialize it as a list.",
    "STFT",
    "NOTE: the translator exept a filepath as parameter",
    "therefore we write the data as a temp file.",
    "NOTE: If an input contains an line separator \\n we split it",
    "into subsegments that we translate independantly",
    "we then merge the translations together with the same",
    "line breaks",
    "Creating a new object is faster",
    "Sorting",
    "output += (\"GOLD SCORE: {:.4f}\".format(self.gold_score))",
    "for debugging",
    "Statistics",
    "Debug attention.",
    "(0) Prep each of the components of the search.",
    "And helper method for reducing verbosity.",
    "Define a list of tokens to exclude from ngram-blocking",
    "exclusion_list = [\"<t>\", \"</t>\", \".\"]",
    "Help functions for working with beams and batches",
    "(1) Run the encoder on the src.",
    "(2) Repeat src objects `beam_size` times.",
    "(3) run the decoder to generate sentences, using beam search.",
    "Construct batch x beam_size nxt words.",
    "Get all the pending current beam words and arrange for forward.",
    "Turn any copied words to UNKs",
    "0 is unk",
    "Temporary kludge solution to handle changed dim expectation",
    "in the decoder",
    "Run one step.",
    "dec_out: beam x rnn_size",
    "(b) Compute a vector of batch x beam word scores.",
    "beam x tgt_vocab",
    "beam x (tgt_vocab + extra_vocab)",
    "beam x tgt_vocab",
    "(c) Advance each beam.",
    "(4) Extract sentences from beam.",
    "(1) run the encoder on the src",
    "(2) if a target is specified, compute the 'goldScore'",
    "(i.e. log likelihood) of the target under the model",
    "Log prob of each word.",
    "The score for each translation on the beam.",
    "The backpointers at each time-step.",
    "The outputs at each time-step.",
    "Has EOS topped the beam yet.",
    "The attentions (matrix) for each time.",
    "Time and k pair for finished.",
    "Information for global scoring.",
    "Minimum prediction length",
    "Apply Penalty at every step",
    "force the output to be longer than self.min_length",
    "Sum the previous scores.",
    "Don't let EOS have children.",
    "Block ngram repeats",
    "Last n tokens, n = block_ngram_repeat",
    "Skip the blocking if it is in the exclusion list",
    "best_scores_id is flattened beam x word array, so calculate which",
    "word and beam each score came from",
    "End condition is when top-of-beam is EOS and no global score.",
    "Add from beam until we have minimum outputs.",
    "Term will be subtracted from probability",
    "Probability will be divided by this"
  ]
}