{
  "v0.11.1": [
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "setKeypointIndex(keypoint, newIndex) {",
    "let oldIndex = keypoint.indexLabel;",
    "if (newIndex == oldIndex) return;",
    "keypoint.indexLabel = parseInt(newIndex);",
    "if (oldIndex >= 0) {",
    "delete this._labelled[oldIndex];",
    "let otherIndices = this._edges[oldIndex];",
    "if (otherIndices) {",
    "otherIndices.forEach(i => this.removeLine([i, oldIndex]));",
    "}",
    "// TODO: Remove assoicated lines",
    "}",
    "if (newIndex >= 0) {",
    "this._labelled[newIndex] = keypoint;",
    "this._drawLines(keypoint);",
    "}",
    "}",
    "keypoint.color = this.strokeColor;",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "## File Watcher",
    "Flask/Gunicorn",
    "",
    "LOG_LEVEL - The granularity of log output",
    "",
    "A string of \"debug\", \"info\", \"warning\", \"error\", \"critical\"",
    "",
    "WORKER_CONNECTIONS - limits the maximum number of simultaneous",
    "clients that a single process can handle.",
    "",
    "A positive integer generally set to around 1000.",
    "",
    "WORKER_TIMEOUT - If a worker does not notify the master process",
    "in this number of seconds it is killed and a new worker is",
    "spawned to replace it.",
    "",
    "## Workers",
    "## Dataset Options",
    "## User Options",
    "## Models",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "Listen to directory events as some file systems don't generate",
    "per-file `deleted` events when moving/deleting directories",
    "check if its a hidden file",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "find a point that's inside the canvas",
    "print('point:', point, flush=True)",
    "Cruve",
    "Point",
    "prev_point_outside = prev_point[0] > image_width or prev_point[0] < 0 or prev_point[1] > image_height or prev_point[1] < 0",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "padding = args.get('padding')",
    "threshold = args.get('threshold')",
    "Calculate annotation counts by category in this dataset",
    "Calculate the annotation count in the current category in this dataset",
    "Calculate the annotated images count in the current category in this dataset",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Remove parsed arguments",
    "Generate query from remaining arugments",
    "Change category_ids__in to list",
    "Initialize mongo query with required elements:",
    "Define query names that should use complex logic:",
    "Add additional 'and' arguments to mongo query that do not require complex_query logic",
    "Add additional arguments to mongo query that require more complex logic to construct",
    "Only show annotated images with selected category_ids",
    "Only show non-annotated images",
    "Ahow annotated images with selected category_ids or non-annotated images",
    "Perform mongodb query",
    "for image in images:",
    "image_json = query_util.fix_ids(image)",
    "query = AnnotationModel.objects(image_id=image.id, deleted=False)",
    "category_ids = query.distinct('category_id')",
    "categories = CategoryModel.objects(id__in=category_ids).only('name', 'color')",
    "image_json['annotations'] = query.count()",
    "image_json['categories'] = query_util.fix_ids(categories)",
    "images_json.append(image_json)",
    "check if the id exits",
    "check if there is anything to update",
    "check if the name is empty",
    "update name of the category",
    "check if the name to update exits already in db",
    "@ToDo: Is it necessary to allow equal category names among different creators?",
    "it is only triggered when the name already exists and the creator is the same",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client",
    "import pycocotools.mask as mask",
    "iterate though all categoires and upsert",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "is_crowd = annotation.get('iscrowed', False)",
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "logger.debug(f\"Emitting {percent} progress update for task {self.id}\")",
    "-- Contants",
    "Set maximum thumbnail size (h x w) to use on dataset page",
    "-- Private",
    "-- Database",
    "Absolute path to image file",
    "True if the image is annotated",
    "Poeple currently annotation the image",
    "Get dataset name from path",
    "Resize image to fit in MAX_THUMBNAIL_DIM envelope as necessary",
    "Save as a jpeg to improve loading time",
    "(note file extension will not match but allows for backwards compatibility)",
    "TODO: Fix why using the functions throws an error",
    "meta = {'allow_inheritance': True}",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed"
  ],
  "v0.11.0": [
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "setKeypointIndex(keypoint, newIndex) {",
    "let oldIndex = keypoint.indexLabel;",
    "if (newIndex == oldIndex) return;",
    "keypoint.indexLabel = parseInt(newIndex);",
    "if (oldIndex >= 0) {",
    "delete this._labelled[oldIndex];",
    "let otherIndices = this._edges[oldIndex];",
    "if (otherIndices) {",
    "otherIndices.forEach(i => this.removeLine([i, oldIndex]));",
    "}",
    "// TODO: Remove assoicated lines",
    "}",
    "if (newIndex >= 0) {",
    "this._labelled[newIndex] = keypoint;",
    "this._drawLines(keypoint);",
    "}",
    "}",
    "keypoint.color = this.strokeColor;",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "## File Watcher",
    "Flask/Gunicorn",
    "",
    "LOG_LEVEL - The granularity of log output",
    "",
    "A string of \"debug\", \"info\", \"warning\", \"error\", \"critical\"",
    "",
    "WORKER_CONNECTIONS - limits the maximum number of simultaneous",
    "clients that a single process can handle.",
    "",
    "A positive integer generally set to around 1000.",
    "",
    "WORKER_TIMEOUT - If a worker does not notify the master process",
    "in this number of seconds it is killed and a new worker is",
    "spawned to replace it.",
    "",
    "## Workers",
    "## Dataset Options",
    "## User Options",
    "## Models",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "check if its a hidden file",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "find a point that's inside the canvas",
    "print('point:', point, flush=True)",
    "Cruve",
    "Point",
    "prev_point_outside = prev_point[0] > image_width or prev_point[0] < 0 or prev_point[1] > image_height or prev_point[1] < 0",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "padding = args.get('padding')",
    "threshold = args.get('threshold')",
    "Calculate annotation counts by category in this dataset",
    "Calculate the annotation count in the current category in this dataset",
    "Calculate the annotated images count in the current category in this dataset",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Remove parsed arguments",
    "Generate query from remaining arugments",
    "Change category_ids__in to list",
    "Initialize mongo query with required elements:",
    "Define query names that should use complex logic:",
    "Add additional 'and' arguments to mongo query that do not require complex_query logic",
    "Add additional arguments to mongo query that require more complex logic to construct",
    "Only show annotated images with selected category_ids",
    "Only show non-annotated images",
    "Ahow annotated images with selected category_ids or non-annotated images",
    "Perform mongodb query",
    "for image in images:",
    "image_json = query_util.fix_ids(image)",
    "query = AnnotationModel.objects(image_id=image.id, deleted=False)",
    "category_ids = query.distinct('category_id')",
    "categories = CategoryModel.objects(id__in=category_ids).only('name', 'color')",
    "image_json['annotations'] = query.count()",
    "image_json['categories'] = query_util.fix_ids(categories)",
    "images_json.append(image_json)",
    "check if the id exits",
    "check if there is anything to update",
    "check if the name is empty",
    "update name of the category",
    "check if the name to update exits already in db",
    "@ToDo: Is it necessary to allow equal category names among different creators?",
    "it is only triggered when the name already exists and the creator is the same",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client",
    "import pycocotools.mask as mask",
    "iterate though all categoires and upsert",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "is_crowd = annotation.get('iscrowed', False)",
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "logger.debug(f\"Emitting {percent} progress update for task {self.id}\")",
    "-- Contants",
    "Set maximum thumbnail size (h x w) to use on dataset page",
    "-- Private",
    "-- Database",
    "Absolute path to image file",
    "True if the image is annotated",
    "Poeple currently annotation the image",
    "Get dataset name from path",
    "logger.debug(f'Generating thumbnail for {self.id}')",
    "Resize image to fit in MAX_THUMBNAIL_DIM envelope as necessary",
    "Save as a jpeg to improve loading time",
    "(note file extension will not match but allows for backwards compatibility)",
    "TODO: Fix why using the functions throws an error",
    "meta = {'allow_inheritance': True}",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed"
  ],
  "v0.10.6": [
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "## File Watcher",
    "Flask/Gunicorn",
    "",
    "LOG_LEVEL - The granularity of log output",
    "",
    "A string of \"debug\", \"info\", \"warning\", \"error\", \"critical\"",
    "",
    "WORKER_CONNECTIONS - limits the maximum number of simultaneous",
    "clients that a single process can handle.",
    "",
    "A positive integer generally set to around 1000.",
    "",
    "WORKER_TIMEOUT - If a worker does not notify the master process",
    "in this number of seconds it is killed and a new worker is",
    "spawned to replace it.",
    "",
    "## Workers",
    "## Dataset Options",
    "## User Options",
    "## Models",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "check if its a hidden file",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "padding = args.get('padding')",
    "threshold = args.get('threshold')",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Remove parsed arguments",
    "Generate query from remaining arugments",
    "for image in images:",
    "image_json = query_util.fix_ids(image)",
    "query = AnnotationModel.objects(image_id=image.id, deleted=False)",
    "category_ids = query.distinct('category_id')",
    "categories = CategoryModel.objects(id__in=category_ids).only('name', 'color')",
    "image_json['annotations'] = query.count()",
    "image_json['categories'] = query_util.fix_ids(categories)",
    "images_json.append(image_json)",
    "check if the id exits",
    "check if the name to update is the same as already stored",
    "check if the name is empty",
    "update name of the category",
    "check if the name to update exits already in db",
    "@ToDo: Is it necessary to allow equal category names among different creators?",
    "it is only triggered when the name already exists and the creator is the same",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client",
    "import pycocotools.mask as mask",
    "iterate though all categoires and upsert",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "is_crowd = annotation.get('iscrowed', False)",
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "logger.debug(f\"Emitting {percent} progress update for task {self.id}\")",
    "-- Contants",
    "-- Private",
    "-- Database",
    "Absolute path to image file",
    "True if the image is annotated",
    "Poeple currently annotation the image",
    "Get dataset name from path",
    "logger.debug(f'Generating thumbnail for {self.id}')",
    "TODO: Fix why using the functions throws an error",
    "meta = {'allow_inheritance': True}",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed"
  ],
  "v0.10.5": [
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "## File Watcher",
    "Flask/Gunicorn",
    "",
    "LOG_LEVEL - The granularity of log output",
    "",
    "A string of \"debug\", \"info\", \"warning\", \"error\", \"critical\"",
    "",
    "WORKER_CONNECTIONS - limits the maximum number of simultaneous",
    "clients that a single process can handle.",
    "",
    "A positive integer generally set to around 1000.",
    "",
    "WORKER_TIMEOUT - If a worker does not notify the master process",
    "in this number of seconds it is killed and a new worker is",
    "spawned to replace it.",
    "",
    "## Workers",
    "## Dataset Options",
    "## User Options",
    "## Models",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "check if its a hidden file",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "padding = args.get('padding')",
    "threshold = args.get('threshold')",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Remove parsed arguments",
    "Generate query from remaining arugments",
    "for image in images:",
    "image_json = query_util.fix_ids(image)",
    "query = AnnotationModel.objects(image_id=image.id, deleted=False)",
    "category_ids = query.distinct('category_id')",
    "categories = CategoryModel.objects(id__in=category_ids).only('name', 'color')",
    "image_json['annotations'] = query.count()",
    "image_json['categories'] = query_util.fix_ids(categories)",
    "images_json.append(image_json)",
    "check if the id exits",
    "check if the name to update is the same as already stored",
    "check if the name is empty",
    "update name of the category",
    "check if the name to update exits already in db",
    "@ToDo: Is it necessary to allow equal category names among different creators?",
    "it is only triggered when the name already exists and the creator is the same",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client",
    "import pycocotools.mask as mask",
    "iterate though all categoires and upsert",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "is_crowd = annotation.get('iscrowed', False)",
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "logger.debug(f\"Emitting {percent} progress update for task {self.id}\")",
    "-- Contants",
    "-- Private",
    "-- Database",
    "Absolute path to image file",
    "True if the image is annotated",
    "Poeple currently annotation the image",
    "Get dataset name from path",
    "logger.debug(f'Generating thumbnail for {self.id}')",
    "TODO: Fix why using the functions throws an error",
    "meta = {'allow_inheritance': True}",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed"
  ],
  "v0.10.4": [
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "## File Watcher",
    "Flask/Gunicorn",
    "",
    "LOG_LEVEL - The granularity of log output",
    "",
    "A string of \"debug\", \"info\", \"warning\", \"error\", \"critical\"",
    "",
    "WORKER_CONNECTIONS - limits the maximum number of simultaneous",
    "clients that a single process can handle.",
    "",
    "A positive integer generally set to around 1000.",
    "",
    "WORKER_TIMEOUT - If a worker does not notify the master process",
    "in this number of seconds it is killed and a new worker is",
    "spawned to replace it.",
    "",
    "## Workers",
    "## Dataset Options",
    "## User Options",
    "## Models",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "check if its a hidden file",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "padding = args.get('padding')",
    "threshold = args.get('threshold')",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "check if the id exits",
    "check if the name to update is the same as already stored",
    "check if the name is empty",
    "update name of the category",
    "check if the name to update exits already in db",
    "@ToDo: Is it necessary to allow equal category names among different creators?",
    "it is only triggered when the name already exists and the creator is the same",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client",
    "import pycocotools.mask as mask",
    "iterate though all categoires and upsert",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "is_crowd = annotation.get('iscrowed', False)",
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "logger.debug(f\"Emitting {percent} progress update for task {self.id}\")",
    "-- Contants",
    "-- Private",
    "-- Database",
    "Absolute path to image file",
    "True if the image is annotated",
    "Poeple currently annotation the image",
    "Get dataset name from path",
    "logger.debug(f'Generating thumbnail for {self.id}')",
    "TODO: Fix why using the functions throws an error",
    "changing permission of folder to upload images with out sudo permissions (anyone can upload images)",
    "meta = {'allow_inheritance': True}",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed"
  ],
  "v0.10.3": [
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "## File Watcher",
    "Flask/Gunicorn",
    "",
    "LOG_LEVEL - The granularity of log output",
    "",
    "A string of \"debug\", \"info\", \"warning\", \"error\", \"critical\"",
    "",
    "WORKER_CONNECTIONS - limits the maximum number of simultaneous",
    "clients that a single process can handle.",
    "",
    "A positive integer generally set to around 1000.",
    "",
    "WORKER_TIMEOUT - If a worker does not notify the master process",
    "in this number of seconds it is killed and a new worker is",
    "spawned to replace it.",
    "",
    "## Workers",
    "## Dataset Options",
    "## User Options",
    "## Models",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "check if its a hidden file",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "padding = args.get('padding')",
    "threshold = args.get('threshold')",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "check if the id exits",
    "check if the name to update is the same as already stored",
    "check if the name is empty",
    "update name of the category",
    "check if the name to update exits already in db",
    "@ToDo: Is it necessary to allow equal category names among different creators?",
    "it is only triggered when the name already exists and the creator is the same",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client",
    "import pycocotools.mask as mask",
    "iterate though all categoires and upsert",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "is_crowd = annotation.get('iscrowed', False)",
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "logger.debug(f\"Emitting {percent} progress update for task {self.id}\")",
    "-- Contants",
    "-- Private",
    "-- Database",
    "Absolute path to image file",
    "True if the image is annotated",
    "Poeple currently annotation the image",
    "Get dataset name from path",
    "logger.debug(f'Generating thumbnail for {self.id}')",
    "TODO: Fix why using the functions throws an error",
    "meta = {'allow_inheritance': True}",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed"
  ],
  "v0.10.2": [
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "## File Watcher",
    "Flask/Gunicorn",
    "",
    "LOG_LEVEL - The granularity of log output",
    "",
    "A string of \"debug\", \"info\", \"warning\", \"error\", \"critical\"",
    "",
    "WORKER_CONNECTIONS - limits the maximum number of simultaneous",
    "clients that a single process can handle.",
    "",
    "A positive integer generally set to around 1000.",
    "",
    "WORKER_TIMEOUT - If a worker does not notify the master process",
    "in this number of seconds it is killed and a new worker is",
    "spawned to replace it.",
    "",
    "## Workers",
    "## Dataset Options",
    "## User Options",
    "## Models",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "check if its a hidden file",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "padding = args.get('padding')",
    "threshold = args.get('threshold')",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "check if the id exits",
    "check if the name to update is the same as already stored",
    "check if the name is empty",
    "update name of the category",
    "check if the name to update exits already in db",
    "@ToDo: Is it necessary to allow equal category names among different creators?",
    "it is only triggered when the name already exists and the creator is the same",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client",
    "import pycocotools.mask as mask",
    "iterate though all categoires and upsert",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "is_crowd = annotation.get('iscrowed', False)",
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "logger.debug(f\"Emitting {percent} progress update for task {self.id}\")",
    "-- Contants",
    "-- Private",
    "-- Database",
    "Absolute path to image file",
    "True if the image is annotated",
    "Poeple currently annotation the image",
    "Get dataset name from path",
    "logger.debug(f'Generating thumbnail for {self.id}')",
    "TODO: Fix why using the functions throws an error",
    "meta = {'allow_inheritance': True}",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed"
  ],
  "v0.10.1": [
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "## File Watcher",
    "Flask/Gunicorn",
    "",
    "LOG_LEVEL - The granularity of log output",
    "",
    "A string of \"debug\", \"info\", \"warning\", \"error\", \"critical\"",
    "",
    "WORKER_CONNECTIONS - limits the maximum number of simultaneous",
    "clients that a single process can handle.",
    "",
    "A positive integer generally set to around 1000.",
    "",
    "WORKER_TIMEOUT - If a worker does not notify the master process",
    "in this number of seconds it is killed and a new worker is",
    "spawned to replace it.",
    "",
    "## Workers",
    "## Dataset Options",
    "## User Options",
    "## Models",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "check if its a hidden file",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "padding = args.get('padding')",
    "threshold = args.get('threshold')",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "check if the id exits",
    "check if the name to update is the same as already stored",
    "check if the name is empty",
    "update name of the category",
    "check if the name to update exits already in db",
    "@ToDo: Is it necessary to allow equal category names among different creators?",
    "it is only triggered when the name already exists and the creator is the same",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client",
    "import pycocotools.mask as mask",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "is_crowd = annotation.get('iscrowed', False)",
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "logger.debug(f\"Emitting {percent} progress update for task {self.id}\")",
    "-- Contants",
    "-- Private",
    "-- Database",
    "Absolute path to image file",
    "True if the image is annotated",
    "Poeple currently annotation the image",
    "Get dataset name from path",
    "logger.debug(f'Generating thumbnail for {self.id}')",
    "TODO: Fix why using the functions throws an error",
    "meta = {'allow_inheritance': True}",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed"
  ],
  "v0.10.0": [
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "## File Watcher",
    "Flask/Gunicorn",
    "",
    "LOG_LEVEL - The granularity of log output",
    "",
    "A string of \"debug\", \"info\", \"warning\", \"error\", \"critical\"",
    "",
    "WORKER_CONNECTIONS - limits the maximum number of simultaneous",
    "clients that a single process can handle.",
    "",
    "A positive integer generally set to around 1000.",
    "",
    "WORKER_TIMEOUT - If a worker does not notify the master process",
    "in this number of seconds it is killed and a new worker is",
    "spawned to replace it.",
    "",
    "## Workers",
    "## Dataset Options",
    "## User Options",
    "## Models",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "check if its a hidden file",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "check if the id exits",
    "check if the name to update is the same as already stored",
    "check if the name is empty",
    "update name of the category",
    "check if the name to update exits already in db",
    "@ToDo: Is it necessary to allow equal category names among different creators?",
    "it is only triggered when the name already exists and the creator is the same",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client",
    "import pycocotools.mask as mask",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "logger.debug(f\"Emitting {percent} progress update for task {self.id}\")",
    "-- Contants",
    "-- Private",
    "-- Database",
    "Absolute path to image file",
    "True if the image is annotated",
    "Poeple currently annotation the image",
    "Get dataset name from path",
    "logger.debug(f'Generating thumbnail for {self.id}')",
    "TODO: Fix why using the functions throws an error",
    "def download_images(self, keywords, limit=100):",
    "task = TaskModel(",
    "name=\"Downloading {} images to {} with keywords {}\".format(limit, self.name, keywords),",
    "dataset_id=self.id,",
    "group=\"Downloading Images\"",
    ")",
    "def download_images(task, dataset, keywords, limit):",
    "def custom_print(string):",
    "__builtins__.print(\"%f -- %s\" % (time.time(), string))",
    "print = dprint",
    "task.log()",
    "for keyword in args['keywords']:",
    "response = gid.googleimagesdownload()",
    "response.download({",
    "\"keywords\": keyword,",
    "\"limit\": args['limit'],",
    "\"output_directory\": output_dir,",
    "\"no_numbering\": True,",
    "\"format\": \"jpg\",",
    "\"type\": \"photo\",",
    "\"print_urls\": False,",
    "\"print_paths\": False,",
    "\"print_size\": False",
    "})",
    "return task",
    "meta = {'allow_inheritance': True}",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed"
  ],
  "v0.9.0": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "File Watcher",
    "Flask instance",
    "Dataset Options",
    "User Options",
    "Models",
    "-- Contants",
    "-- Private",
    "-- Database",
    "Absolute path to image file",
    "True if the image is annotated",
    "Poeple currently annotation the image",
    "Users who have annotated this image",
    "Amount of time spent in the annotator viewing this image",
    "Get dataset name from path",
    "TODO: Fix why using the functions throws an error",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "check if its a hidden file",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "check if the id exits",
    "check if the name to update is the same as already stored",
    "check if the name is empty",
    "update name of the category",
    "check if the name to update exits already in db",
    "@ToDo: Is it necessary to allow equal category names among different creators?",
    "it is only triggered when the name already exists and the creator is the same",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.8.0": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "File Watcher",
    "Flask instance",
    "Dataset Options",
    "User Options",
    "Models",
    "Get dataset name from path",
    "TODO: Fix why using the functions throws an error",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "Check if thumbnails directory",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.7.2": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "File Watcher",
    "Flask instance",
    "Dataset Options",
    "Coco Importer Options",
    "User Options",
    "Get dataset name from path",
    "TODO: Fix why using the functions throws an error",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "Check if thumbnails directory",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "Create any missing categories",
    "Add any new categories to dataset",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "split annotations up into batches, import them in parallel",
    "update the category ids for the images",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "release resources",
    "Find all images",
    "is_crowd = annotation.get('iscrowed', False)",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.7.1": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "File Watcher",
    "Flask instance",
    "Dataset Options",
    "Coco Importer Options",
    "User Options",
    "Get dataset name from path",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "Check if thumbnails directory",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "Create any missing categories",
    "Add any new categories to dataset",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "split annotations up into batches, import them in parallel",
    "update the category ids for the images",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "release resources",
    "Find all images",
    "is_crowd = annotation.get('iscrowed', False)",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.7.0": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "TODO: Remove assoicated lines",
    "We need to move the line aswell",
    "If labels convert to indexs",
    "Draw line if points exist",
    "Order doesn't matter so can sort first",
    "Cantor pairing function",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "File Watcher",
    "Flask instance",
    "Dataset Options",
    "Coco Importer Options",
    "User Options",
    "Get dataset name from path",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "Check if thumbnails directory",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "Create any missing categories",
    "Add any new categories to dataset",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "split annotations up into batches, import them in parallel",
    "update the category ids for the images",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "release resources",
    "Find all images",
    "is_crowd = annotation.get('iscrowed', False)",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.6.3": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "File Watcher",
    "Flask instance",
    "Dataset Options",
    "Coco Importer Options",
    "User Options",
    "Get dataset name from path",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "Check if thumbnails directory",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "Create any missing categories",
    "Add any new categories to dataset",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "split annotations up into batches, import them in parallel",
    "update the category ids for the images",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "release resources",
    "Find all images",
    "is_crowd = annotation.get('iscrowed', False)",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.6.2": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "File Watcher",
    "Flask instance",
    "Dataset Options",
    "Coco Importer Options",
    "User Options",
    "Get dataset name from path",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "Check if thumbnails directory",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "Create any missing categories",
    "Add any new categories to dataset",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "split annotations up into batches, import them in parallel",
    "update the category ids for the images",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "release resources",
    "Find all images",
    "is_crowd = annotation.get('iscrowed', False)",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.6.1": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "File Watcher",
    "Flask instance",
    "Dataset Options",
    "Coco Importer Options",
    "User Options",
    "Get dataset name from path",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "Check if thumbnails directory",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "Create any missing categories",
    "Add any new categories to dataset",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "split annotations up into batches, import them in parallel",
    "update the category ids for the images",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "release resources",
    "Find all images",
    "is_crowd = annotation.get('iscrowed', False)",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "print(query, flush=True)",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.6.0": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "File Watcher",
    "Flask instance",
    "Dataset Options",
    "Coco Importer Options",
    "User Options",
    "Get dataset name from path",
    "Type of task: Importer, Exporter, Scanner, etc.",
    ": Start date of the executor",
    ": End date of the executor",
    "If any of the information is relevant to the task",
    "it should be added",
    "Send socket update every 10%",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Remove all poeple who were annotating when",
    "the server shutdown",
    "invalid image ID",
    "Remove user from pervious room",
    "Remove user from room",
    "Check if thumbnails directory",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "Create any missing categories",
    "Add any new categories to dataset",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "split annotations up into batches, import them in parallel",
    "update the category ids for the images",
    "split images up into batches, import them in parallel",
    "process all images before moving on to annotations",
    "release resources",
    "Find all images",
    "is_crowd = annotation.get('iscrowed', False)",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "category id mapping  ( file : database )",
    "Create any missing categories",
    "map category ids",
    "update progress",
    "image id mapping ( file: database )",
    "Find all images",
    "update progress",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.5.8": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "Flask instance",
    "Dataset Options",
    "User Options",
    "Check if thumbnails directory",
    "Get dataset name from path",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Cruve",
    "Point",
    "Make sure shape is not all outside the image",
    "len 4 means this is a line with no width; it contributes",
    "no area to the mask, and if we include it, coco will treat",
    "it instead as a bbox (and throw an error)",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create any missing categories",
    "Add any new categories to dataset",
    "Find all images",
    "Generate annotations",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.5.7": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "Flask instance",
    "Dataset Options",
    "User Options",
    "Check if thumbnails directory",
    "Get dataset name from path",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Make sure shape is not all outside the image",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create any missing categories",
    "Add any new categories to dataset",
    "Find all images",
    "Generate annotations",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.5.6": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "Flask instance",
    "Dataset Options",
    "User Options",
    "Check if thumbnails directory",
    "Get dataset name from path",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Make sure shape is not all outside the image",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create any missing categories",
    "Add any new categories to dataset",
    "Find all images",
    "Generate annotations",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.5.5": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "Flask instance",
    "Dataset Options",
    "User Options",
    "Check if thumbnails directory",
    "Get dataset name from path",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Make sure shape is not all outside the image",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create any missing categories",
    "Add any new categories to dataset",
    "Find all images",
    "Generate annotations",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.5.4": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "Flask instance",
    "Dataset Options",
    "User Options",
    "Check if thumbnails directory",
    "Get dataset name from path",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Make sure shape is not all outside the image",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create any missing categories",
    "Add any new categories to dataset",
    "Find all images",
    "Generate annotations",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.5.3": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "Flask instance",
    "Dataset Options",
    "User Options",
    "Check if thumbnails directory",
    "Get dataset name from path",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Make sure shape is not all outside the image",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create any missing categories",
    "Add any new categories to dataset",
    "Find all images",
    "Generate annotations",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.5.2": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "Flask instance",
    "Dataset Options",
    "User Options",
    "Check if thumbnails directory",
    "Get dataset name from path",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Make sure shape is not all outside the image",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create any missing categories",
    "Add any new categories to dataset",
    "Find all images",
    "Generate annotations",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.5.1": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "Flask instance",
    "Dataset Options",
    "User Options",
    "Check if thumbnails directory",
    "Get dataset name from path",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Make sure shape is not all outside the image",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create any missing categories",
    "Add any new categories to dataset",
    "Find all images",
    "Generate annotations",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ],
  "v0.5.0": [
    "Category 1 Test",
    "Category 2 Test",
    "Category 3 Test",
    "TODO write tests for data",
    "import Home from \"@/views/Home\";",
    "mode: \"history\",",
    "convert 3-digit hex to 6-digits.",
    "invert color components",
    "pad each with zeros and return",
    "e: { test: true, data: \"info\" }",
    "Magic Wand (Fuzzy Selection Tool) for Javascript",
    "",
    "The MIT License (MIT)",
    "",
    "Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)",
    "",
    "Permission is hereby granted, free of charge, to any person obtaining a copy",
    "of this software and associated documentation files (the \"Software\"), to deal",
    "in the Software without restriction, including without limitation the rights",
    "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
    "copies of the Software, and to permit persons to whom the Software is",
    "furnished to do so, subject to the following conditions:",
    "",
    "The above copyright notice and this permission notice shall be included in",
    "all copies or substantial portions of the Software.",
    "",
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
    "THE SOFTWARE.",
    "compare the color of the sample",
    "walk to left side starting with the left neighbor",
    "compare the color of the sample",
    "walk to right side starting with the right neighbor",
    "compare the color of the sample",
    "check minmax for X",
    "add two scanning lines in the opposite direction (y - dir) if necessary",
    "add the scanning line in the direction (y + dir) if necessary",
    "check minmax for Y if necessary",
    "calc gauss weights",
    "normalization weights",
    "walk through all source points for blur",
    "walk through x-neighbors",
    "walk through y-neighbors",
    "copy visited points (only \"black\")",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (visitedData[k + 1] + visitedData[k - 1] +",
    "visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +",
    "visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through radius-neighbors of border points and add them to the result array",
    "walk through x-neighbors",
    "check the uniqueness",
    "walk through y-neighbors",
    "check the uniqueness",
    "calc gauss weights",
    "normalization weights",
    "walk through all border points for blur",
    "walk through x-neighbors",
    "check minmax",
    "walk through y-neighbors",
    "check minmax",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values except points on the boundary of the image",
    "check if any neighbor with a \"white\" color",
    "if (data[k + 1] + data[k - 1] +",
    "data[k1] + data[k1 + 1] + data[k1 - 1] +",
    "data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;",
    "walk through points on the boundary of the image if necessary",
    "if the \"black\" point is adjacent to the boundary of the image, it is a border point",
    "walk through inner values and copy only \"black\" points to the result mask",
    "all [dx,dy] pairs (array index is the direction)",
    "5 6 7",
    "4 X 0",
    "3 2 1",
    "k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)",
    "need contour tracing",
    "bypass all the neighbors around the current point in a clockwise",
    "get the next point by new direction",
    "black boundary pixel",
    "walk through all contours",
    "contour isn't simplified",
    "no intermediate points",
    "calc the distance from current point to edge",
    "if the max \"deviation\" is larger than allowed then...",
    "from flask import Blueprint, render_template",
    "client = Blueprint('client', __name__, static_folder='client')",
    "client = Blueprint('client', __name__, static_folder=\"../dist\", template_folder=\"../dist\")",
    "@client.route('/')",
    "def index():",
    "return render_template('index.html')",
    "@client.route('/images/<int:dataset_id>')",
    "@client.route('/datasets/<int:dataset_id>')",
    "def index(dataset_id):",
    "return render_template('images.html')",
    "",
    "",
    "@client.route('/annotate/<int:image_id>')",
    "@client.route('/editor/<int:image_id>')",
    "def annotate(image_id):",
    "return render_template('annotator.html')",
    "",
    "",
    "@client.route('/datasets/')",
    "def datasets():",
    "return render_template('datasets.html')",
    "",
    "",
    "@client.route('/categories/')",
    "def categories():",
    "return render_template('categories.html')",
    "",
    "",
    "@client.route('/undo/')",
    "def undo():",
    "return render_template('undo.html')",
    "Flask instance",
    "Dataset Options",
    "User Options",
    "Check if thumbnails directory",
    "Get dataset name from path",
    "https://github.com/MongoEngine/mongoengine/issues/1171",
    "Use this methods until a solution is found",
    "map category names to ids; create as needed",
    "Compute segmentation",
    "paperjs points are relative to the center, so we must shift them relative to the top left.",
    "Make sure shape is not all outside the image",
    "Convert into rle",
    "@api.route('/<int:annotation_id>/mask')",
    "class AnnotationMask(Resource):",
    "def get(self, annotation_id):",
    "\"\"\" Returns the binary mask of an annotation \"\"\"",
    "return query_util.fix_ids(AnnotationModel.objects(id=annotation_id).first())",
    "Check if dataset exists",
    "Make sure folder starts with is in proper format",
    "Get directory",
    "Create any missing categories",
    "Add any new categories to dataset",
    "Find all images",
    "Generate annotations",
    "Check if annotation already exists",
    "Create annotation",
    "annotation.iscrowd = is_crowd",
    "Create /api/ space",
    "Remove default namespace",
    "Setup API namespaces",
    "Check if current user can access dataset",
    "Iterate every category passed in the data",
    "Find corresponding category object in the database",
    "Iterate every annotation from the data annotations",
    "Find corresponding annotation object in database",
    "Paperjs objects are complex, so they will not always be passed. Therefor we update",
    "the annotation twice, checking if the paperjs exists.",
    "Update annotation in database",
    "Update paperjs if it exists",
    "Generate coco formatted segmentation data",
    "Get next and previous image",
    "Generate data about the image to return to client"
  ]
}