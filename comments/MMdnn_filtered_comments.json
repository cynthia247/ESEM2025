{
  "0.3.1": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "Communication to TensorFlow server via gRPC",
    "TensorFlow serving stuff to send messages",
    "Command line arguments",
    "Send request",
    "request.inputs['input'].CopyFrom()",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.tensorflow_emit",
    "TestModels.caffe_emit,",
    "TestModels.coreml_emit,",
    "TestModels.keras_emit,",
    "TestModels.mxnet_emit,",
    "Run too slow on Travis.",
    "cntk_emit OOM on Travis",
    "TestModels.cntk_emit,",
    "TestModels.cntk_emit,",
    "Cannot run on Travis since it seems to consume too much memory.",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.keras_emit,",
    "TestModels.keras_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.keras_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.tensorflow_emit",
    "omit tensorflow lead to crash",
    "TestModels.cntk_emit,",
    "TestModels.cntk_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.keras_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.tensorflow_emit",
    "TestModels.cntk_emit,",
    "Function self.assertEquals has deprecated, change to assertEqual",
    "self.assertEqual(original_predict.shape, converted_predict.shape)",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "get original model prediction result",
    "original to IR",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "print(original_predict)",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "get shape",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "IR to code",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "The list is in RGB oder",
    "IR to Model",
    "converted_file = original_framework + '_coreml_' + architecture_name + \"_converted\"",
    "converted_file = converted_file.replace('.', '_')",
    "load model",
    "save model",
    "coremltools.utils.save_spec(model.get_spec(), converted_file)",
    "inference",
    "IR to code",
    "import converted model",
    "In case of odd number add the extra padding at the end for SAME_UPPER(eg. pads:[0, 2, 2, 0, 0, 3, 3, 0]) and at the beginning for SAME_LOWER(eg. pads:[0, 3, 3, 0, 0, 2, 2, 0])",
    "'xception'     : [onnx_emit],",
    "'nasnet'       : [onnx_emit],",
    "Temporarily disable 'yolo2'        : [onnx_emit],",
    "Temporarily disable 'inception_v4'  : [onnx_emit],",
    "'voc-fcn8s'     : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn16s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn32s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "Temporarily disable 'xception'      : [onnx_emit],",
    "Temporarily disable 'facenet'               : [onnx_emit],",
    "'resnet_v1_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v1_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'nasnet-a_large'        : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "Temporarily disable 'facenet'           : [onnx_emit],",
    "TODO: coredump",
    "'alexnet'       : [cntk_emit, keras_emit, tensorflow_emit],",
    "'nasnet'       : [tensorflow_emit, keras_emit, coreml_emit],",
    "Temporarily disable 'yolo2'        : [keras_emit],",
    "'facenet'      : [tensorflow_emit, coreml_emit,mxnet_emit,keras_emit]  # TODO",
    "Temporarily disable 'inception_v4'  : [cntk_emit, coreml_emit, keras_emit, pytorch_emit, tensorflow_emit], # TODO mxnet_emit(Small error), caffe_emit(Crash for shape)",
    "Temporarily disable 'xception'      : [coreml_emit, cntk_emit, mxnet_emit, pytorch_emit, tensorflow_emit], #  TODO: Caffe(Crash) keras_emit(too slow)",
    "Temporarily disable 'facenet'               : [mxnet_emit, tensorflow_emit, keras_emit, pytorch_emit, caffe_emit], # TODO: coreml_emit",
    "Temporarily disable 'rnn_lstm_gru_stacked'  : [tensorflow_emit, keras_emit, pytorch_emit, mxnet_emit] #TODO cntk_emit",
    "Temporarily disable 'facenet'           : [mxnet_emit, tensorflow_emit, keras_emit, caffe_emit] # TODO: coreml_emit",
    "'tinyyolo'     : [coreml_emit, keras_emit, mxnet_emit, pytorch_emit, tensorflow_emit],",
    "'vgg16': [tensorflow_emit],",
    "'alexnet': [tensorflow_emit]",
    "get test input path",
    "get original model prediction result",
    "def test_caffe(self):",
    "try:",
    "import caffe",
    "self._test_function('caffe', self.caffe_parse)",
    "except ImportError:",
    "print('Please install caffe! Or caffe is not supported in your platform.', file=sys.stderr)",
    "def test_cntk(self):",
    "try:",
    "import cntk",
    "self._test_function('cntk', self.cntk_parse)",
    "except ImportError:",
    "print('Please install cntk! Or cntk is not supported in your platform.', file=sys.stderr)",
    "def test_coreml(self):",
    "from coremltools.models.utils import macos_version",
    "if macos_version() < (10, 13):",
    "print('Coreml is not supported in your platform.', file=sys.stderr)",
    "else:",
    "self._test_function('coreml', self.coreml_parse)",
    "def test_keras(self):",
    "self._test_function('keras', self.keras_parse)",
    "def test_mxnet(self):",
    "self._test_function('mxnet', self.mxnet_parse)",
    "def test_darknet(self):",
    "self._test_function('darknet', self.darknet_parse)",
    "def test_paddle(self):",
    "# omit tensorflow lead to crash",
    "import tensorflow as tf",
    "try:",
    "import paddle.v2 as paddle",
    "self._test_function('paddle', self.paddle_parse)",
    "except ImportError:",
    "print('Please install Paddlepaddle! Or Paddlepaddle is not supported in your platform.', file=sys.stderr)",
    "def test_pytorch(self):",
    "self._test_function('pytorch', self.pytorch_parse)",
    "def test_tensorflow(self):",
    "self._test_function('tensorflow', self.tensorflow_parse)",
    "def test_tensorflow_frozen(self):",
    "self._test_function('tensorflow_frozen', self.tensorflow_frozen_parse)",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "Temporarily disable 'xception'      : [TestModels.coreml_emit, TestModels.cntk_emit, TestModels.tensorflow_emit],",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "Cannot run on Travis since it seems to consume too much memory.",
    "Temporarily disable 'xception'      : [TestModels.mxnet_emit, TestModels.pytorch_emit],",
    "Temporarily disable 'inception_v4'  : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.keras_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.tensorflow_emit",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.tensorflow_emit",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "!/usr/bin/python",
    "major python major_python_versions as python2 and python3",
    "operating system",
    "do not deal",
    "I don't want to deal with auto_pad",
    "Don't support auto_pad current!",
    "2018-02-28",
    "if group is None:",
    "group = 1",
    "group is not support yet too.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "node",
    "input",
    "edge(node a <-> node b)",
    "",
    "key is edge name, value is src/dst node name",
    "key is initializer name, value is TensorProto",
    "print(name)",
    "print(layer.op_type)",
    "n is input data",
    "n is input edge",
    "omit node of some type",
    "self.nodes.append(IR_node.variable_name + '_bias')",
    "self.nodes.append(IR_node.variable_name + '_weight')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "if node len(in_edges), generate additional DataInput node",
    "print",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "TODO",
    "'max_pool2d': convert_maxpool,",
    "'onnx::Mul': convert_elementwise_mul,",
    "'onnx::Sub': convert_elementwise_sub,",
    "'onnx::ConvTranspose': convert_convtranspose,",
    "'onnx::LeakyRelu': convert_lrelu,",
    "'onnx::Sigmoid': convert_sigmoid,",
    "'onnx::Softmax': convert_softmax,",
    "'onnx::Selu': convert_selu,",
    "'onnx::Transpose': convert_transpose,",
    "'onnx::Reshape': convert_reshape,",
    "'onnx::MatMul': convert_matmul,",
    "'onnx::Gather': convert_gather,",
    "'onnx::ReduceSum': convert_reduce_sum,",
    "'onnx::Constant': convert_constant,",
    "'onnx::Upsample': convert_upsample,",
    "'onnx::Pad': convert_padding,",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "test",
    "cpu: https://github.com/pytorch/pytorch/issues/5286",
    "Build network graph",
    "(batch, C, H, W)  & NHWC",
    "#########",
    "Layers #",
    "#########",
    "dilation",
    "handle bias",
    "TODO",
    "output_shape",
    "epsilon",
    "mean",
    "var",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "use_bias",
    "units",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Scopes created in a nested scope may have initial characters",
    "that are illegal as the initial character of an op name",
    "(viz. '-', '\\', '/', and '_').",
    "sanity check.",
    "run dce first to eliminate dead parts of the graph that might have been",
    "left behind by things like symbolic_override",
    "construct graph",
    "build each layer",
    "make connection",
    "nodes",
    "connect name and id in nodes with weights",
    "print(node.__str__())",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "padding,",
    "exstr = \", value=float('-Inf')\"",
    "exstr = \"\"",
    "Change to padding defuse",
    "input_node = self._defuse_padding(IR_node, exstr)",
    "Change to padding defuse",
    "Ignore it in Pytorch",
    "for Keras",
    "self.add_init(2, \"self.{:<15} = torch.from_numpy(_weights_dict['{}']['value'])\".format(",
    "IR_node.variable_name,",
    "IR_node.name))",
    "param_code does not need parameter slice.",
    "from torch.nn.parameter import Parameter",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._type = layer.__class__.__name__.replace('Backward', '')",
    "self._name = \"{}_{}\".format(self.type, id)",
    "TODO",
    "\"\"\"",
    "build graph for pytorch 0.2.0",
    "\"\"\"",
    "dummy_input = torch.autograd.Variable(torch.randn(shape))",
    "output_node = self.model(dummy_input)",
    "search_queue = [output_node.grad_fn]",
    "tmp_node = PyTorchGraphNode(output_node.grad_fn, 0)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "visited = {output_node.grad_fn : self.layer_map[tmp_node.name]}",
    "idx = 0",
    "node_count = 1",
    "while (idx < len(search_queue)):",
    "current_node = search_queue[idx]",
    "current_type = visited[current_node].type",
    "if hasattr(current_node, 'next_functions'):",
    "for parent, _ in current_node.next_functions:",
    "parent_type = parent.__class__.__name__.replace('Backward', '')",
    "if parent_type != 'AccumulateGrad' and \\",
    "(parent_type != 'Transpose' or current_type != 'Addmm'):",
    "if not parent in visited:",
    "tmp_node = PyTorchGraphNode(parent, node_count)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "node_count += 1",
    "visited[parent] = tmp_node",
    "search_queue.append(parent)",
    "self._make_connection(visited[parent].name, visited[current_node].name)",
    "idx += 1",
    "try:",
    "return TorchGraph._forward_torch_random_input(",
    "torch_model,",
    "input_shapes,",
    "is_batch=False",
    ")",
    "except:",
    "# try batch mode",
    "# return TorchGraph._forward_torch_random_input(",
    "#     torch_model,",
    "#     input_shapes,",
    "#     is_batch=True",
    "# )",
    "pass",
    "tensor = torch.rand(*shape).float()",
    "multi output",
    "single output",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "Build network graph",
    "#########",
    "Layers #",
    "#########",
    "handle weight",
    "handle bias",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "load model file into Coreml Graph",
    "model.encode() convert to str --- python2 may crash due to type 'unicode'",
    "Build Network Graph",
    "self.data_format ? TODO",
    "load the model network",
    "convert to Model_pb2.Model",
    "determine the type of the current_node",
    "staticmethods",
    "(seq, batch, C, H, W)  & NHWC",
    "TODO dtype_map",
    "##### convert methods",
    "convolution",
    "input edge",
    "important!",
    "reshape the weight!",
    "[2, 3, 0, 1]",
    "pads",
    "use_bias",
    "isDeconvolution",
    "name, op",
    "kwargs['kernel_shape'] = weights.shape",
    "strides",
    "[1, sd, sh, sw, 1]",
    "activation",
    "TODO",
    "padding in conv",
    "pad in IR is [x1_b, x2_b, ..., x1_e, x2_e, ...]",
    "padding",
    "compute padding for 'same'",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "https://www.jianshu.com/p/05c4f1621c7e",
    "padding in pooling",
    "padding",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "TODO",
    "symmetric padding",
    "name, op",
    "input edge",
    "For concat axis",
    "NO axis in coreml, so set the last axis",
    "The first -1 means in coreml there is one-more axis,",
    "The second -1 means the last axis",
    "name, op",
    "input edge",
    "padding",
    "Future Module TODO",
    "#### rename methods",
    "name, op",
    "activation type",
    "else:",
    "assert False",
    "input edge",
    "Merge layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "NHWC channel last",
    "in fact, here is NWHC",
    "name, op",
    "input edge",
    "axis TODO",
    "channels_first, then axis = 1",
    "scale",
    "bias",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "mean",
    "var",
    "name, op",
    "input edge",
    "bias",
    "name, op",
    "input edge",
    "MAX = 0, AVERAGE = 1, L2 = 2",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "change to single because of the tf matmul",
    "in features",
    "name, op",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "the end of the tensorflow_resnet_v2_50's squeeze shape is [unknown_rank: true] with len 0",
    "1001 means the 1001 classes for tensorflow_resnet_v2_50",
    "!Alert! TODO",
    "Future implement can be changed to the last two layer",
    "TODO - remove style transfer 1D hack",
    "Input is 1D but it goes to the width dimension: (1,1,W)",
    "assume (Batch, Channels) - Batch dimension should be dropped",
    "assume (Batch, Sequence-Length, channels)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Add classifier classes (if applicable)",
    "Set pre-processing paramsters",
    "image_input_names,",
    "Return the protobuf spec",
    "model = _MLModel(self.builder.spec)",
    "if IR_node.name in self.weights_dict and 'weights' in self.weights_dict[IR_node.name]:",
    "pass",
    "self._emit_merge(IR_node,'DOT')",
    "Get input and output names",
    "Dimensions and weights",
    "W should have shape (height, width, kernel_channels, output_channels), where kernel_channel = input_channels / groups",
    "Dilations",
    "see protobuf",
    "assert False",
    "Get the weights.",
    "Dilations",
    "see protobuf",
    "depth-wise convolution",
    "Dilations",
    "see protobuf",
    "Get input and output names",
    "Pooling layer type",
    "if it's global, set the global flag",
    "TODO  global pooling modification",
    "Padding",
    "see protobuf",
    "Padding",
    "see protobuf",
    "Get input and output names",
    "type: \"list(int). A 1-D values of (leftBorder, topBorder, rightBorder, bottomBorder).\"",
    "This is central crop",
    "Now add the layer",
    "Allowed values: 'CHW', 'HW', 'C', 'H', 'W'",
    "Get input and output names",
    "Get input and output names",
    "Get the weights from keras",
    "Get input and output names",
    "blob_order == 0 if the input blob needs not be rearranged",
    "blob_order == 1 if the input blob needs to be rearranged",
    "using keras_layer.input.shape have a \"?\" (Dimension[None] at the front),",
    "making a 3D tensor with unknown batch size 4D",
    "Get input and output names",
    "activation emit",
    "Get input and output names",
    "negate it",
    "apply threshold",
    "negate it back",
    "for Keras",
    "Get input and output names",
    "Set parameters",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "padding type TODO",
    "Type of the padding. Can be one of 'constant', 'reflection' or 'replication",
    "Now add the layer",
    "self.emit_Flatten(IR_node)",
    "Get the weights",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "input layer",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "The information of the layer",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "print(node.parameters)",
    "assert False",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "if parent.output_shape.height > 1 or parent.output_shape.width > 1:",
    "TODO: The gamma parameter has to be set (in node.data?) and this should work.",
    "Also, mean should be set to 0, and var to 1, just to be safe.",
    "skip the split node",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For some reason argparser gives us unicode, so we need to conver to str first",
    "for test",
    "with open(\"graph.txt\", 'w') as f:",
    "for layer in self.IR_graph.topological_sort:",
    "current_node = self.IR_graph.get_node(layer)",
    "print(\"========current_node=========\\n{}\".format(current_node.layer), file=f)",
    "test end",
    "print(\"========current_node={}\".format(current_node.layer))",
    "check if have pad layer",
    "Pad_h < kernel_h (vgg19 caffe2caffe)",
    "implement asymmetric paddings by applying symmetric padding then cropping",
    "num_output = IR_node.get_attr('kernel_shape')[-2]",
    "keys = []",
    "for key in self.weights_dict[IR_node.name].keys():",
    "keys.append(key)",
    "print(\"=======Layer: {}, keys: {}\".format(IR_node.name, keys))",
    "if asymmetric padding, set offset to 1",
    "Change the layer name",
    "check if need crop output shape",
    "check if need crop output shape",
    "change the key \"name\" to \"variable_name\", in case of the layer name has invalid characters",
    "Convert NHWC (IR) to NCHW (Caffe): [0,1,2,3]->[0,3,1,2]",
    "def emit_Square(self, IR_node):",
    "input_layers = ', '.join(('n.' + self.IR_graph.get_node(edge).real_variable_name) for edge in IR_node.in_edges)",
    "self.add_body(1, \"n.{:<15} = L.Square({}, ntop=1)\".format(",
    "IR_node.variable_name,",
    "input_layers))",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "self.graph = NodeRenamer()(graph)",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "assert mapped_node is not None",
    "skip when mapped_node is None",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "Fall back to the protobuf implementation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from tensorflow.core.framework.node_def_pb2 import NodeDef",
    "from tensorflow.core.framework import attr_value_pb2",
    "pass",
    "print(\"\\n\")",
    "print(i)",
    "print(block)",
    "continue",
    "NHWC",
    "assert False",
    "print(shortcut_layer['input'] )",
    "spacetodepth",
    "print(block)",
    "print(region_layer)",
    "assert False",
    "print line",
    "set default value",
    "yolo3(608) start at 1, yolo2(608) start at 0. yolo2(416) start at 1, yolo3(416) start at 0",
    "load weight by original order",
    "print(node_type)",
    "print(IR_node)",
    "assert False",
    "strides",
    "assert False",
    "padding",
    "only load weight conv",
    "print(\"----------------\",self.start)",
    "print(kernel.shape)",
    "print(k_bias.shape)",
    "buf, start, scale_layer['name'], bn_layer['name'], conv_layer['name']",
    "print(\"==============\",self.start)",
    "print(bias.shape)",
    "print(scale.shape)",
    "print(mean.shape)",
    "print(var.shape)",
    "print(kernel.shape)",
    "print(W)",
    "assert False",
    "no use",
    "print(source_node.layer)",
    "for image classification(resnet) AVG pooling",
    "print(source_node.layer)",
    "print(source_node.layer)",
    "kwargs['ignore_thresh'] = source_node.get_attr('ignore_thresh')",
    "print(source_node.get_attr('anchors'))",
    "kwargs['anchors'] = ['0.52','0.22']",
    "kwargs['mask'] = source_node.get_attr('mask')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "tensorflow dump tag",
    "Reference: 1) Keras image preprocess: https://github.com/keras-team/keras/blob/master/keras/applications/imagenet_utils.py",
    "2) tensorflow github issue: https://github.com/tensorflow/models/issues/517",
    "R-G-B for Imagenet === [123.68, 116.78, 103.94]",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load a real image and do default tf imageNet preprocessing",
    "[Batch, Height, Width, Channels] --> [Batch, Channels, Height, Width]",
    "We only deal with non-recurrent networks for now",
    "(H,W,C) --> (C,H,W)",
    "Load TensorFlow model",
    "Prepare inputs",
    "Run TF session",
    "Evaluate coreml model",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "@unittest.skip(\"Failing GPU backend: related to https://github.com/tf-coreml/tf-coreml/issues/26\")",
    "? style transfer image size and style number?",
    "Test predictions on an image",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "compare_tf_coreml_outputs(tf_out_flatten, coreml_out_flatten)",
    "#Download model",
    "url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception_v3_2016_08_28_frozen.pb.tar.gz'",
    "tf_model_dir = _download_file(url = url)",
    "tf_model_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28_frozen.pb')",
    "#Convert to coreml",
    "mlmodel_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28.mlmodel')",
    "mlmodel = tf_converter.convert(",
    "tf_model_path = tf_model_path,",
    "mlmodel_path = mlmodel_path,",
    "output_feature_names = ['InceptionV3/Predictions/Softmax:0'],",
    "input_name_shape_dict = {'input:0':[1,299,299,3]},",
    "image_input_names = ['input:0'],",
    "red_bias = -1,",
    "green_bias = -1,",
    "blue_bias = -1,",
    "image_scale = 2.0/255.0)",
    "#Test predictions on an image",
    "_test_coreml_model_image_input(",
    "tf_model_path = tf_model_path,",
    "coreml_model = mlmodel,",
    "input_tensor_name = 'input:0',",
    "output_tensor_name = 'InceptionV3/Predictions/Softmax:0',",
    "img_size = 299)",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "self.test_truth()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from collections import namedtuple",
    "Batch = namedtuple('Batch', ['data'])",
    "TODO",
    "Apple has published some of their own models. They can be downloaded from https://developer.apple.com/machine-learning/.",
    "Those published models are: SqueezeNet, Places205-GoogLeNet, ResNet50, Inception v3, VGG16",
    "TODO",
    "load model",
    "TODO: Multiple inputs",
    "TODO: Multiple outputs",
    "inference",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "caffe uses NCHW",
    "self.print_intermediate_result('pooling0', False)",
    "delete tmp model files",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "net = caffe.Net(arch_fn, weight_fn, caffe.TEST)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "# Image Classification",
    "# Semantic Segmentation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "print(r)",
    "d = darknet_extractor()",
    "model_filename = d.download('yolov3')",
    "print(model_filename)",
    "image_path = \"./mmdnn/conversion/examples/data/dog.jpg\"",
    "model_path = \"./\"",
    "d = darknet_extractor()",
    "result = d.inference('yolov3', model_filename, model_path, image_path = image_path)",
    "print(result)",
    "print(i)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('pooling0', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "need to be updated",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "raise NotImplementedError()",
    "Load file",
    "Run TensorBoard",
    "print(cmd)",
    "Using cuDNN since vanilla RNN",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Notes for training NASNet Cifar Model",
    "-------------------------------------",
    "batch_size: 32",
    "learning rate: 0.025",
    "cosine (single period) learning rate decay",
    "auxiliary head loss weighting: 0.4",
    "clip global norm of all gradients by 5",
    "600 epochs with a batch size of 32",
    "This is used for the drop path probabilities since it needs to increase",
    "the drop out probability over the course of training.",
    "Notes for training large NASNet model on ImageNet",
    "-------------------------------------",
    "batch size (per replica): 16",
    "learning rate: 0.015 * 100",
    "learning rate decay factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 100 replicas",
    "auxiliary head loss weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Notes for training the mobile NASNet ImageNet model",
    "-------------------------------------",
    "batch size (per replica): 32",
    "learning rate: 0.04 * 50",
    "learning rate scaling factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 50 replicas",
    "auxiliary head weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Shape of feature map before the final layer.",
    "149 x 149 x 32",
    "Run the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Find where to place the reduction cells or stride normal cells",
    "Setup for building in the auxiliary head.",
    "Run the cells",
    "true_cell_num accounts for the stem cells",
    "Final softmax layer",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 192",
    "35 x 35 x 320",
    "TODO(alemi): Register intermediate endpoints",
    "17 x 17 x 1088 if output_stride == 8,",
    "33 x 33 x 1088 if output_stride == 16",
    "TODO(alemi): register intermediate endpoints",
    "TODO(gpapan): Properly support output_stride for the rest of the net.",
    "8 x 8 x 2080",
    "TODO(alemi): register intermediate endpoints",
    "8 x 8 x 1536",
    "TODO(sguada,arnoegw): Consider adding a parameter global_pool which",
    "can be set to False to disable pooling here (as in resnet_*()).",
    "Set weight_decay for weights in conv2d and fully_connected layers.",
    "Set activation_fn and parameters for batch_norm.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "=============================================================================",
    "Tensorflow mandates these.",
    "Conv and DepthSepConv namedtuple define layers of the MobileNet architecture",
    "Conv defines 3x3 convolution layers",
    "DepthSepConv defines 3x3 depthwise convolution followed by 1x1 convolution.",
    "stride is the stride of the convolution",
    "depth is the number of channels or filters in a layer",
    "_CONV_DEFS specifies the MobileNet body",
    "Used to find thinned depths for each layer.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "By passing filters=None",
    "separable_conv2d produces only a depthwise convolution layer",
    "Global average pooling.",
    "Pooling with a fixed kernel size.",
    "1 x 1 x 1024",
    "Set weight_decay for weights in Conv and DepthSepConv layers.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Skip path 1",
    "Skip path 2",
    "First pad with 0's on the right and bottom, then shift the filter to",
    "include those 0's that were added.",
    "Concat and apply BN",
    "Set the prev layer to the current layer if it is none",
    "Check to be sure prev layer stuff is setup correctly",
    "Apply conv operations",
    "Combine hidden states using 'add'.",
    "Add hiddenstate to the list of hiddenstates we can choose from",
    "Dont stride if this is not one of the original hiddenstates",
    "Check if a stride is needed, then use a strided 1x1 here",
    "Determine if a reduction should be applied to make the number of",
    "filters match.",
    "Return the concat of all the states",
    "Scale keep prob by layer number",
    "The added 2 is for the reduction cells",
    "Decrease the keep probability over time",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Inception-Resnet-A",
    "Inception-Resnet-B",
    "Inception-Resnet-C",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "force in-place updates of mean and variance estimates",
    "Moving averages ends up in the trainable variables collection",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 256",
    "5 x Inception-resnet-A",
    "Reduction-A",
    "10 x Inception-Resnet-B",
    "Reduction-B",
    "5 x Inception-Resnet-C",
    "pylint: disable=no-member",
    "net = slim.fully_connected(net, bottleneck_layer_size, activation_fn=None,",
    "scope='Bottleneck', reuse=False)",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Note: want to round down, we adjust each split to match the total.",
    "We use scope_depthwise, scope_pointwise for compatibility with V1 ckpts.",
    "which provide numbered scopes.",
    "b1 -> b2 * r -> b2",
    "i -> (o * r) (bottleneck) -> o",
    "Note in contrast with expansion, we always have",
    "projection to produce the desired output size.",
    "stride check enforces that we don't add residuals when spatial",
    "dimensions are None",
    "Depth matches",
    "Don't do any splitting if we end up with less than 8 filters",
    "on either side.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Set conv defs defaults and overrides.",
    "a) Set the tensorflow scope",
    "b) set padding to default: note we might consider removing this",
    "since it is also set by mobilenet_scope",
    "c) set all defaults",
    "d) set all extra overrides.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "Insert default parameters before the base scope which includes",
    "any custom overrides set in mobilenet.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "Update params.",
    "Only insert rate to params if rate > 1.",
    "Set padding",
    "Add all tensors that end with 'output' to",
    "endpoints",
    "1 x 1 x num_classes",
    "Note: legacy scope name.",
    "Recover output shape, for unknown shape.",
    "the network created will be trainble with dropout/batch norm",
    "initialized appropriately.",
    "Note: do not introduce parameters that would change the inference",
    "model here (for example whether to use bias), modify conv_def instead.",
    "Set weight_decay for weights in Conv and FC layers.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "pyformat: disable",
    "Architecture: https://arxiv.org/abs/1801.04381",
    "Note: these parameters of batch norm affect the architecture",
    "that's why they are here and not in training_scope.",
    "pyformat: enable",
    "NB: do not set depth_args unless they are provided to avoid overriding",
    "whatever default depth_multiplier might have thanks to arg_scope.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "import self.model",
    "self.model",
    "how the model can not load from `***.bin`",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "the channel of input feature is 3",
    "depth should be one of 20, 32, 44, 56, 110, 1202",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.anchors = np.array([[10,13], [16,30],[33,23],[30,61],[62,45], [59,119],[116,90],[156,198],[373,326]])",
    "print(output)",
    "print(out_boxes, out_scores, out_classes)",
    "get random colors",
    "My kingdom for a good redistributable image drawing library.",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "yolov3 80 classes",
    "Reshape to batch, height, width, num_anchors, box_params.",
    "Adjust preditions to each spatial grid point and anchor size.",
    "Note: YOLO iterates over height index before width index.",
    "TODO: It works with +1, don't know why.",
    "Scale boxes back to original image shape.",
    "print(\"feats,anchors, num_classes, input_shape\", feats, anchors, num_classes, input_shape)",
    "print(box_xy, box_wh, box_confidence, box_class_probs)",
    "yolo_outputs order 13,26,52",
    "TODO: use keras backend instead of tf.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Convert network architecture only",
    "MXNet",
    "Caffe",
    "For CoreML",
    "Caffe",
    "Darknet",
    "exts = ['.pb', '.npy', '.py']",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "We use the real_name for specifying the input layer in data_names",
    "since MXNet API wants the actual name of the layer. On the other",
    "hand, the module API wants the last symbol in the symbol chain, so",
    "for the output node we need to use the actual python variable name",
    "of the last layer (real_variable_name).",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if layout not in MXNetEmitter.channels_last:",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "self.output_weights[IR_node.name + \"_gamma\"] = np.multiply(weight_dict['scale'], weight_dict_scale['scale'])",
    "self.output_weights[IR_node.name + \"_beta\"] = np.multiply(weight_dict['bias'], weight_dict_scale['scale']) + weight_dict_scale['bias']",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "def emit_ConvTranspose(self, IR_node):",
    "if self.weight_loaded:",
    "weight_dict = self.weights[IR_node.name]",
    "weights = weight_dict['weights']",
    "dim = len(IR_node.IR_layer.attr[\"kernel_shape\"].list.i) - 2",
    "kernel = list()",
    "for idx in range(0, dim):",
    "kernel.append(IR_node.IR_layer.attr[\"kernel_shape\"].list.i[idx])",
    "stride = list()",
    "for e in IR_node.IR_layer.attr[\"strides\"].list.i[1:-1]:",
    "stride.append(e)",
    "dilate = list()",
    "for e in IR_node.IR_layer.attr[\"dilations\"].list.i[1:-1]:",
    "dilate.append(e)",
    "dilate = ', '.join('%s' % i for i in dilate)",
    "defuse_pad = False",
    "pad = list()",
    "if \"pads\" in IR_node.IR_layer.attr:",
    "output_shape = list()",
    "for e in IR_node.IR_layer.attr[\"_output_shapes\"].list.shape[0].dim:",
    "output_shape.append(e.size)",
    "# print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "defuse_pad, pad = MXNetEmitter.transfer_pad(IR_node.IR_layer.attr[\"pads\"].list.i)",
    "pad = ', '.join('%s' % i for i in pad)",
    "kernel = ', '.join('%s' % i for i in kernel)",
    "stride = ', '.join('%s' % i for i in stride)",
    "num_filter = IR_node.IR_layer.attr[\"kernel_shape\"].list.i[-2]",
    "no_bias = not IR_node.IR_layer.attr[\"use_bias\"].b",
    "if not no_bias and self.weight_loaded:",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_bias\"] = weight_dict['bias']",
    "# layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NCHW'",
    "elif dim == 3:",
    "layout = 'NCDHW'",
    "if self.weight_loaded:",
    "# if layout not in MXNetEmitter.channels_last:",
    "weights = MXNetEmitter.transpose(weights, dim)",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_weight\"] = weights",
    "code = \"\"",
    "if not defuse_pad:",
    "code = \"{:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), pad = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "kernel,",
    "stride,",
    "dilate,",
    "pad,",
    "num_filter,",
    "no_bias,",
    "layout,",
    "IR_node.replace_scope(IR_node.name))",
    "else:",
    "code = self.set_pad(IR_node, code, pad)",
    "code += \"\\n    {:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name) + \"_pad\", kernel, stride, dilate, num_filter, no_bias, layout, IR_node.replace_scope(IR_node.name))",
    "return code",
    "reverse cannot support yet",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(\"trans\", self.parent_variable_name(IR_node))",
    "save the constant into weight dict",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "Load the model network and weights",
    "digraph = mx.viz.plot_network(sym, save_format='jpg') # For debugging",
    "digraph.render()",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "load the model network",
    "adjust the data format",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "for e in pad:",
    "IR_node.attr[\"pads\"].list.i.extend([e, e])",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "name, op",
    "input edge",
    "units",
    "use bias (no_bias default = False)",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "input edge",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "groups",
    "in_channel = in_channel // group",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "padding",
    "weights",
    "axis",
    "scale",
    "epsilon",
    "momentum",
    "weights",
    "gamma",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "kernel_shape",
    "padding",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "dim",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "weights",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "IR only support elu and prelu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "return",
    "name, op",
    "gamma",
    "input edge",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "keep_prob",
    "mode",
    "reverse cannot support yet",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "dim",
    "dtype",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "axis",
    "raise NotImplementedError(\"No matching IR api\")",
    "left strip the \"_\" at the beginning of the name",
    "Issue #85, #135",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "print(moving_variance.name)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into TensorFlow graph",
    "extract subgraph using in_nodes and dest_nodes",
    "Build network graph",
    "extract subgraph using dest_nodes",
    "Get input node name",
    "Graph Transform",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Matmul Layer",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "print (source_node)",
    "print (source_node.layer)",
    "assert False",
    "def rename_RandomShuffleQueueV2(self, source_node):",
    "# print(source_node.layer)",
    "IR_node = self._convert_identity_operation(source_node, in_edge_count = 0, new_op = 'DataInput')",
    "# IR_node.attr['shape'].shape.MergeFromString(source_node.layer.attr['_output_shapes'].list.shape[0].SerializeToString())",
    "# IR_node.attr['shape'].shape.dim[0].size = -1",
    "IR_node.attr['dtype'].type = self.dtype_map[source_node.layer.attr['component_types'].list.type[0]]",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "TODO: Current it is only for slice",
    "TODO:  axis",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "check whether flatten operator should be added",
    "flatten is needed",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "param_code does not need parameter slice.",
    "skip_prefix = [",
    "\"^\",",
    "\"train_op\",",
    "\"save\",",
    "\"gradients\",",
    "\"init\",",
    "\"global_step\",",
    "\"distort_image\",",
    "\"Adagrad\",",
    "]",
    "\"Switch\"",
    "\"RequantizationRange\",",
    "\"Requantize\",",
    "\"Identity\",",
    "\"Mean\",",
    "\"Cast\"",
    "load model files into TensorFlow graph",
    "Save it to an output file",
    "keep dims",
    "axes",
    "ssd model is transformed",
    "Ax - (Au - b)",
    "A",
    "b",
    "print(sub_content)",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "print(Rsqrt.out_edges)",
    "beta  (bias)",
    "moving mean (mean)",
    "input node",
    "epsilon",
    "beta",
    "gamma (scale)",
    "output_node = self.get_son(source_node.name, [0, 0, 0, 0], True)",
    "assert False",
    "Quantized model type",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "assert variable.get_attr('_output_shapes')[0].dim[0].size == IR_node.attr['kernel_shape'].list.i[-1]",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "In facenet or other newtwork using slim.batch_norm,",
    "There are two BN(train, test) skip switch and merge.",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "beta  (bias)",
    "moving mean (mean)",
    "ReduceMean",
    "keep dims",
    "axes",
    "Skip the node as merge",
    "weights",
    "Skip BiasAdd",
    "weights",
    "input_node_perm = self.check_const(self.get_parent(source_node.name, [1], True))",
    "paddings",
    "for attr.shape >= 2",
    "For models built by slim.batch_norm, remove duplicate BN (eg.facenet)",
    "TODO:  only for 1D",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "PaddleParser._set_output_shape(source_node, IR_node)",
    "name, op",
    "input edge",
    "For concat axis",
    "only for training",
    "name, op",
    "input edge",
    "input edge",
    "layer and spec",
    "width <=> x or height <=> y",
    "output shape",
    "name, op",
    "it should be in the shape of height x width x inputchannel x outputchannel",
    "use_bias: TODO",
    "pad_dim",
    "fail report because of auto_pad",
    "if dilation_x == 1 and dilation_y == 1:",
    "if output_x * stride_x == input_x and output_y * stride_y == input_y:",
    "auto_pad = \"SAME\"",
    "kwargs['auto_pad'] = auto_pad",
    "elif output_x * stride_x == input_x - width + 1 and output_y * stride_y == input_y - height + 1:",
    "auto_pad = \"VALID\"",
    "kwargs['auto_pad'] = auto_pad",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "channels_first, then axis = 1",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "flatten",
    "mean",
    "var",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "assert False",
    "output shape",
    "pad_dim",
    "padding mode",
    "If padding == \"SAME\": output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])",
    "If padding == \"VALID\": output_spatial_shape[i] = ceil((input_spatial_shape[i] - (spatial_filter_shape[i]-1) * dilation_rate[i]) / strides[i]).",
    "name, op",
    "input edge",
    "layer and spec",
    "units",
    "output shape",
    "use_bias",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "need the shape TODO",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "alpha",
    "beta",
    "nsize",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "TODO: Handle square",
    "self._print_layer(source_node)",
    "print (source_node.name)",
    "print (self.src_graph.get_parent(source_node.name, [0]).real_name)",
    "assert False",
    "Convolution",
    "Kernel",
    "Attributes",
    "Bias",
    "Activation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "BlockFunction node",
    "redirect the composite's inputs to the true inputs",
    "BlockFunctions are short-circuited, and not added to accum[]",
    "Function node",
    "OutputVariable node",
    "def build(self):",
    "_traverse_graph(self, self.model.root_function)",
    "super(CntkGraph, self).build()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "IR_node.get_attr('output_dim'),",
    "alpha = alpha / size",
    "??",
    "print(IR_node.layer)",
    "assert False",
    "def emit_Unstack(self, IR_node):",
    "num_str = \"{}.shape[{}]\".format(self.parent_variable_name(IR_node), IR_node.get_attr('axis'))",
    "axis = IR_node.get_attr('axis')",
    "parent_variable_shape = \"list({}.shape)\".format(self.parent_variable_name(IR_node)",
    "if self.IR_graph.get_parent(IR_node.name, [0]).type != 'Embedding'",
    "else self.parent_variable_name(IR_node)+'.E')",
    "if axis==1:",
    "shape_str = \"tuple([{}[0]*{}[{}], 1].extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "else:",
    "shape_str = \"tuple([{}[0]*{}[{}]].extend({}[1:{}]).append(1).extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "code = \"{:<15} = cntk.reshape({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "shape_str,",
    "IR_node.variable_name)",
    "code = \"{: <15} = cntk.reshape({}, {}.shape, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name",
    ")",
    "return code",
    "def emit_Fill(self, IR_node):",
    "code = \"{:<15} = cntk.Constant({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "IR_node.get_attr('value'),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name)",
    "return code",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "network library",
    "not support multi-threads download",
    "key: layer_name    value: keras layer",
    "private functions",
    "next_node_info.left_in_edges -= 1",
    "print ('{} --> {}'.format(src, dst))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "If pattern.inputs is empty, skips the rest and accepts all the inputs.",
    "If order doesn't matter for the inputs, then make sure we match at least",
    "one permutation of the inputs.",
    "def get_tensor(self, pattern_or_name):",
    "op_tensor = self._get_op_tensor(pattern_or_name)",
    "return op_tensor[1] if op_tensor else None",
    "pylint: disable=protected-access",
    "pylint: enable=protected-access",
    "Python 3.3.2+ implements `yield from`, but for now:",
    "check the same pattern scope node whether have same inputs, outputs and weights.",
    "For those don't have, rename their scope names.",
    "clear out scope node, typically input constant node.",
    "get sub_scopes",
    "decline the suffix number",
    "Obtain nodes where the scope name that satisfies top_level is top_scope and sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in top_level is top_scope",
    "Obtain all nodes grouped by sub_level sub_scope",
    "cover the node",
    "store idx, node into a dict and sort it later to keep its topology sort.",
    "in_node's out edges replace n_name with scope node name.",
    "no out nodes means the last node in scope nodes should be returned",
    "if out_node is scope node, replace the scope node's inner topology list node.",
    "the input parameter shoule be sliced when call func.",
    "modify the in_edges in scope inner nodes. decline the :idx.",
    "1. initilize scope node",
    "2. get scope nodes' topology list.",
    "3. rebuild the edges connection after folding these scope nodes into one node and",
    "get this scope node's return variables.",
    "4. rebuild graph.",
    "RNN-related attrs.",
    "get input params",
    "self.store_const_to_top(result)",
    "self.set_top_node_prop(result, pattern_name)",
    "Do not include input op.",
    "TODO: pytorch, mxnet, keras, cntk",
    "-*- coding: utf-8 -*-",
    "from keras.layers.core import Layer",
    "Arguments",
    "Input shape",
    "Output shape",
    "Prepare broadcasting shape.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "Keras 2.1.6",
    "Keras. 2.2.2",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "size",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "weights",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "for target shape",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot",
    "print(\"Converting layer {}({})\".format(current_node.name, node_type))",
    "TODO",
    "return input_node, 'same'",
    "assert IR_node.get_attr('group', 1) == 1",
    "change dw from filters to 1",
    "reset the default dilation",
    "############",
    "Operators #",
    "############",
    "code = self._emit_merge(IR_node, \"subtract\")",
    "TODO",
    "when converting from coreml model, reshape is needed after the global pooling",
    "for Keras",
    "It arouses some problems:",
    "it can be implemented by Lambda Layer",
    "https://github.com/keras-team/keras/issues/890",
    "Keras == 2.1.6",
    "Keras == 2.2.2",
    "TODO: arguments won't be saved in keras export model",
    "param_code does not need parameter slice.",
    "Prepare broadcasting shape.",
    "Prepare broadcasting shape.",
    "output = Lambda(lambda x: tf.fill(x, value))(input)",
    "return output",
    "def _layer_Constant(self):",
    "self.add_body(0, '''",
    "class my_constant(keras.layers.Layer):",
    "def __init__(self, value, **kwargs):",
    "super(my_constant, self).__init__(**kwargs)",
    "self._value = value",
    "# the input is dummy, just for creating keras graph.",
    "def call(self, dummy):",
    "res = K.constant(self._value)",
    "self.output_shapes = K.int_shape(res)",
    "return res",
    "def compute_output_shape(self, input_shape):",
    "return self.output_shapes",
    "''')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "with open('modelmapbydataset.json', 'w') as outfile:",
    "json.dump(new_data, outfile)",
    "generate makedown script",
    "add Image Classification",
    "add Object Detection",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "generate makedown script",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "remove list",
    "draw",
    "mode;",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "rm the '_'",
    "Base64 encode: https://developers.google.com/protocol-buffers/docs/proto3",
    "Search the node",
    "select by id: https://stackoverflow.com/questions/37270787/uncaught-syntaxerror-failed-to-execute-queryselector-on-document",
    "Scroll",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ],
  "0.3.0": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "Communication to TensorFlow server via gRPC",
    "TensorFlow serving stuff to send messages",
    "Command line arguments",
    "Send request",
    "request.inputs['input'].CopyFrom()",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.tensorflow_emit",
    "TestModels.caffe_emit,",
    "TestModels.coreml_emit,",
    "TestModels.keras_emit,",
    "TestModels.mxnet_emit,",
    "Run too slow on Travis.",
    "cntk_emit OOM on Travis",
    "TestModels.cntk_emit,",
    "TestModels.cntk_emit,",
    "Cannot run on Travis since it seems to consume too much memory.",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.keras_emit,",
    "TestModels.keras_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.keras_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.tensorflow_emit",
    "omit tensorflow lead to crash",
    "TestModels.cntk_emit,",
    "TestModels.cntk_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.keras_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.tensorflow_emit",
    "TestModels.cntk_emit,",
    "Function self.assertEquals has deprecated, change to assertEqual",
    "self.assertEqual(original_predict.shape, converted_predict.shape)",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "get original model prediction result",
    "original to IR",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "print(original_predict)",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "get shape",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "IR to code",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "The list is in RGB oder",
    "IR to Model",
    "converted_file = original_framework + '_coreml_' + architecture_name + \"_converted\"",
    "converted_file = converted_file.replace('.', '_')",
    "load model",
    "save model",
    "coremltools.utils.save_spec(model.get_spec(), converted_file)",
    "inference",
    "IR to code",
    "import converted model",
    "In case of odd number add the extra padding at the end for SAME_UPPER(eg. pads:[0, 2, 2, 0, 0, 3, 3, 0]) and at the beginning for SAME_LOWER(eg. pads:[0, 3, 3, 0, 0, 2, 2, 0])",
    "'xception'     : [onnx_emit],",
    "'nasnet'       : [onnx_emit],",
    "Temporarily disable 'yolo2'        : [onnx_emit],",
    "Temporarily disable 'inception_v4'  : [onnx_emit],",
    "'voc-fcn8s'     : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn16s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn32s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "Temporarily disable 'xception'      : [onnx_emit],",
    "Temporarily disable 'facenet'               : [onnx_emit],",
    "'resnet_v1_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v1_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'nasnet-a_large'        : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "Temporarily disable 'facenet'           : [onnx_emit],",
    "TODO: coredump",
    "'alexnet'       : [cntk_emit, keras_emit, tensorflow_emit],",
    "'nasnet'       : [tensorflow_emit, keras_emit, coreml_emit],",
    "Temporarily disable 'yolo2'        : [keras_emit],",
    "'facenet'      : [tensorflow_emit, coreml_emit,mxnet_emit,keras_emit]  # TODO",
    "Temporarily disable 'inception_v4'  : [cntk_emit, coreml_emit, keras_emit, pytorch_emit, tensorflow_emit], # TODO mxnet_emit(Small error), caffe_emit(Crash for shape)",
    "Temporarily disable 'xception'      : [coreml_emit, cntk_emit, mxnet_emit, pytorch_emit, tensorflow_emit], #  TODO: Caffe(Crash) keras_emit(too slow)",
    "Temporarily disable 'facenet'               : [mxnet_emit, tensorflow_emit, keras_emit, pytorch_emit, caffe_emit], # TODO: coreml_emit",
    "Temporarily disable 'rnn_lstm_gru_stacked'  : [tensorflow_emit, keras_emit, pytorch_emit, mxnet_emit] #TODO cntk_emit",
    "Temporarily disable 'facenet'           : [mxnet_emit, tensorflow_emit, keras_emit, caffe_emit] # TODO: coreml_emit",
    "'tinyyolo'     : [coreml_emit, keras_emit, mxnet_emit, pytorch_emit, tensorflow_emit],",
    "'vgg16': [tensorflow_emit],",
    "'alexnet': [tensorflow_emit]",
    "get test input path",
    "get original model prediction result",
    "def test_caffe(self):",
    "try:",
    "import caffe",
    "self._test_function('caffe', self.caffe_parse)",
    "except ImportError:",
    "print('Please install caffe! Or caffe is not supported in your platform.', file=sys.stderr)",
    "def test_cntk(self):",
    "try:",
    "import cntk",
    "self._test_function('cntk', self.cntk_parse)",
    "except ImportError:",
    "print('Please install cntk! Or cntk is not supported in your platform.', file=sys.stderr)",
    "def test_coreml(self):",
    "from coremltools.models.utils import macos_version",
    "if macos_version() < (10, 13):",
    "print('Coreml is not supported in your platform.', file=sys.stderr)",
    "else:",
    "self._test_function('coreml', self.coreml_parse)",
    "def test_keras(self):",
    "self._test_function('keras', self.keras_parse)",
    "def test_mxnet(self):",
    "self._test_function('mxnet', self.mxnet_parse)",
    "def test_darknet(self):",
    "self._test_function('darknet', self.darknet_parse)",
    "def test_paddle(self):",
    "# omit tensorflow lead to crash",
    "import tensorflow as tf",
    "try:",
    "import paddle.v2 as paddle",
    "self._test_function('paddle', self.paddle_parse)",
    "except ImportError:",
    "print('Please install Paddlepaddle! Or Paddlepaddle is not supported in your platform.', file=sys.stderr)",
    "def test_pytorch(self):",
    "self._test_function('pytorch', self.pytorch_parse)",
    "def test_tensorflow(self):",
    "self._test_function('tensorflow', self.tensorflow_parse)",
    "def test_tensorflow_frozen(self):",
    "self._test_function('tensorflow_frozen', self.tensorflow_frozen_parse)",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "Temporarily disable 'xception'      : [TestModels.coreml_emit, TestModels.cntk_emit, TestModels.tensorflow_emit],",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "Cannot run on Travis since it seems to consume too much memory.",
    "Temporarily disable 'xception'      : [TestModels.mxnet_emit, TestModels.pytorch_emit],",
    "Temporarily disable 'inception_v4'  : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.keras_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.tensorflow_emit",
    "TestModels.onnx_emit,",
    "TestModels.caffe_emit,",
    "TestModels.cntk_emit,",
    "TestModels.coreml_emit,",
    "TestModels.mxnet_emit,",
    "TestModels.pytorch_emit,",
    "TestModels.tensorflow_emit",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "TestModels.onnx_emit,",
    "TestModels.cntk_emit,",
    "!/usr/bin/python",
    "major python major_python_versions as python2 and python3",
    "operating system",
    "do not deal",
    "I don't want to deal with auto_pad",
    "Don't support auto_pad current!",
    "2018-02-28",
    "if group is None:",
    "group = 1",
    "group is not support yet too.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "node",
    "input",
    "edge(node a <-> node b)",
    "",
    "key is edge name, value is src/dst node name",
    "key is initializer name, value is TensorProto",
    "print(name)",
    "print(layer.op_type)",
    "n is input data",
    "n is input edge",
    "omit node of some type",
    "self.nodes.append(IR_node.variable_name + '_bias')",
    "self.nodes.append(IR_node.variable_name + '_weight')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "if node len(in_edges), generate additional DataInput node",
    "print",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "TODO",
    "'max_pool2d': convert_maxpool,",
    "'onnx::Mul': convert_elementwise_mul,",
    "'onnx::Sub': convert_elementwise_sub,",
    "'onnx::ConvTranspose': convert_convtranspose,",
    "'onnx::LeakyRelu': convert_lrelu,",
    "'onnx::Sigmoid': convert_sigmoid,",
    "'onnx::Softmax': convert_softmax,",
    "'onnx::Selu': convert_selu,",
    "'onnx::Transpose': convert_transpose,",
    "'onnx::Reshape': convert_reshape,",
    "'onnx::MatMul': convert_matmul,",
    "'onnx::Gather': convert_gather,",
    "'onnx::ReduceSum': convert_reduce_sum,",
    "'onnx::Constant': convert_constant,",
    "'onnx::Upsample': convert_upsample,",
    "'onnx::Pad': convert_padding,",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "test",
    "cpu: https://github.com/pytorch/pytorch/issues/5286",
    "Build network graph",
    "(batch, C, H, W)  & NHWC",
    "#########",
    "Layers #",
    "#########",
    "dilation",
    "handle bias",
    "TODO",
    "output_shape",
    "epsilon",
    "mean",
    "var",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "use_bias",
    "units",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Scopes created in a nested scope may have initial characters",
    "that are illegal as the initial character of an op name",
    "(viz. '-', '\\', '/', and '_').",
    "sanity check.",
    "run dce first to eliminate dead parts of the graph that might have been",
    "left behind by things like symbolic_override",
    "construct graph",
    "nodes",
    "input layer",
    "TODO",
    "build each layer",
    "input",
    "print(node_input_name ,'->', node_name)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "padding,",
    "exstr = \", value=float('-Inf')\"",
    "exstr = \"\"",
    "Change to padding defuse",
    "input_node = self._defuse_padding(IR_node, exstr)",
    "Change to padding defuse",
    "Ignore it in Pytorch",
    "for Keras",
    "self.add_init(2, \"self.{:<15} = torch.from_numpy(__weights_dict['{}']['value'])\".format(",
    "IR_node.variable_name,",
    "IR_node.name))",
    "param_code does not need parameter slice.",
    "from torch.nn.parameter import Parameter",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._type = layer.__class__.__name__.replace('Backward', '')",
    "self._name = \"{}_{}\".format(self.type, id)",
    "TODO",
    "\"\"\"",
    "build graph for pytorch 0.2.0",
    "\"\"\"",
    "dummy_input = torch.autograd.Variable(torch.randn(shape))",
    "output_node = self.model(dummy_input)",
    "search_queue = [output_node.grad_fn]",
    "tmp_node = PyTorchGraphNode(output_node.grad_fn, 0)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "visited = {output_node.grad_fn : self.layer_map[tmp_node.name]}",
    "idx = 0",
    "node_count = 1",
    "while (idx < len(search_queue)):",
    "current_node = search_queue[idx]",
    "current_type = visited[current_node].type",
    "if hasattr(current_node, 'next_functions'):",
    "for parent, _ in current_node.next_functions:",
    "parent_type = parent.__class__.__name__.replace('Backward', '')",
    "if parent_type != 'AccumulateGrad' and \\",
    "(parent_type != 'Transpose' or current_type != 'Addmm'):",
    "if not parent in visited:",
    "tmp_node = PyTorchGraphNode(parent, node_count)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "node_count += 1",
    "visited[parent] = tmp_node",
    "search_queue.append(parent)",
    "self._make_connection(visited[parent].name, visited[current_node].name)",
    "idx += 1",
    "try:",
    "return TorchGraph._forward_torch_random_input(",
    "torch_model,",
    "input_shapes,",
    "is_batch=False",
    ")",
    "except:",
    "# try batch mode",
    "# return TorchGraph._forward_torch_random_input(",
    "#     torch_model,",
    "#     input_shapes,",
    "#     is_batch=True",
    "# )",
    "pass",
    "tensor = torch.rand(*shape).float()",
    "multi output",
    "single output",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "Build network graph",
    "#########",
    "Layers #",
    "#########",
    "handle weight",
    "handle bias",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "load model file into Coreml Graph",
    "model.encode() convert to str --- python2 may crash due to type 'unicode'",
    "Build Network Graph",
    "self.data_format ? TODO",
    "load the model network",
    "convert to Model_pb2.Model",
    "determine the type of the current_node",
    "staticmethods",
    "(seq, batch, C, H, W)  & NHWC",
    "TODO dtype_map",
    "##### convert methods",
    "convolution",
    "input edge",
    "important!",
    "reshape the weight!",
    "[2, 3, 0, 1]",
    "pads",
    "use_bias",
    "isDeconvolution",
    "name, op",
    "kwargs['kernel_shape'] = weights.shape",
    "strides",
    "[1, sd, sh, sw, 1]",
    "activation",
    "TODO",
    "padding in conv",
    "pad in IR is [x1_b, x2_b, ..., x1_e, x2_e, ...]",
    "padding",
    "compute padding for 'same'",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "https://www.jianshu.com/p/05c4f1621c7e",
    "padding in pooling",
    "padding",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "TODO",
    "symmetric padding",
    "name, op",
    "input edge",
    "For concat axis",
    "NO axis in coreml, so set the last axis",
    "The first -1 means in coreml there is one-more axis,",
    "The second -1 means the last axis",
    "name, op",
    "input edge",
    "padding",
    "Future Module TODO",
    "#### rename methods",
    "name, op",
    "activation type",
    "else:",
    "assert False",
    "input edge",
    "Merge layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "NHWC channel last",
    "in fact, here is NWHC",
    "name, op",
    "input edge",
    "axis TODO",
    "channels_first, then axis = 1",
    "scale",
    "bias",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "mean",
    "var",
    "name, op",
    "input edge",
    "bias",
    "name, op",
    "input edge",
    "MAX = 0, AVERAGE = 1, L2 = 2",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "change to single because of the tf matmul",
    "in features",
    "name, op",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "the end of the tensorflow_resnet_v2_50's squeeze shape is [unknown_rank: true] with len 0",
    "1001 means the 1001 classes for tensorflow_resnet_v2_50",
    "!Alert! TODO",
    "Future implement can be changed to the last two layer",
    "TODO - remove style transfer 1D hack",
    "Input is 1D but it goes to the width dimension: (1,1,W)",
    "assume (Batch, Channels) - Batch dimension should be dropped",
    "assume (Batch, Sequence-Length, channels)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Add classifier classes (if applicable)",
    "Set pre-processing paramsters",
    "image_input_names,",
    "Return the protobuf spec",
    "model = _MLModel(self.builder.spec)",
    "if IR_node.name in self.weights_dict and 'weights' in self.weights_dict[IR_node.name]:",
    "pass",
    "self._emit_merge(IR_node,'DOT')",
    "Get input and output names",
    "Dimensions and weights",
    "W should have shape (height, width, kernel_channels, output_channels), where kernel_channel = input_channels / groups",
    "Dilations",
    "see protobuf",
    "assert False",
    "Get the weights.",
    "Dilations",
    "see protobuf",
    "depth-wise convolution",
    "Dilations",
    "see protobuf",
    "Get input and output names",
    "Pooling layer type",
    "if it's global, set the global flag",
    "TODO  global pooling modification",
    "Padding",
    "see protobuf",
    "Padding",
    "see protobuf",
    "Get input and output names",
    "type: \"list(int). A 1-D values of (leftBorder, topBorder, rightBorder, bottomBorder).\"",
    "This is central crop",
    "Now add the layer",
    "Allowed values: 'CHW', 'HW', 'C', 'H', 'W'",
    "Get input and output names",
    "Get input and output names",
    "Get the weights from keras",
    "Get input and output names",
    "blob_order == 0 if the input blob needs not be rearranged",
    "blob_order == 1 if the input blob needs to be rearranged",
    "using keras_layer.input.shape have a \"?\" (Dimension[None] at the front),",
    "making a 3D tensor with unknown batch size 4D",
    "Get input and output names",
    "activation emit",
    "Get input and output names",
    "negate it",
    "apply threshold",
    "negate it back",
    "for Keras",
    "Get input and output names",
    "Set parameters",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "padding type TODO",
    "Type of the padding. Can be one of 'constant', 'reflection' or 'replication",
    "Now add the layer",
    "self.emit_Flatten(IR_node)",
    "Get the weights",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "input layer",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "The information of the layer",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "print(node.parameters)",
    "assert False",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "if parent.output_shape.height > 1 or parent.output_shape.width > 1:",
    "TODO: The gamma parameter has to be set (in node.data?) and this should work.",
    "Also, mean should be set to 0, and var to 1, just to be safe.",
    "skip the split node",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For some reason argparser gives us unicode, so we need to conver to str first",
    "for test",
    "with open(\"graph.txt\", 'w') as f:",
    "for layer in self.IR_graph.topological_sort:",
    "current_node = self.IR_graph.get_node(layer)",
    "print(\"========current_node=========\\n{}\".format(current_node.layer), file=f)",
    "test end",
    "print(\"========current_node={}\".format(current_node.layer))",
    "check if have pad layer",
    "Pad_h < kernel_h (vgg19 caffe2caffe)",
    "implement asymmetric paddings by applying symmetric padding then cropping",
    "num_output = IR_node.get_attr('kernel_shape')[-2]",
    "keys = []",
    "for key in self.weights_dict[IR_node.name].keys():",
    "keys.append(key)",
    "print(\"=======Layer: {}, keys: {}\".format(IR_node.name, keys))",
    "if asymmetric padding, set offset to 1",
    "Change the layer name",
    "check if need crop output shape",
    "check if need crop output shape",
    "change the key \"name\" to \"variable_name\", in case of the layer name has invalid characters",
    "Convert NHWC (IR) to NCHW (Caffe): [0,1,2,3]->[0,3,1,2]",
    "def emit_Square(self, IR_node):",
    "input_layers = ', '.join(('n.' + self.IR_graph.get_node(edge).real_variable_name) for edge in IR_node.in_edges)",
    "self.add_body(1, \"n.{:<15} = L.Square({}, ntop=1)\".format(",
    "IR_node.variable_name,",
    "input_layers))",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "self.graph = NodeRenamer()(graph)",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "assert mapped_node is not None",
    "skip when mapped_node is None",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "Fall back to the protobuf implementation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from tensorflow.core.framework.node_def_pb2 import NodeDef",
    "from tensorflow.core.framework import attr_value_pb2",
    "pass",
    "print(\"\\n\")",
    "print(i)",
    "print(block)",
    "continue",
    "NHWC",
    "assert False",
    "print(shortcut_layer['input'] )",
    "spacetodepth",
    "print(block)",
    "print(region_layer)",
    "assert False",
    "print line",
    "set default value",
    "yolo3(608) start at 1, yolo2(608) start at 0. yolo2(416) start at 1, yolo3(416) start at 0",
    "load weight by original order",
    "print(node_type)",
    "print(IR_node)",
    "assert False",
    "strides",
    "assert False",
    "padding",
    "only load weight conv",
    "print(\"----------------\",self.start)",
    "print(kernel.shape)",
    "print(k_bias.shape)",
    "buf, start, scale_layer['name'], bn_layer['name'], conv_layer['name']",
    "print(\"==============\",self.start)",
    "print(bias.shape)",
    "print(scale.shape)",
    "print(mean.shape)",
    "print(var.shape)",
    "print(kernel.shape)",
    "print(W)",
    "assert False",
    "no use",
    "print(source_node.layer)",
    "for image classification(resnet) AVG pooling",
    "print(source_node.layer)",
    "print(source_node.layer)",
    "kwargs['ignore_thresh'] = source_node.get_attr('ignore_thresh')",
    "print(source_node.get_attr('anchors'))",
    "kwargs['anchors'] = ['0.52','0.22']",
    "kwargs['mask'] = source_node.get_attr('mask')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "tensorflow dump tag",
    "Reference: 1) Keras image preprocess: https://github.com/keras-team/keras/blob/master/keras/applications/imagenet_utils.py",
    "2) tensorflow github issue: https://github.com/tensorflow/models/issues/517",
    "R-G-B for Imagenet === [123.68, 116.78, 103.94]",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load a real image and do default tf imageNet preprocessing",
    "[Batch, Height, Width, Channels] --> [Batch, Channels, Height, Width]",
    "We only deal with non-recurrent networks for now",
    "(H,W,C) --> (C,H,W)",
    "Load TensorFlow model",
    "Prepare inputs",
    "Run TF session",
    "Evaluate coreml model",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "@unittest.skip(\"Failing GPU backend: related to https://github.com/tf-coreml/tf-coreml/issues/26\")",
    "? style transfer image size and style number?",
    "Test predictions on an image",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "compare_tf_coreml_outputs(tf_out_flatten, coreml_out_flatten)",
    "#Download model",
    "url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception_v3_2016_08_28_frozen.pb.tar.gz'",
    "tf_model_dir = _download_file(url = url)",
    "tf_model_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28_frozen.pb')",
    "#Convert to coreml",
    "mlmodel_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28.mlmodel')",
    "mlmodel = tf_converter.convert(",
    "tf_model_path = tf_model_path,",
    "mlmodel_path = mlmodel_path,",
    "output_feature_names = ['InceptionV3/Predictions/Softmax:0'],",
    "input_name_shape_dict = {'input:0':[1,299,299,3]},",
    "image_input_names = ['input:0'],",
    "red_bias = -1,",
    "green_bias = -1,",
    "blue_bias = -1,",
    "image_scale = 2.0/255.0)",
    "#Test predictions on an image",
    "_test_coreml_model_image_input(",
    "tf_model_path = tf_model_path,",
    "coreml_model = mlmodel,",
    "input_tensor_name = 'input:0',",
    "output_tensor_name = 'InceptionV3/Predictions/Softmax:0',",
    "img_size = 299)",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "self.test_truth()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from collections import namedtuple",
    "Batch = namedtuple('Batch', ['data'])",
    "TODO",
    "Apple has published some of their own models. They can be downloaded from https://developer.apple.com/machine-learning/.",
    "Those published models are: SqueezeNet, Places205-GoogLeNet, ResNet50, Inception v3, VGG16",
    "TODO",
    "load model",
    "TODO: Multiple inputs",
    "TODO: Multiple outputs",
    "inference",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "caffe uses NCHW",
    "self.print_intermediate_result('pooling0', False)",
    "delete tmp model files",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "net = caffe.Net(arch_fn, weight_fn, caffe.TEST)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "# Image Classification",
    "# Semantic Segmentation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "print(r)",
    "d = darknet_extractor()",
    "model_filename = d.download('yolov3')",
    "print(model_filename)",
    "image_path = \"./mmdnn/conversion/examples/data/dog.jpg\"",
    "model_path = \"./\"",
    "d = darknet_extractor()",
    "result = d.inference('yolov3', model_filename, model_path, image_path = image_path)",
    "print(result)",
    "print(i)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('pooling0', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "need to be updated",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "raise NotImplementedError()",
    "Load file",
    "Run TensorBoard",
    "print(cmd)",
    "Using cuDNN since vanilla RNN",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Notes for training NASNet Cifar Model",
    "-------------------------------------",
    "batch_size: 32",
    "learning rate: 0.025",
    "cosine (single period) learning rate decay",
    "auxiliary head loss weighting: 0.4",
    "clip global norm of all gradients by 5",
    "600 epochs with a batch size of 32",
    "This is used for the drop path probabilities since it needs to increase",
    "the drop out probability over the course of training.",
    "Notes for training large NASNet model on ImageNet",
    "-------------------------------------",
    "batch size (per replica): 16",
    "learning rate: 0.015 * 100",
    "learning rate decay factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 100 replicas",
    "auxiliary head loss weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Notes for training the mobile NASNet ImageNet model",
    "-------------------------------------",
    "batch size (per replica): 32",
    "learning rate: 0.04 * 50",
    "learning rate scaling factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 50 replicas",
    "auxiliary head weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Shape of feature map before the final layer.",
    "149 x 149 x 32",
    "Run the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Find where to place the reduction cells or stride normal cells",
    "Setup for building in the auxiliary head.",
    "Run the cells",
    "true_cell_num accounts for the stem cells",
    "Final softmax layer",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 192",
    "35 x 35 x 320",
    "TODO(alemi): Register intermediate endpoints",
    "17 x 17 x 1088 if output_stride == 8,",
    "33 x 33 x 1088 if output_stride == 16",
    "TODO(alemi): register intermediate endpoints",
    "TODO(gpapan): Properly support output_stride for the rest of the net.",
    "8 x 8 x 2080",
    "TODO(alemi): register intermediate endpoints",
    "8 x 8 x 1536",
    "TODO(sguada,arnoegw): Consider adding a parameter global_pool which",
    "can be set to False to disable pooling here (as in resnet_*()).",
    "Set weight_decay for weights in conv2d and fully_connected layers.",
    "Set activation_fn and parameters for batch_norm.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "=============================================================================",
    "Tensorflow mandates these.",
    "Conv and DepthSepConv namedtuple define layers of the MobileNet architecture",
    "Conv defines 3x3 convolution layers",
    "DepthSepConv defines 3x3 depthwise convolution followed by 1x1 convolution.",
    "stride is the stride of the convolution",
    "depth is the number of channels or filters in a layer",
    "_CONV_DEFS specifies the MobileNet body",
    "Used to find thinned depths for each layer.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "By passing filters=None",
    "separable_conv2d produces only a depthwise convolution layer",
    "Global average pooling.",
    "Pooling with a fixed kernel size.",
    "1 x 1 x 1024",
    "Set weight_decay for weights in Conv and DepthSepConv layers.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Skip path 1",
    "Skip path 2",
    "First pad with 0's on the right and bottom, then shift the filter to",
    "include those 0's that were added.",
    "Concat and apply BN",
    "Set the prev layer to the current layer if it is none",
    "Check to be sure prev layer stuff is setup correctly",
    "Apply conv operations",
    "Combine hidden states using 'add'.",
    "Add hiddenstate to the list of hiddenstates we can choose from",
    "Dont stride if this is not one of the original hiddenstates",
    "Check if a stride is needed, then use a strided 1x1 here",
    "Determine if a reduction should be applied to make the number of",
    "filters match.",
    "Return the concat of all the states",
    "Scale keep prob by layer number",
    "The added 2 is for the reduction cells",
    "Decrease the keep probability over time",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Inception-Resnet-A",
    "Inception-Resnet-B",
    "Inception-Resnet-C",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "force in-place updates of mean and variance estimates",
    "Moving averages ends up in the trainable variables collection",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 256",
    "5 x Inception-resnet-A",
    "Reduction-A",
    "10 x Inception-Resnet-B",
    "Reduction-B",
    "5 x Inception-Resnet-C",
    "pylint: disable=no-member",
    "net = slim.fully_connected(net, bottleneck_layer_size, activation_fn=None,",
    "scope='Bottleneck', reuse=False)",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Note: want to round down, we adjust each split to match the total.",
    "We use scope_depthwise, scope_pointwise for compatibility with V1 ckpts.",
    "which provide numbered scopes.",
    "b1 -> b2 * r -> b2",
    "i -> (o * r) (bottleneck) -> o",
    "Note in contrast with expansion, we always have",
    "projection to produce the desired output size.",
    "stride check enforces that we don't add residuals when spatial",
    "dimensions are None",
    "Depth matches",
    "Don't do any splitting if we end up with less than 8 filters",
    "on either side.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Set conv defs defaults and overrides.",
    "a) Set the tensorflow scope",
    "b) set padding to default: note we might consider removing this",
    "since it is also set by mobilenet_scope",
    "c) set all defaults",
    "d) set all extra overrides.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "Insert default parameters before the base scope which includes",
    "any custom overrides set in mobilenet.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "Update params.",
    "Only insert rate to params if rate > 1.",
    "Set padding",
    "Add all tensors that end with 'output' to",
    "endpoints",
    "1 x 1 x num_classes",
    "Note: legacy scope name.",
    "Recover output shape, for unknown shape.",
    "the network created will be trainble with dropout/batch norm",
    "initialized appropriately.",
    "Note: do not introduce parameters that would change the inference",
    "model here (for example whether to use bias), modify conv_def instead.",
    "Set weight_decay for weights in Conv and FC layers.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "pyformat: disable",
    "Architecture: https://arxiv.org/abs/1801.04381",
    "Note: these parameters of batch norm affect the architecture",
    "that's why they are here and not in training_scope.",
    "pyformat: enable",
    "NB: do not set depth_args unless they are provided to avoid overriding",
    "whatever default depth_multiplier might have thanks to arg_scope.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "import self.model",
    "self.model",
    "how the model can not load from `***.bin`",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "the channel of input feature is 3",
    "depth should be one of 20, 32, 44, 56, 110, 1202",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.anchors = np.array([[10,13], [16,30],[33,23],[30,61],[62,45], [59,119],[116,90],[156,198],[373,326]])",
    "print(output)",
    "print(out_boxes, out_scores, out_classes)",
    "get random colors",
    "My kingdom for a good redistributable image drawing library.",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "yolov3 80 classes",
    "Reshape to batch, height, width, num_anchors, box_params.",
    "Adjust preditions to each spatial grid point and anchor size.",
    "Note: YOLO iterates over height index before width index.",
    "TODO: It works with +1, don't know why.",
    "Scale boxes back to original image shape.",
    "print(\"feats,anchors, num_classes, input_shape\", feats, anchors, num_classes, input_shape)",
    "print(box_xy, box_wh, box_confidence, box_class_probs)",
    "yolo_outputs order 13,26,52",
    "TODO: use keras backend instead of tf.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Convert network architecture only",
    "MXNet",
    "Caffe",
    "For CoreML",
    "Caffe",
    "Darknet",
    "exts = ['.pb', '.npy', '.py']",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "We use the real_name for specifying the input layer in data_names",
    "since MXNet API wants the actual name of the layer. On the other",
    "hand, the module API wants the last symbol in the symbol chain, so",
    "for the output node we need to use the actual python variable name",
    "of the last layer (real_variable_name).",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if layout not in MXNetEmitter.channels_last:",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "self.output_weights[IR_node.name + \"_gamma\"] = np.multiply(weight_dict['scale'], weight_dict_scale['scale'])",
    "self.output_weights[IR_node.name + \"_beta\"] = np.multiply(weight_dict['bias'], weight_dict_scale['scale']) + weight_dict_scale['bias']",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "def emit_ConvTranspose(self, IR_node):",
    "if self.weight_loaded:",
    "weight_dict = self.weights[IR_node.name]",
    "weights = weight_dict['weights']",
    "dim = len(IR_node.IR_layer.attr[\"kernel_shape\"].list.i) - 2",
    "kernel = list()",
    "for idx in range(0, dim):",
    "kernel.append(IR_node.IR_layer.attr[\"kernel_shape\"].list.i[idx])",
    "stride = list()",
    "for e in IR_node.IR_layer.attr[\"strides\"].list.i[1:-1]:",
    "stride.append(e)",
    "dilate = list()",
    "for e in IR_node.IR_layer.attr[\"dilations\"].list.i[1:-1]:",
    "dilate.append(e)",
    "dilate = ', '.join('%s' % i for i in dilate)",
    "defuse_pad = False",
    "pad = list()",
    "if \"pads\" in IR_node.IR_layer.attr:",
    "output_shape = list()",
    "for e in IR_node.IR_layer.attr[\"_output_shapes\"].list.shape[0].dim:",
    "output_shape.append(e.size)",
    "# print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "defuse_pad, pad = MXNetEmitter.transfer_pad(IR_node.IR_layer.attr[\"pads\"].list.i)",
    "pad = ', '.join('%s' % i for i in pad)",
    "kernel = ', '.join('%s' % i for i in kernel)",
    "stride = ', '.join('%s' % i for i in stride)",
    "num_filter = IR_node.IR_layer.attr[\"kernel_shape\"].list.i[-2]",
    "no_bias = not IR_node.IR_layer.attr[\"use_bias\"].b",
    "if not no_bias and self.weight_loaded:",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_bias\"] = weight_dict['bias']",
    "# layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NCHW'",
    "elif dim == 3:",
    "layout = 'NCDHW'",
    "if self.weight_loaded:",
    "# if layout not in MXNetEmitter.channels_last:",
    "weights = MXNetEmitter.transpose(weights, dim)",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_weight\"] = weights",
    "code = \"\"",
    "if not defuse_pad:",
    "code = \"{:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), pad = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "kernel,",
    "stride,",
    "dilate,",
    "pad,",
    "num_filter,",
    "no_bias,",
    "layout,",
    "IR_node.replace_scope(IR_node.name))",
    "else:",
    "code = self.set_pad(IR_node, code, pad)",
    "code += \"\\n    {:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name) + \"_pad\", kernel, stride, dilate, num_filter, no_bias, layout, IR_node.replace_scope(IR_node.name))",
    "return code",
    "reverse cannot support yet",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(\"trans\", self.parent_variable_name(IR_node))",
    "save the constant into weight dict",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "Load the model network and weights",
    "digraph = mx.viz.plot_network(sym, save_format='jpg') # For debugging",
    "digraph.render()",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "load the model network",
    "adjust the data format",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "for e in pad:",
    "IR_node.attr[\"pads\"].list.i.extend([e, e])",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "name, op",
    "input edge",
    "units",
    "use bias (no_bias default = False)",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "input edge",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "groups",
    "in_channel = in_channel // group",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "padding",
    "weights",
    "axis",
    "scale",
    "epsilon",
    "momentum",
    "weights",
    "gamma",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "kernel_shape",
    "padding",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "dim",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "weights",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "IR only support elu and prelu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "return",
    "name, op",
    "gamma",
    "input edge",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "keep_prob",
    "mode",
    "reverse cannot support yet",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "dim",
    "dtype",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "axis",
    "raise NotImplementedError(\"No matching IR api\")",
    "left strip the \"_\" at the beginning of the name",
    "Issue #85, #135",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "print(moving_variance.name)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into TensorFlow graph",
    "extract subgraph using in_nodes and dest_nodes",
    "Build network graph",
    "extract subgraph using dest_nodes",
    "Get input node name",
    "Graph Transform",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Matmul Layer",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "print (source_node)",
    "print (source_node.layer)",
    "assert False",
    "def rename_RandomShuffleQueueV2(self, source_node):",
    "# print(source_node.layer)",
    "IR_node = self._convert_identity_operation(source_node, in_edge_count = 0, new_op = 'DataInput')",
    "# IR_node.attr['shape'].shape.MergeFromString(source_node.layer.attr['_output_shapes'].list.shape[0].SerializeToString())",
    "# IR_node.attr['shape'].shape.dim[0].size = -1",
    "IR_node.attr['dtype'].type = self.dtype_map[source_node.layer.attr['component_types'].list.type[0]]",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "TODO: Current it is only for slice",
    "TODO:  axis",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "check whether flatten operator should be added",
    "flatten is needed",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "param_code does not need parameter slice.",
    "skip_prefix = [",
    "\"^\",",
    "\"train_op\",",
    "\"save\",",
    "\"gradients\",",
    "\"init\",",
    "\"global_step\",",
    "\"distort_image\",",
    "\"Adagrad\",",
    "]",
    "\"Switch\"",
    "\"RequantizationRange\",",
    "\"Requantize\",",
    "\"Identity\",",
    "\"Mean\",",
    "\"Cast\"",
    "load model files into TensorFlow graph",
    "Save it to an output file",
    "keep dims",
    "axes",
    "ssd model is transformed",
    "Ax - (Au - b)",
    "A",
    "b",
    "print(sub_content)",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "print(Rsqrt.out_edges)",
    "beta  (bias)",
    "moving mean (mean)",
    "input node",
    "epsilon",
    "beta",
    "gamma (scale)",
    "output_node = self.get_son(source_node.name, [0, 0, 0, 0], True)",
    "assert False",
    "Quantized model type",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "assert variable.get_attr('_output_shapes')[0].dim[0].size == IR_node.attr['kernel_shape'].list.i[-1]",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "In facenet or other newtwork using slim.batch_norm,",
    "There are two BN(train, test) skip switch and merge.",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "beta  (bias)",
    "moving mean (mean)",
    "ReduceMean",
    "keep dims",
    "axes",
    "Skip the node as merge",
    "weights",
    "Skip BiasAdd",
    "weights",
    "input_node_perm = self.check_const(self.get_parent(source_node.name, [1], True))",
    "paddings",
    "for attr.shape >= 2",
    "For models built by slim.batch_norm, remove duplicate BN (eg.facenet)",
    "TODO:  only for 1D",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "PaddleParser._set_output_shape(source_node, IR_node)",
    "name, op",
    "input edge",
    "For concat axis",
    "only for training",
    "name, op",
    "input edge",
    "input edge",
    "layer and spec",
    "width <=> x or height <=> y",
    "output shape",
    "name, op",
    "it should be in the shape of height x width x inputchannel x outputchannel",
    "use_bias: TODO",
    "pad_dim",
    "fail report because of auto_pad",
    "if dilation_x == 1 and dilation_y == 1:",
    "if output_x * stride_x == input_x and output_y * stride_y == input_y:",
    "auto_pad = \"SAME\"",
    "kwargs['auto_pad'] = auto_pad",
    "elif output_x * stride_x == input_x - width + 1 and output_y * stride_y == input_y - height + 1:",
    "auto_pad = \"VALID\"",
    "kwargs['auto_pad'] = auto_pad",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "channels_first, then axis = 1",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "flatten",
    "mean",
    "var",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "assert False",
    "output shape",
    "pad_dim",
    "padding mode",
    "If padding == \"SAME\": output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])",
    "If padding == \"VALID\": output_spatial_shape[i] = ceil((input_spatial_shape[i] - (spatial_filter_shape[i]-1) * dilation_rate[i]) / strides[i]).",
    "name, op",
    "input edge",
    "layer and spec",
    "units",
    "output shape",
    "use_bias",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "need the shape TODO",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "alpha",
    "beta",
    "nsize",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "TODO: Handle square",
    "self._print_layer(source_node)",
    "print (source_node.name)",
    "print (self.src_graph.get_parent(source_node.name, [0]).real_name)",
    "assert False",
    "Convolution",
    "Kernel",
    "Attributes",
    "Bias",
    "Activation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "BlockFunction node",
    "redirect the composite's inputs to the true inputs",
    "BlockFunctions are short-circuited, and not added to accum[]",
    "Function node",
    "OutputVariable node",
    "def build(self):",
    "_traverse_graph(self, self.model.root_function)",
    "super(CntkGraph, self).build()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "IR_node.get_attr('output_dim'),",
    "alpha = alpha / size",
    "??",
    "print(IR_node.layer)",
    "assert False",
    "def emit_Unstack(self, IR_node):",
    "num_str = \"{}.shape[{}]\".format(self.parent_variable_name(IR_node), IR_node.get_attr('axis'))",
    "axis = IR_node.get_attr('axis')",
    "parent_variable_shape = \"list({}.shape)\".format(self.parent_variable_name(IR_node)",
    "if self.IR_graph.get_parent(IR_node.name, [0]).type != 'Embedding'",
    "else self.parent_variable_name(IR_node)+'.E')",
    "if axis==1:",
    "shape_str = \"tuple([{}[0]*{}[{}], 1].extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "else:",
    "shape_str = \"tuple([{}[0]*{}[{}]].extend({}[1:{}]).append(1).extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "code = \"{:<15} = cntk.reshape({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "shape_str,",
    "IR_node.variable_name)",
    "code = \"{: <15} = cntk.reshape({}, {}.shape, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name",
    ")",
    "return code",
    "def emit_Fill(self, IR_node):",
    "code = \"{:<15} = cntk.Constant({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "IR_node.get_attr('value'),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name)",
    "return code",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "network library",
    "not support multi-threads download",
    "key: layer_name    value: keras layer",
    "private functions",
    "next_node_info.left_in_edges -= 1",
    "print ('{} --> {}'.format(src, dst))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "If pattern.inputs is empty, skips the rest and accepts all the inputs.",
    "If order doesn't matter for the inputs, then make sure we match at least",
    "one permutation of the inputs.",
    "def get_tensor(self, pattern_or_name):",
    "op_tensor = self._get_op_tensor(pattern_or_name)",
    "return op_tensor[1] if op_tensor else None",
    "pylint: disable=protected-access",
    "pylint: enable=protected-access",
    "Python 3.3.2+ implements `yield from`, but for now:",
    "check the same pattern scope node whether have same inputs, outputs and weights.",
    "For those don't have, rename their scope names.",
    "clear out scope node, typically input constant node.",
    "get sub_scopes",
    "decline the suffix number",
    "Obtain nodes where the scope name that satisfies top_level is top_scope and sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in top_level is top_scope",
    "Obtain all nodes grouped by sub_level sub_scope",
    "cover the node",
    "store idx, node into a dict and sort it later to keep its topology sort.",
    "in_node's out edges replace n_name with scope node name.",
    "no out nodes means the last node in scope nodes should be returned",
    "if out_node is scope node, replace the scope node's inner topology list node.",
    "the input parameter shoule be sliced when call func.",
    "modify the in_edges in scope inner nodes. decline the :idx.",
    "1. initilize scope node",
    "2. get scope nodes' topology list.",
    "3. rebuild the edges connection after folding these scope nodes into one node and",
    "get this scope node's return variables.",
    "4. rebuild graph.",
    "RNN-related attrs.",
    "get input params",
    "self.store_const_to_top(result)",
    "self.set_top_node_prop(result, pattern_name)",
    "Do not include input op.",
    "TODO: pytorch, mxnet, keras, cntk",
    "-*- coding: utf-8 -*-",
    "from keras.layers.core import Layer",
    "Arguments",
    "Input shape",
    "Output shape",
    "Prepare broadcasting shape.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "Keras 2.1.6",
    "Keras. 2.2.2",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "size",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "weights",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "for target shape",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot",
    "print(\"Converting layer {}({})\".format(current_node.name, node_type))",
    "TODO",
    "return input_node, 'same'",
    "assert IR_node.get_attr('group', 1) == 1",
    "change dw from filters to 1",
    "reset the default dilation",
    "############",
    "Operators #",
    "############",
    "code = self._emit_merge(IR_node, \"subtract\")",
    "TODO",
    "when converting from coreml model, reshape is needed after the global pooling",
    "for Keras",
    "It arouses some problems:",
    "it can be implemented by Lambda Layer",
    "https://github.com/keras-team/keras/issues/890",
    "Keras == 2.1.6",
    "Keras == 2.2.2",
    "TODO: arguments won't be saved in keras export model",
    "param_code does not need parameter slice.",
    "Prepare broadcasting shape.",
    "Prepare broadcasting shape.",
    "output = Lambda(lambda x: tf.fill(x, value))(input)",
    "return output",
    "def _layer_Constant(self):",
    "self.add_body(0, '''",
    "class my_constant(keras.layers.Layer):",
    "def __init__(self, value, **kwargs):",
    "super(my_constant, self).__init__(**kwargs)",
    "self._value = value",
    "# the input is dummy, just for creating keras graph.",
    "def call(self, dummy):",
    "res = K.constant(self._value)",
    "self.output_shapes = K.int_shape(res)",
    "return res",
    "def compute_output_shape(self, input_shape):",
    "return self.output_shapes",
    "''')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "with open('modelmapbydataset.json', 'w') as outfile:",
    "json.dump(new_data, outfile)",
    "generate makedown script",
    "add Image Classification",
    "add Object Detection",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "generate makedown script",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "remove list",
    "draw",
    "mode;",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "rm the '_'",
    "Base64 encode: https://developers.google.com/protocol-buffers/docs/proto3",
    "Search the node",
    "select by id: https://stackoverflow.com/questions/37270787/uncaught-syntaxerror-failed-to-execute-queryselector-on-document",
    "Scroll",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ],
  "0.2.5": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "Communication to TensorFlow server via gRPC",
    "TensorFlow serving stuff to send messages",
    "Command line arguments",
    "Send request",
    "request.inputs['input'].CopyFrom()",
    "'xception'     : [TestModels.onnx_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "omit tensorflow lead to crash",
    "'nasnet-a_large'       : [TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'inception_resnet_v2'  : [TestModels.caffe_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "Function self.assertEquals has deprecated, change to assertEqual",
    "self.assertEqual(original_predict.shape, converted_predict.shape)",
    "get original model prediction result",
    "original to IR",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "print(original_predict)",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "get shape",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "IR to code",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "The list is in RGB oder",
    "IR to Model",
    "converted_file = original_framework + '_coreml_' + architecture_name + \"_converted\"",
    "converted_file = converted_file.replace('.', '_')",
    "load model",
    "save model",
    "coremltools.utils.save_spec(model.get_spec(), converted_file)",
    "inference",
    "IR to code",
    "import converted model",
    "In case of odd number add the extra padding at the end for SAME_UPPER(eg. pads:[0, 2, 2, 0, 0, 3, 3, 0]) and at the beginning for SAME_LOWER(eg. pads:[0, 3, 3, 0, 0, 2, 2, 0])",
    "'xception'     : [onnx_emit],",
    "'nasnet'       : [onnx_emit],",
    "'voc-fcn8s'     : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn16s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn32s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'resnet_v1_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v1_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'nasnet-a_large'        : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "TODO: coredump",
    "'alexnet'       : [cntk_emit, keras_emit, tensorflow_emit],",
    "'nasnet'       : [tensorflow_emit, keras_emit, coreml_emit],",
    "'facenet'      : [tensorflow_emit, coreml_emit,mxnet_emit,keras_emit]  # TODO",
    "'tinyyolo'     : [coreml_emit, keras_emit, mxnet_emit, pytorch_emit, tensorflow_emit],",
    "'vgg16': [tensorflow_emit],",
    "'alexnet': [tensorflow_emit]",
    "get test input path",
    "get original model prediction result",
    "def test_caffe(self):",
    "try:",
    "import caffe",
    "self._test_function('caffe', self.caffe_parse)",
    "except ImportError:",
    "print('Please install caffe! Or caffe is not supported in your platform.', file=sys.stderr)",
    "def test_cntk(self):",
    "try:",
    "import cntk",
    "self._test_function('cntk', self.cntk_parse)",
    "except ImportError:",
    "print('Please install cntk! Or cntk is not supported in your platform.', file=sys.stderr)",
    "def test_coreml(self):",
    "from coremltools.models.utils import macos_version",
    "if macos_version() < (10, 13):",
    "print('Coreml is not supported in your platform.', file=sys.stderr)",
    "else:",
    "self._test_function('coreml', self.coreml_parse)",
    "def test_keras(self):",
    "self._test_function('keras', self.keras_parse)",
    "def test_mxnet(self):",
    "self._test_function('mxnet', self.mxnet_parse)",
    "def test_darknet(self):",
    "self._test_function('darknet', self.darknet_parse)",
    "def test_paddle(self):",
    "# omit tensorflow lead to crash",
    "import tensorflow as tf",
    "try:",
    "import paddle.v2 as paddle",
    "self._test_function('paddle', self.paddle_parse)",
    "except ImportError:",
    "print('Please install Paddlepaddle! Or Paddlepaddle is not supported in your platform.', file=sys.stderr)",
    "def test_pytorch(self):",
    "self._test_function('pytorch', self.pytorch_parse)",
    "def test_tensorflow(self):",
    "self._test_function('tensorflow', self.tensorflow_parse)",
    "def test_tensorflow_frozen(self):",
    "self._test_function('tensorflow_frozen', self.tensorflow_frozen_parse)",
    "'vgg19'         : [TestModels.onnx_emit],",
    "'voc-fcn8s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'vgg19'         : [TestModels.caffe_emit, TestModels.cntk_emit, TestModels.coreml_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'voc-fcn8s'     : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'voc-fcn16s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'voc-fcn32s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "'vgg19'         : [TestModels.onnx_emit],",
    "'alexnet'       : [TestModels.caffe_emit, TestModels.cntk_emit, TestModels.coreml_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'nasnet-a_large'       : [TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'inception_resnet_v2'  : [TestModels.caffe_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'xception'     : [TestModels.onnx_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "!/usr/bin/python",
    "major python major_python_versions as python2 and python3",
    "operating system",
    "do not deal",
    "I don't want to deal with auto_pad",
    "Don't support auto_pad current!",
    "2018-02-28",
    "if group is None:",
    "group = 1",
    "group is not support yet too.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "node",
    "input",
    "edge(node a <-> node b)",
    "",
    "key is edge name, value is src/dst node name",
    "key is initializer name, value is TensorProto",
    "print(name)",
    "print(layer.op_type)",
    "n is input data",
    "n is input edge",
    "omit node of some type",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "if node len(in_edges), generate additional DataInput node",
    "print",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "TODO",
    "'max_pool2d': convert_maxpool,",
    "'onnx::Mul': convert_elementwise_mul,",
    "'onnx::Sub': convert_elementwise_sub,",
    "'onnx::ConvTranspose': convert_convtranspose,",
    "'onnx::LeakyRelu': convert_lrelu,",
    "'onnx::Sigmoid': convert_sigmoid,",
    "'onnx::Softmax': convert_softmax,",
    "'onnx::Selu': convert_selu,",
    "'onnx::Transpose': convert_transpose,",
    "'onnx::Reshape': convert_reshape,",
    "'onnx::MatMul': convert_matmul,",
    "'onnx::Gather': convert_gather,",
    "'onnx::ReduceSum': convert_reduce_sum,",
    "'onnx::Constant': convert_constant,",
    "'onnx::Upsample': convert_upsample,",
    "'onnx::Pad': convert_padding,",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "test",
    "cpu: https://github.com/pytorch/pytorch/issues/5286",
    "Build network graph",
    "(batch, C, H, W)  & NHWC",
    "#########",
    "Layers #",
    "#########",
    "dilation",
    "handle bias",
    "TODO",
    "output_shape",
    "epsilon",
    "mean",
    "var",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "use_bias",
    "units",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Scopes created in a nested scope may have initial characters",
    "that are illegal as the initial character of an op name",
    "(viz. '-', '\\', '/', and '_').",
    "sanity check.",
    "run dce first to eliminate dead parts of the graph that might have been",
    "left behind by things like symbolic_override",
    "construct graph",
    "nodes",
    "input layer",
    "TODO",
    "build each layer",
    "input",
    "print(node_input_name ,'->', node_name)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "padding,",
    "exstr = \", value=float('-Inf')\"",
    "exstr = \"\"",
    "Change to padding defuse",
    "input_node = self._defuse_padding(IR_node, exstr)",
    "Ignore it in Pytorch",
    "for Keras",
    "self.add_init(2, \"self.{:<15} = torch.from_numpy(__weights_dict['{}']['value'])\".format(",
    "IR_node.variable_name,",
    "IR_node.name))",
    "param_code does not need parameter slice.",
    "from torch.nn.parameter import Parameter",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._type = layer.__class__.__name__.replace('Backward', '')",
    "self._name = \"{}_{}\".format(self.type, id)",
    "TODO",
    "\"\"\"",
    "build graph for pytorch 0.2.0",
    "\"\"\"",
    "dummy_input = torch.autograd.Variable(torch.randn(shape))",
    "output_node = self.model(dummy_input)",
    "search_queue = [output_node.grad_fn]",
    "tmp_node = PyTorchGraphNode(output_node.grad_fn, 0)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "visited = {output_node.grad_fn : self.layer_map[tmp_node.name]}",
    "idx = 0",
    "node_count = 1",
    "while (idx < len(search_queue)):",
    "current_node = search_queue[idx]",
    "current_type = visited[current_node].type",
    "if hasattr(current_node, 'next_functions'):",
    "for parent, _ in current_node.next_functions:",
    "parent_type = parent.__class__.__name__.replace('Backward', '')",
    "if parent_type != 'AccumulateGrad' and \\",
    "(parent_type != 'Transpose' or current_type != 'Addmm'):",
    "if not parent in visited:",
    "tmp_node = PyTorchGraphNode(parent, node_count)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "node_count += 1",
    "visited[parent] = tmp_node",
    "search_queue.append(parent)",
    "self._make_connection(visited[parent].name, visited[current_node].name)",
    "idx += 1",
    "try:",
    "return TorchGraph._forward_torch_random_input(",
    "torch_model,",
    "input_shapes,",
    "is_batch=False",
    ")",
    "except:",
    "# try batch mode",
    "# return TorchGraph._forward_torch_random_input(",
    "#     torch_model,",
    "#     input_shapes,",
    "#     is_batch=True",
    "# )",
    "pass",
    "tensor = torch.rand(*shape).float()",
    "multi output",
    "single output",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "Build network graph",
    "#########",
    "Layers #",
    "#########",
    "handle weight",
    "handle bias",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "load model file into Coreml Graph",
    "model.encode() convert to str --- python2 may crash due to type 'unicode'",
    "Build Network Graph",
    "self.data_format ? TODO",
    "load the model network",
    "convert to Model_pb2.Model",
    "determine the type of the current_node",
    "staticmethods",
    "(seq, batch, C, H, W)  & NHWC",
    "TODO dtype_map",
    "##### convert methods",
    "convolution",
    "input edge",
    "important!",
    "reshape the weight!",
    "[2, 3, 0, 1]",
    "pads",
    "use_bias",
    "isDeconvolution",
    "name, op",
    "kwargs['kernel_shape'] = weights.shape",
    "strides",
    "[1, sd, sh, sw, 1]",
    "activation",
    "TODO",
    "padding in conv",
    "pad in IR is [x1_b, x2_b, ..., x1_e, x2_e, ...]",
    "padding",
    "compute padding for 'same'",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "https://www.jianshu.com/p/05c4f1621c7e",
    "padding in pooling",
    "padding",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "TODO",
    "symmetric padding",
    "name, op",
    "input edge",
    "For concat axis",
    "NO axis in coreml, so set the last axis",
    "The first -1 means in coreml there is one-more axis,",
    "The second -1 means the last axis",
    "name, op",
    "input edge",
    "padding",
    "Future Module TODO",
    "#### rename methods",
    "name, op",
    "activation type",
    "else:",
    "assert False",
    "input edge",
    "Merge layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "NHWC channel last",
    "in fact, here is NWHC",
    "name, op",
    "input edge",
    "axis TODO",
    "channels_first, then axis = 1",
    "scale",
    "bias",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "mean",
    "var",
    "name, op",
    "input edge",
    "bias",
    "name, op",
    "input edge",
    "MAX = 0, AVERAGE = 1, L2 = 2",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "change to single because of the tf matmul",
    "in features",
    "name, op",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "the end of the tensorflow_resnet_v2_50's squeeze shape is [unknown_rank: true] with len 0",
    "1001 means the 1001 classes for tensorflow_resnet_v2_50",
    "!Alert! TODO",
    "Future implement can be changed to the last two layer",
    "TODO - remove style transfer 1D hack",
    "Input is 1D but it goes to the width dimension: (1,1,W)",
    "assume (Batch, Channels) - Batch dimension should be dropped",
    "assume (Batch, Sequence-Length, channels)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Add classifier classes (if applicable)",
    "Set pre-processing paramsters",
    "image_input_names,",
    "Return the protobuf spec",
    "model = _MLModel(self.builder.spec)",
    "if IR_node.name in self.weights_dict and 'weights' in self.weights_dict[IR_node.name]:",
    "pass",
    "self._emit_merge(IR_node,'DOT')",
    "Get input and output names",
    "Dimensions and weights",
    "W should have shape (height, width, kernel_channels, output_channels), where kernel_channel = input_channels / groups",
    "Dilations",
    "see protobuf",
    "assert False",
    "Get the weights.",
    "Dilations",
    "see protobuf",
    "depth-wise convolution",
    "Dilations",
    "see protobuf",
    "Get input and output names",
    "Pooling layer type",
    "if it's global, set the global flag",
    "TODO  global pooling modification",
    "Padding",
    "see protobuf",
    "Padding",
    "see protobuf",
    "Get input and output names",
    "type: \"list(int). A 1-D values of (leftBorder, topBorder, rightBorder, bottomBorder).\"",
    "This is central crop",
    "Now add the layer",
    "Allowed values: 'CHW', 'HW', 'C', 'H', 'W'",
    "Get input and output names",
    "Get input and output names",
    "Get the weights from keras",
    "Get input and output names",
    "blob_order == 0 if the input blob needs not be rearranged",
    "blob_order == 1 if the input blob needs to be rearranged",
    "using keras_layer.input.shape have a \"?\" (Dimension[None] at the front),",
    "making a 3D tensor with unknown batch size 4D",
    "Get input and output names",
    "activation emit",
    "Get input and output names",
    "negate it",
    "apply threshold",
    "negate it back",
    "for Keras",
    "Get input and output names",
    "Set parameters",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "padding type TODO",
    "Type of the padding. Can be one of 'constant', 'reflection' or 'replication",
    "Now add the layer",
    "self.emit_Flatten(IR_node)",
    "depth_radius: Half-width of the 1-D normalization window.\"",
    "Get the weights",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "input layer",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "The information of the layer",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "print(node.parameters)",
    "assert False",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "if parent.output_shape.height > 1 or parent.output_shape.width > 1:",
    "TODO: The gamma parameter has to be set (in node.data?) and this should work.",
    "Also, mean should be set to 0, and var to 1, just to be safe.",
    "skip the split node",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For some reason argparser gives us unicode, so we need to conver to str first",
    "for test",
    "with open(\"graph.txt\", 'w') as f:",
    "for layer in self.IR_graph.topological_sort:",
    "current_node = self.IR_graph.get_node(layer)",
    "print(\"========current_node=========\\n{}\".format(current_node.layer), file=f)",
    "test end",
    "print(\"========current_node={}\".format(current_node.layer))",
    "check if have pad layer",
    "Pad_h < kernel_h (vgg19 caffe2caffe)",
    "implement asymmetric paddings by applying symmetric padding then cropping",
    "keys = []",
    "for key in self.weights_dict[IR_node.name].keys():",
    "keys.append(key)",
    "print(\"=======Layer: {}, keys: {}\".format(IR_node.name, keys))",
    "if asymmetric padding, set offset to 1",
    "Change the layer name",
    "check if need crop output shape",
    "change the key \"name\" to \"variable_name\", in case of the layer name has invalid characters",
    "Convert NHWC (IR) to NCHW (Caffe): [0,1,2,3]->[0,3,1,2]",
    "def emit_Square(self, IR_node):",
    "input_layers = ', '.join(('n.' + self.IR_graph.get_node(edge).real_variable_name) for edge in IR_node.in_edges)",
    "self.add_body(1, \"n.{:<15} = L.Square({}, ntop=1)\".format(",
    "IR_node.variable_name,",
    "input_layers))",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "self.graph = NodeRenamer()(graph)",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "assert mapped_node is not None",
    "skip when mapped_node is None",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "try:",
    "except ImportError:",
    "# # Fall back to the protobuf implementation",
    "# from mmdnn.conversion.caffe import caffe_pb2",
    "# self.caffepb = caffe_pb2",
    "# show_fallback_warning()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from tensorflow.core.framework.node_def_pb2 import NodeDef",
    "from tensorflow.core.framework import attr_value_pb2",
    "pass",
    "print(\"\\n\")",
    "print(i)",
    "print(block)",
    "continue",
    "NHWC",
    "assert False",
    "print(shortcut_layer['input'] )",
    "spacetodepth",
    "print(block)",
    "print(region_layer)",
    "assert False",
    "print line",
    "set default value",
    "yolo3(608) start at 1, yolo2(608) start at 0. yolo2(416) start at 1, yolo3(416) start at 0",
    "load weight by original order",
    "print(node_type)",
    "print(IR_node)",
    "assert False",
    "strides",
    "assert False",
    "padding",
    "only load weight conv",
    "print(\"----------------\",self.start)",
    "print(kernel.shape)",
    "print(k_bias.shape)",
    "buf, start, scale_layer['name'], bn_layer['name'], conv_layer['name']",
    "print(\"==============\",self.start)",
    "print(bias.shape)",
    "print(scale.shape)",
    "print(mean.shape)",
    "print(var.shape)",
    "print(kernel.shape)",
    "print(W)",
    "assert False",
    "no use",
    "print(source_node.layer)",
    "for image classification(resnet) AVG pooling",
    "print(source_node.layer)",
    "print(source_node.layer)",
    "kwargs['ignore_thresh'] = source_node.get_attr('ignore_thresh')",
    "print(source_node.get_attr('anchors'))",
    "kwargs['anchors'] = ['0.52','0.22']",
    "kwargs['mask'] = source_node.get_attr('mask')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "tensorflow dump tag",
    "Reference: 1) Keras image preprocess: https://github.com/keras-team/keras/blob/master/keras/applications/imagenet_utils.py",
    "2) tensorflow github issue: https://github.com/tensorflow/models/issues/517",
    "R-G-B for Imagenet === [123.68, 116.78, 103.94]",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load a real image and do default tf imageNet preprocessing",
    "[Batch, Height, Width, Channels] --> [Batch, Channels, Height, Width]",
    "We only deal with non-recurrent networks for now",
    "(H,W,C) --> (C,H,W)",
    "Load TensorFlow model",
    "Prepare inputs",
    "Run TF session",
    "Evaluate coreml model",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "@unittest.skip(\"Failing GPU backend: related to https://github.com/tf-coreml/tf-coreml/issues/26\")",
    "? style transfer image size and style number?",
    "Test predictions on an image",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "compare_tf_coreml_outputs(tf_out_flatten, coreml_out_flatten)",
    "#Download model",
    "url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception_v3_2016_08_28_frozen.pb.tar.gz'",
    "tf_model_dir = _download_file(url = url)",
    "tf_model_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28_frozen.pb')",
    "#Convert to coreml",
    "mlmodel_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28.mlmodel')",
    "mlmodel = tf_converter.convert(",
    "tf_model_path = tf_model_path,",
    "mlmodel_path = mlmodel_path,",
    "output_feature_names = ['InceptionV3/Predictions/Softmax:0'],",
    "input_name_shape_dict = {'input:0':[1,299,299,3]},",
    "image_input_names = ['input:0'],",
    "red_bias = -1,",
    "green_bias = -1,",
    "blue_bias = -1,",
    "image_scale = 2.0/255.0)",
    "#Test predictions on an image",
    "_test_coreml_model_image_input(",
    "tf_model_path = tf_model_path,",
    "coreml_model = mlmodel,",
    "input_tensor_name = 'input:0',",
    "output_tensor_name = 'InceptionV3/Predictions/Softmax:0',",
    "img_size = 299)",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "self.test_truth()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from collections import namedtuple",
    "Batch = namedtuple('Batch', ['data'])",
    "TODO",
    "Apple has published some of their own models. They can be downloaded from https://developer.apple.com/machine-learning/.",
    "Those published models are: SqueezeNet, Places205-GoogLeNet, ResNet50, Inception v3, VGG16",
    "TODO",
    "load model",
    "TODO: Multiple inputs",
    "TODO: Multiple outputs",
    "inference",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "caffe uses NCHW",
    "self.print_intermediate_result('pooling0', False)",
    "delete tmp model files",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "net = caffe.Net(arch_fn, weight_fn, caffe.TEST)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "# Image Classification",
    "# Semantic Segmentation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "print(r)",
    "d = darknet_extractor()",
    "model_filename = d.download('yolov3')",
    "print(model_filename)",
    "image_path = \"./mmdnn/conversion/examples/data/dog.jpg\"",
    "model_path = \"./\"",
    "d = darknet_extractor()",
    "result = d.inference('yolov3', model_filename, model_path, image_path = image_path)",
    "print(result)",
    "print(i)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('pooling0', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "need to be updated",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "raise NotImplementedError()",
    "load file",
    "Using cuDNN since vanilla RNN",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Notes for training NASNet Cifar Model",
    "-------------------------------------",
    "batch_size: 32",
    "learning rate: 0.025",
    "cosine (single period) learning rate decay",
    "auxiliary head loss weighting: 0.4",
    "clip global norm of all gradients by 5",
    "600 epochs with a batch size of 32",
    "This is used for the drop path probabilities since it needs to increase",
    "the drop out probability over the course of training.",
    "Notes for training large NASNet model on ImageNet",
    "-------------------------------------",
    "batch size (per replica): 16",
    "learning rate: 0.015 * 100",
    "learning rate decay factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 100 replicas",
    "auxiliary head loss weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Notes for training the mobile NASNet ImageNet model",
    "-------------------------------------",
    "batch size (per replica): 32",
    "learning rate: 0.04 * 50",
    "learning rate scaling factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 50 replicas",
    "auxiliary head weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Shape of feature map before the final layer.",
    "149 x 149 x 32",
    "Run the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Find where to place the reduction cells or stride normal cells",
    "Setup for building in the auxiliary head.",
    "Run the cells",
    "true_cell_num accounts for the stem cells",
    "Final softmax layer",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 192",
    "35 x 35 x 320",
    "TODO(alemi): Register intermediate endpoints",
    "17 x 17 x 1088 if output_stride == 8,",
    "33 x 33 x 1088 if output_stride == 16",
    "TODO(alemi): register intermediate endpoints",
    "TODO(gpapan): Properly support output_stride for the rest of the net.",
    "8 x 8 x 2080",
    "TODO(alemi): register intermediate endpoints",
    "8 x 8 x 1536",
    "TODO(sguada,arnoegw): Consider adding a parameter global_pool which",
    "can be set to False to disable pooling here (as in resnet_*()).",
    "Set weight_decay for weights in conv2d and fully_connected layers.",
    "Set activation_fn and parameters for batch_norm.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "=============================================================================",
    "Tensorflow mandates these.",
    "Conv and DepthSepConv namedtuple define layers of the MobileNet architecture",
    "Conv defines 3x3 convolution layers",
    "DepthSepConv defines 3x3 depthwise convolution followed by 1x1 convolution.",
    "stride is the stride of the convolution",
    "depth is the number of channels or filters in a layer",
    "_CONV_DEFS specifies the MobileNet body",
    "Used to find thinned depths for each layer.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "By passing filters=None",
    "separable_conv2d produces only a depthwise convolution layer",
    "Global average pooling.",
    "Pooling with a fixed kernel size.",
    "1 x 1 x 1024",
    "Set weight_decay for weights in Conv and DepthSepConv layers.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Skip path 1",
    "Skip path 2",
    "First pad with 0's on the right and bottom, then shift the filter to",
    "include those 0's that were added.",
    "Concat and apply BN",
    "Set the prev layer to the current layer if it is none",
    "Check to be sure prev layer stuff is setup correctly",
    "Apply conv operations",
    "Combine hidden states using 'add'.",
    "Add hiddenstate to the list of hiddenstates we can choose from",
    "Dont stride if this is not one of the original hiddenstates",
    "Check if a stride is needed, then use a strided 1x1 here",
    "Determine if a reduction should be applied to make the number of",
    "filters match.",
    "Return the concat of all the states",
    "Scale keep prob by layer number",
    "The added 2 is for the reduction cells",
    "Decrease the keep probability over time",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Inception-Resnet-A",
    "Inception-Resnet-B",
    "Inception-Resnet-C",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "force in-place updates of mean and variance estimates",
    "Moving averages ends up in the trainable variables collection",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 256",
    "5 x Inception-resnet-A",
    "Reduction-A",
    "10 x Inception-Resnet-B",
    "Reduction-B",
    "5 x Inception-Resnet-C",
    "pylint: disable=no-member",
    "net = slim.fully_connected(net, bottleneck_layer_size, activation_fn=None,",
    "scope='Bottleneck', reuse=False)",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Note: want to round down, we adjust each split to match the total.",
    "We use scope_depthwise, scope_pointwise for compatibility with V1 ckpts.",
    "which provide numbered scopes.",
    "b1 -> b2 * r -> b2",
    "i -> (o * r) (bottleneck) -> o",
    "Note in contrast with expansion, we always have",
    "projection to produce the desired output size.",
    "stride check enforces that we don't add residuals when spatial",
    "dimensions are None",
    "Depth matches",
    "Don't do any splitting if we end up with less than 8 filters",
    "on either side.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Set conv defs defaults and overrides.",
    "a) Set the tensorflow scope",
    "b) set padding to default: note we might consider removing this",
    "since it is also set by mobilenet_scope",
    "c) set all defaults",
    "d) set all extra overrides.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "Insert default parameters before the base scope which includes",
    "any custom overrides set in mobilenet.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "Update params.",
    "Only insert rate to params if rate > 1.",
    "Set padding",
    "Add all tensors that end with 'output' to",
    "endpoints",
    "1 x 1 x num_classes",
    "Note: legacy scope name.",
    "Recover output shape, for unknown shape.",
    "the network created will be trainble with dropout/batch norm",
    "initialized appropriately.",
    "Note: do not introduce parameters that would change the inference",
    "model here (for example whether to use bias), modify conv_def instead.",
    "Set weight_decay for weights in Conv and FC layers.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "pyformat: disable",
    "Architecture: https://arxiv.org/abs/1801.04381",
    "Note: these parameters of batch norm affect the architecture",
    "that's why they are here and not in training_scope.",
    "pyformat: enable",
    "NB: do not set depth_args unless they are provided to avoid overriding",
    "whatever default depth_multiplier might have thanks to arg_scope.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "import self.model",
    "self.model",
    "how the model can not load from `***.bin`",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "the channel of input feature is 3",
    "depth should be one of 20, 32, 44, 56, 110, 1202",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.anchors = np.array([[10,13], [16,30],[33,23],[30,61],[62,45], [59,119],[116,90],[156,198],[373,326]])",
    "print(output)",
    "print(out_boxes, out_scores, out_classes)",
    "get random colors",
    "My kingdom for a good redistributable image drawing library.",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "yolov3 80 classes",
    "Reshape to batch, height, width, num_anchors, box_params.",
    "Adjust preditions to each spatial grid point and anchor size.",
    "Note: YOLO iterates over height index before width index.",
    "TODO: It works with +1, don't know why.",
    "Scale boxes back to original image shape.",
    "print(\"feats,anchors, num_classes, input_shape\", feats, anchors, num_classes, input_shape)",
    "print(box_xy, box_wh, box_confidence, box_class_probs)",
    "yolo_outputs order 13,26,52",
    "TODO: use keras backend instead of tf.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Convert network architecture only",
    "MXNet",
    "Caffe",
    "For CoreML",
    "Caffe",
    "Darknet",
    "exts = ['.pb', '.npy', '.py']",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "We use the real_name for specifying the input layer in data_names",
    "since MXNet API wants the actual name of the layer. On the other",
    "hand, the module API wants the last symbol in the symbol chain, so",
    "for the output node we need to use the actual python variable name",
    "of the last layer (real_variable_name).",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if layout not in MXNetEmitter.channels_last:",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "self.output_weights[IR_node.name + \"_gamma\"] = np.multiply(weight_dict['scale'], weight_dict_scale['scale'])",
    "self.output_weights[IR_node.name + \"_beta\"] = np.multiply(weight_dict['bias'], weight_dict_scale['scale']) + weight_dict_scale['bias']",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "def emit_ConvTranspose(self, IR_node):",
    "if self.weight_loaded:",
    "weight_dict = self.weights[IR_node.name]",
    "weights = weight_dict['weights']",
    "dim = len(IR_node.IR_layer.attr[\"kernel_shape\"].list.i) - 2",
    "kernel = list()",
    "for idx in range(0, dim):",
    "kernel.append(IR_node.IR_layer.attr[\"kernel_shape\"].list.i[idx])",
    "stride = list()",
    "for e in IR_node.IR_layer.attr[\"strides\"].list.i[1:-1]:",
    "stride.append(e)",
    "dilate = list()",
    "for e in IR_node.IR_layer.attr[\"dilations\"].list.i[1:-1]:",
    "dilate.append(e)",
    "dilate = ', '.join('%s' % i for i in dilate)",
    "defuse_pad = False",
    "pad = list()",
    "if \"pads\" in IR_node.IR_layer.attr:",
    "output_shape = list()",
    "for e in IR_node.IR_layer.attr[\"_output_shapes\"].list.shape[0].dim:",
    "output_shape.append(e.size)",
    "# print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "defuse_pad, pad = MXNetEmitter.transfer_pad(IR_node.IR_layer.attr[\"pads\"].list.i)",
    "pad = ', '.join('%s' % i for i in pad)",
    "kernel = ', '.join('%s' % i for i in kernel)",
    "stride = ', '.join('%s' % i for i in stride)",
    "num_filter = IR_node.IR_layer.attr[\"kernel_shape\"].list.i[-2]",
    "no_bias = not IR_node.IR_layer.attr[\"use_bias\"].b",
    "if not no_bias and self.weight_loaded:",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_bias\"] = weight_dict['bias']",
    "# layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NCHW'",
    "elif dim == 3:",
    "layout = 'NCDHW'",
    "if self.weight_loaded:",
    "# if layout not in MXNetEmitter.channels_last:",
    "weights = MXNetEmitter.transpose(weights, dim)",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_weight\"] = weights",
    "code = \"\"",
    "if not defuse_pad:",
    "code = \"{:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), pad = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "kernel,",
    "stride,",
    "dilate,",
    "pad,",
    "num_filter,",
    "no_bias,",
    "layout,",
    "IR_node.replace_scope(IR_node.name))",
    "else:",
    "code = self.set_pad(IR_node, code, pad)",
    "code += \"\\n    {:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name) + \"_pad\", kernel, stride, dilate, num_filter, no_bias, layout, IR_node.replace_scope(IR_node.name))",
    "return code",
    "reverse cannot support yet",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(\"trans\", self.parent_variable_name(IR_node))",
    "save the constant into weight dict",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "Load the model network and weights",
    "digraph = mx.viz.plot_network(sym, save_format='jpg') # For debugging",
    "digraph.render()",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "load the model network",
    "adjust the data format",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "for e in pad:",
    "IR_node.attr[\"pads\"].list.i.extend([e, e])",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "name, op",
    "input edge",
    "units",
    "use bias (no_bias default = False)",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "input edge",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "groups",
    "in_channel = in_channel // group",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "padding",
    "weights",
    "axis",
    "scale",
    "epsilon",
    "momentum",
    "weights",
    "gamma",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "kernel_shape",
    "padding",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "dim",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "weights",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "IR only support elu and prelu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "return",
    "name, op",
    "gamma",
    "input edge",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "alpha",
    "beta",
    "knorm",
    "nsize",
    "keep_prob",
    "mode",
    "reverse cannot support yet",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "dim",
    "dtype",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "axis",
    "raise NotImplementedError(\"No matching IR api\")",
    "left strip the \"_\" at the beginning of the name",
    "Issue #85, #135",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "print(moving_variance.name)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into TensorFlow graph",
    "extract subgraph using in_nodes and dest_nodes",
    "Build network graph",
    "extract subgraph using dest_nodes",
    "Graph Transform",
    "Get input node name",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Matmul Layer",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "print (source_node)",
    "print (source_node.layer)",
    "assert False",
    "def rename_RandomShuffleQueueV2(self, source_node):",
    "# print(source_node.layer)",
    "IR_node = self._convert_identity_operation(source_node, in_edge_count = 0, new_op = 'DataInput')",
    "# IR_node.attr['shape'].shape.MergeFromString(source_node.layer.attr['_output_shapes'].list.shape[0].SerializeToString())",
    "# IR_node.attr['shape'].shape.dim[0].size = -1",
    "IR_node.attr['dtype'].type = self.dtype_map[source_node.layer.attr['component_types'].list.type[0]]",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "TODO: Current it is only for slice",
    "TODO:  only for 1D",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "check whether flatten operator should be added",
    "flatten is needed",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "param_code does not need parameter slice.",
    "skip_prefix = [",
    "\"^\",",
    "\"train_op\",",
    "\"save\",",
    "\"gradients\",",
    "\"init\",",
    "\"global_step\",",
    "\"distort_image\",",
    "\"Adagrad\",",
    "]",
    "\"Switch\"",
    "\"RequantizationRange\",",
    "\"Requantize\",",
    "\"Identity\",",
    "\"Mean\",",
    "\"Cast\"",
    "load model files into TensorFlow graph",
    "Save it to an output file",
    "keep dims",
    "axes",
    "ssd model is transformed",
    "Ax - (Au - b)",
    "A",
    "b",
    "print(sub_content)",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "print(Rsqrt.out_edges)",
    "beta  (bias)",
    "moving mean (mean)",
    "input node",
    "epsilon",
    "beta",
    "gamma (scale)",
    "output_node = self.get_son(source_node.name, [0, 0, 0, 0], True)",
    "assert False",
    "Quantized model type",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "assert variable.get_attr('_output_shapes')[0].dim[0].size == IR_node.attr['kernel_shape'].list.i[-1]",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "In facenet or other newtwork using slim.batch_norm,",
    "There are two BN(train, test) skip switch and merge.",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "beta  (bias)",
    "moving mean (mean)",
    "ReduceMean",
    "keep dims",
    "axes",
    "Skip the node as merge",
    "weights",
    "alpha",
    "beta",
    "Skip BiasAdd",
    "weights",
    "input_node_perm = self.check_const(self.get_parent(source_node.name, [1], True))",
    "paddings",
    "for attr.shape >= 2",
    "For models built by slim.batch_norm, remove duplicate BN (eg.facenet)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "PaddleParser._set_output_shape(source_node, IR_node)",
    "name, op",
    "input edge",
    "For concat axis",
    "only for training",
    "name, op",
    "input edge",
    "input edge",
    "layer and spec",
    "width <=> x or height <=> y",
    "output shape",
    "name, op",
    "it should be in the shape of height x width x inputchannel x outputchannel",
    "use_bias: TODO",
    "pad_dim",
    "fail report because of auto_pad",
    "if dilation_x == 1 and dilation_y == 1:",
    "if output_x * stride_x == input_x and output_y * stride_y == input_y:",
    "auto_pad = \"SAME\"",
    "kwargs['auto_pad'] = auto_pad",
    "elif output_x * stride_x == input_x - width + 1 and output_y * stride_y == input_y - height + 1:",
    "auto_pad = \"VALID\"",
    "kwargs['auto_pad'] = auto_pad",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "channels_first, then axis = 1",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "flatten",
    "mean",
    "var",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "assert False",
    "output shape",
    "pad_dim",
    "padding mode",
    "If padding == \"SAME\": output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])",
    "If padding == \"VALID\": output_spatial_shape[i] = ceil((input_spatial_shape[i] - (spatial_filter_shape[i]-1) * dilation_rate[i]) / strides[i]).",
    "name, op",
    "input edge",
    "layer and spec",
    "units",
    "output shape",
    "use_bias",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "need the shape TODO",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "alpha",
    "beta",
    "nsize",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "TODO: Handle square",
    "self._print_layer(source_node)",
    "print (source_node.name)",
    "print (self.src_graph.get_parent(source_node.name, [0]).real_name)",
    "assert False",
    "Convolution",
    "Kernel",
    "Attributes",
    "Bias",
    "Activation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "BlockFunction node",
    "redirect the composite's inputs to the true inputs",
    "BlockFunctions are short-circuited, and not added to accum[]",
    "Function node",
    "OutputVariable node",
    "def build(self):",
    "_traverse_graph(self, self.model.root_function)",
    "super(CntkGraph, self).build()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "IR_node.get_attr('output_dim'),",
    "??",
    "print(IR_node.layer)",
    "assert False",
    "def emit_Unstack(self, IR_node):",
    "num_str = \"{}.shape[{}]\".format(self.parent_variable_name(IR_node), IR_node.get_attr('axis'))",
    "axis = IR_node.get_attr('axis')",
    "parent_variable_shape = \"list({}.shape)\".format(self.parent_variable_name(IR_node)",
    "if self.IR_graph.get_parent(IR_node.name, [0]).type != 'Embedding'",
    "else self.parent_variable_name(IR_node)+'.E')",
    "if axis==1:",
    "shape_str = \"tuple([{}[0]*{}[{}], 1].extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "else:",
    "shape_str = \"tuple([{}[0]*{}[{}]].extend({}[1:{}]).append(1).extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "code = \"{:<15} = cntk.reshape({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "shape_str,",
    "IR_node.variable_name)",
    "code = \"{: <15} = cntk.reshape({}, {}.shape, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name",
    ")",
    "return code",
    "def emit_Fill(self, IR_node):",
    "code = \"{:<15} = cntk.Constant({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "IR_node.get_attr('value'),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name)",
    "return code",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "network library",
    "not support multi-threads download",
    "key: layer_name    value: keras layer",
    "private functions",
    "next_node_info.left_in_edges -= 1",
    "print ('{} --> {}'.format(src, dst))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "If pattern.inputs is empty, skips the rest and accepts all the inputs.",
    "If order doesn't matter for the inputs, then make sure we match at least",
    "one permutation of the inputs.",
    "def get_tensor(self, pattern_or_name):",
    "op_tensor = self._get_op_tensor(pattern_or_name)",
    "return op_tensor[1] if op_tensor else None",
    "pylint: disable=protected-access",
    "pylint: enable=protected-access",
    "Python 3.3.2+ implements `yield from`, but for now:",
    "check the same pattern scope node whether have same inputs, outputs and weights.",
    "For those don't have, rename their scope names.",
    "clear out scope node, typically input constant node.",
    "get sub_scopes",
    "decline the suffix number",
    "Obtain nodes where the scope name that satisfies top_level is top_scope and sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in top_level is top_scope",
    "Obtain all nodes grouped by sub_level sub_scope",
    "cover the node",
    "store idx, node into a dict and sort it later to keep its topology sort.",
    "in_node's out edges replace n_name with scope node name.",
    "no out nodes means the last node in scope nodes should be returned",
    "if out_node is scope node, replace the scope node's inner topology list node.",
    "the input parameter shoule be sliced when call func.",
    "modify the in_edges in scope inner nodes. decline the :idx.",
    "1. initilize scope node",
    "2. get scope nodes' topology list.",
    "3. rebuild the edges connection after folding these scope nodes into one node and",
    "get this scope node's return variables.",
    "4. rebuild graph.",
    "RNN-related attrs.",
    "get input params",
    "self.store_const_to_top(result)",
    "self.set_top_node_prop(result, pattern_name)",
    "Do not include input op.",
    "TODO: pytorch, mxnet, keras, cntk",
    "-*- coding: utf-8 -*-",
    "from keras.layers.core import Layer",
    "Arguments",
    "Input shape",
    "Output shape",
    "Prepare broadcasting shape.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "Keras 2.1.6",
    "Keras. 2.2.2",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "size",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "weights",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "for target shape",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot weights",
    "print(\"Converting layer {}({})\".format(current_node.name, node_type))",
    "TODO",
    "return input_node, 'same'",
    "assert IR_node.get_attr('group', 1) == 1",
    "change dw from filters to 1",
    "reset the default dilation",
    "############",
    "Operators #",
    "############",
    "code = self._emit_merge(IR_node, \"subtract\")",
    "TODO",
    "when converting from coreml model, reshape is needed after the global pooling",
    "for Keras",
    "It arouses some problems:",
    "it can be implemented by Lambda Layer",
    "https://github.com/keras-team/keras/issues/890",
    "Keras == 2.1.6",
    "Keras == 2.2.2",
    "TODO: arguments won't be saved in keras export model",
    "param_code does not need parameter slice.",
    "Prepare broadcasting shape.",
    "output = Lambda(lambda x: tf.fill(x, value))(input)",
    "return output",
    "def _layer_Constant(self):",
    "self.add_body(0, '''",
    "class my_constant(keras.layers.Layer):",
    "def __init__(self, value, **kwargs):",
    "super(my_constant, self).__init__(**kwargs)",
    "self._value = value",
    "# the input is dummy, just for creating keras graph.",
    "def call(self, dummy):",
    "res = K.constant(self._value)",
    "self.output_shapes = K.int_shape(res)",
    "return res",
    "def compute_output_shape(self, input_shape):",
    "return self.output_shapes",
    "''')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "with open('modelmapbydataset.json', 'w') as outfile:",
    "json.dump(new_data, outfile)",
    "generate makedown script",
    "add Image Classification",
    "add Object Detection",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "generate makedown script",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "remove list",
    "draw",
    "mode;",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "rm the '_'",
    "Base64 encode: https://developers.google.com/protocol-buffers/docs/proto3",
    "Search the node",
    "select by id: https://stackoverflow.com/questions/37270787/uncaught-syntaxerror-failed-to-execute-queryselector-on-document",
    "Scroll",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ],
  "0.2.4": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "Communication to TensorFlow server via gRPC",
    "TensorFlow serving stuff to send messages",
    "Command line arguments",
    "Send request",
    "request.inputs['input'].CopyFrom()",
    "'xception'     : [TestModels.onnx_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "omit tensorflow lead to crash",
    "'nasnet-a_large'       : [TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'inception_resnet_v2'  : [TestModels.caffe_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "Function self.assertEquals has deprecated, change to assertEqual",
    "self.assertEqual(original_predict.shape, converted_predict.shape)",
    "get original model prediction result",
    "original to IR",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "print(original_predict)",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "get shape",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "IR to code",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "The list is in RGB oder",
    "IR to Model",
    "converted_file = original_framework + '_coreml_' + architecture_name + \"_converted\"",
    "converted_file = converted_file.replace('.', '_')",
    "load model",
    "save model",
    "coremltools.utils.save_spec(model.get_spec(), converted_file)",
    "inference",
    "IR to code",
    "import converted model",
    "In case of odd number add the extra padding at the end for SAME_UPPER(eg. pads:[0, 2, 2, 0, 0, 3, 3, 0]) and at the beginning for SAME_LOWER(eg. pads:[0, 3, 3, 0, 0, 2, 2, 0])",
    "'xception'     : [onnx_emit],",
    "'nasnet'       : [onnx_emit],",
    "'voc-fcn8s'     : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn16s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn32s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'resnet_v1_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v1_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'nasnet-a_large'        : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "TODO: coredump",
    "'alexnet'       : [cntk_emit, keras_emit, tensorflow_emit],",
    "'nasnet'       : [tensorflow_emit, keras_emit, coreml_emit],",
    "'facenet'      : [tensorflow_emit, coreml_emit,mxnet_emit,keras_emit]  # TODO",
    "'vgg16': [tensorflow_emit],",
    "'alexnet': [tensorflow_emit]",
    "get original model prediction result",
    "def test_caffe(self):",
    "try:",
    "import caffe",
    "self._test_function('caffe', self.caffe_parse)",
    "except ImportError:",
    "print('Please install caffe! Or caffe is not supported in your platform.', file=sys.stderr)",
    "def test_cntk(self):",
    "try:",
    "import cntk",
    "self._test_function('cntk', self.cntk_parse)",
    "except ImportError:",
    "print('Please install cntk! Or cntk is not supported in your platform.', file=sys.stderr)",
    "def test_coreml(self):",
    "from coremltools.models.utils import macos_version",
    "if macos_version() < (10, 13):",
    "print('Coreml is not supported in your platform.', file=sys.stderr)",
    "else:",
    "self._test_function('coreml', self.coreml_parse)",
    "def test_keras(self):",
    "self._test_function('keras', self.keras_parse)",
    "def test_mxnet(self):",
    "self._test_function('mxnet', self.mxnet_parse)",
    "def test_darknet(self):",
    "self._test_function('darknet', self.darknet_parse)",
    "def test_paddle(self):",
    "# omit tensorflow lead to crash",
    "import tensorflow as tf",
    "try:",
    "import paddle.v2 as paddle",
    "self._test_function('paddle', self.paddle_parse)",
    "except ImportError:",
    "print('Please install Paddlepaddle! Or Paddlepaddle is not supported in your platform.', file=sys.stderr)",
    "def test_pytorch(self):",
    "self._test_function('pytorch', self.pytorch_parse)",
    "def test_tensorflow(self):",
    "self._test_function('tensorflow', self.tensorflow_parse)",
    "def test_tensorflow_frozen(self):",
    "self._test_function('tensorflow_frozen', self.tensorflow_frozen_parse)",
    "'vgg19'         : [TestModels.onnx_emit],",
    "'voc-fcn8s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'vgg19'         : [TestModels.caffe_emit, TestModels.cntk_emit, TestModels.coreml_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'voc-fcn8s'     : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'voc-fcn16s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'voc-fcn32s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "'vgg19'         : [TestModels.onnx_emit],",
    "'alexnet'       : [TestModels.caffe_emit, TestModels.cntk_emit, TestModels.coreml_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'nasnet-a_large'       : [TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'inception_resnet_v2'  : [TestModels.caffe_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'xception'     : [TestModels.onnx_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "!/usr/bin/python",
    "major python major_python_versions as python2 and python3",
    "operating system",
    "do not deal",
    "I don't want to deal with auto_pad",
    "Don't support auto_pad current!",
    "2018-02-28",
    "if group is None:",
    "group = 1",
    "group is not support yet too.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "node",
    "input",
    "edge(node a <-> node b)",
    "",
    "key is edge name, value is src/dst node name",
    "key is initializer name, value is TensorProto",
    "print(name)",
    "print(layer.op_type)",
    "n is input data",
    "n is input edge",
    "omit node of some type",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "if node len(in_edges), generate additional DataInput node",
    "print",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "TODO",
    "'max_pool2d': convert_maxpool,",
    "'onnx::Mul': convert_elementwise_mul,",
    "'onnx::Sub': convert_elementwise_sub,",
    "'onnx::ConvTranspose': convert_convtranspose,",
    "'onnx::LeakyRelu': convert_lrelu,",
    "'onnx::Sigmoid': convert_sigmoid,",
    "'onnx::Softmax': convert_softmax,",
    "'onnx::Selu': convert_selu,",
    "'onnx::Transpose': convert_transpose,",
    "'onnx::Reshape': convert_reshape,",
    "'onnx::MatMul': convert_matmul,",
    "'onnx::Gather': convert_gather,",
    "'onnx::ReduceSum': convert_reduce_sum,",
    "'onnx::Constant': convert_constant,",
    "'onnx::Upsample': convert_upsample,",
    "'onnx::Pad': convert_padding,",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "test",
    "cpu: https://github.com/pytorch/pytorch/issues/5286",
    "Build network graph",
    "(batch, C, H, W)  & NHWC",
    "#########",
    "Layers #",
    "#########",
    "dilation",
    "handle bias",
    "TODO",
    "output_shape",
    "epsilon",
    "mean",
    "var",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "use_bias",
    "units",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Scopes created in a nested scope may have initial characters",
    "that are illegal as the initial character of an op name",
    "(viz. '-', '\\', '/', and '_').",
    "sanity check.",
    "run dce first to eliminate dead parts of the graph that might have been",
    "left behind by things like symbolic_override",
    "construct graph",
    "nodes",
    "input layer",
    "TODO",
    "build each layer",
    "input",
    "print(node_input_name ,'->', node_name)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "padding,",
    "exstr = \", value=float('-Inf')\"",
    "exstr = \"\"",
    "Change to padding defuse",
    "input_node = self._defuse_padding(IR_node, exstr)",
    "Ignore it in Pytorch",
    "for Keras",
    "self.add_init(2, \"self.{:<15} = torch.from_numpy(__weights_dict['{}']['value'])\".format(",
    "IR_node.variable_name,",
    "IR_node.name))",
    "param_code does not need parameter slice.",
    "from torch.nn.parameter import Parameter",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._type = layer.__class__.__name__.replace('Backward', '')",
    "self._name = \"{}_{}\".format(self.type, id)",
    "TODO",
    "\"\"\"",
    "build graph for pytorch 0.2.0",
    "\"\"\"",
    "dummy_input = torch.autograd.Variable(torch.randn(shape))",
    "output_node = self.model(dummy_input)",
    "search_queue = [output_node.grad_fn]",
    "tmp_node = PyTorchGraphNode(output_node.grad_fn, 0)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "visited = {output_node.grad_fn : self.layer_map[tmp_node.name]}",
    "idx = 0",
    "node_count = 1",
    "while (idx < len(search_queue)):",
    "current_node = search_queue[idx]",
    "current_type = visited[current_node].type",
    "if hasattr(current_node, 'next_functions'):",
    "for parent, _ in current_node.next_functions:",
    "parent_type = parent.__class__.__name__.replace('Backward', '')",
    "if parent_type != 'AccumulateGrad' and \\",
    "(parent_type != 'Transpose' or current_type != 'Addmm'):",
    "if not parent in visited:",
    "tmp_node = PyTorchGraphNode(parent, node_count)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "node_count += 1",
    "visited[parent] = tmp_node",
    "search_queue.append(parent)",
    "self._make_connection(visited[parent].name, visited[current_node].name)",
    "idx += 1",
    "try:",
    "return TorchGraph._forward_torch_random_input(",
    "torch_model,",
    "input_shapes,",
    "is_batch=False",
    ")",
    "except:",
    "# try batch mode",
    "# return TorchGraph._forward_torch_random_input(",
    "#     torch_model,",
    "#     input_shapes,",
    "#     is_batch=True",
    "# )",
    "pass",
    "tensor = torch.rand(*shape).float()",
    "multi output",
    "single output",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "Build network graph",
    "#########",
    "Layers #",
    "#########",
    "handle weight",
    "handle bias",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "load model file into Coreml Graph",
    "model.encode() convert to str --- python2 may crash due to type 'unicode'",
    "Build Network Graph",
    "self.data_format ? TODO",
    "load the model network",
    "convert to Model_pb2.Model",
    "determine the type of the current_node",
    "staticmethods",
    "(seq, batch, C, H, W)  & NHWC",
    "TODO dtype_map",
    "##### convert methods",
    "convolution",
    "input edge",
    "important!",
    "reshape the weight!",
    "[2, 3, 0, 1]",
    "pads",
    "use_bias",
    "isDeconvolution",
    "name, op",
    "kwargs['kernel_shape'] = weights.shape",
    "strides",
    "[1, sd, sh, sw, 1]",
    "activation",
    "TODO",
    "padding in conv",
    "pad in IR is [x1_b, x2_b, ..., x1_e, x2_e, ...]",
    "padding",
    "compute padding for 'same'",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "https://www.jianshu.com/p/05c4f1621c7e",
    "padding in pooling",
    "padding",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "TODO",
    "symmetric padding",
    "name, op",
    "input edge",
    "For concat axis",
    "NO axis in coreml, so set the last axis",
    "The first -1 means in coreml there is one-more axis,",
    "The second -1 means the last axis",
    "name, op",
    "input edge",
    "padding",
    "Future Module TODO",
    "#### rename methods",
    "name, op",
    "activation type",
    "else:",
    "assert False",
    "input edge",
    "Merge layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "NHWC channel last",
    "in fact, here is NWHC",
    "name, op",
    "input edge",
    "axis TODO",
    "channels_first, then axis = 1",
    "scale",
    "bias",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "mean",
    "var",
    "name, op",
    "input edge",
    "bias",
    "name, op",
    "input edge",
    "MAX = 0, AVERAGE = 1, L2 = 2",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "change to single because of the tf matmul",
    "name, op",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "the end of the tensorflow_resnet_v2_50's squeeze shape is [unknown_rank: true] with len 0",
    "1001 means the 1001 classes for tensorflow_resnet_v2_50",
    "!Alert! TODO",
    "Future implement can be changed to the last two layer",
    "TODO - remove style transfer 1D hack",
    "Input is 1D but it goes to the width dimension: (1,1,W)",
    "assume (Batch, Channels) - Batch dimension should be dropped",
    "assume (Batch, Sequence-Length, channels)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Add classifier classes (if applicable)",
    "Set pre-processing paramsters",
    "image_input_names,",
    "Return the protobuf spec",
    "model = _MLModel(self.builder.spec)",
    "if IR_node.name in self.weights_dict and 'weights' in self.weights_dict[IR_node.name]:",
    "pass",
    "self._emit_merge(IR_node,'DOT')",
    "Get input and output names",
    "Dimensions and weights",
    "W should have shape (height, width, kernel_channels, output_channels), where kernel_channel = input_channels / groups",
    "Dilations",
    "see protobuf",
    "assert False",
    "Get the weights.",
    "Dilations",
    "see protobuf",
    "depth-wise convolution",
    "Dilations",
    "see protobuf",
    "Get input and output names",
    "Pooling layer type",
    "if it's global, set the global flag",
    "TODO  global pooling modification",
    "Padding",
    "see protobuf",
    "Padding",
    "see protobuf",
    "Get input and output names",
    "type: \"list(int). A 1-D values of (leftBorder, topBorder, rightBorder, bottomBorder).\"",
    "This is central crop",
    "Now add the layer",
    "Allowed values: 'CHW', 'HW', 'C', 'H', 'W'",
    "Get input and output names",
    "Get input and output names",
    "Get the weights from keras",
    "Get input and output names",
    "blob_order == 0 if the input blob needs not be rearranged",
    "blob_order == 1 if the input blob needs to be rearranged",
    "using keras_layer.input.shape have a \"?\" (Dimension[None] at the front),",
    "making a 3D tensor with unknown batch size 4D",
    "Get input and output names",
    "activation emit",
    "Get input and output names",
    "negate it",
    "apply threshold",
    "negate it back",
    "for Keras",
    "Get input and output names",
    "Set parameters",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "padding type TODO",
    "Type of the padding. Can be one of 'constant', 'reflection' or 'replication",
    "Now add the layer",
    "self.emit_Flatten(IR_node)",
    "depth_radius: Half-width of the 1-D normalization window.\"",
    "Get the weights",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "input layer",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "The information of the layer",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "print(node.parameters)",
    "assert False",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "if parent.output_shape.height > 1 or parent.output_shape.width > 1:",
    "TODO: The gamma parameter has to be set (in node.data?) and this should work.",
    "Also, mean should be set to 0, and var to 1, just to be safe.",
    "skip the split node",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For some reason argparser gives us unicode, so we need to conver to str first",
    "for test",
    "with open(\"graph.txt\", 'w') as f:",
    "for layer in self.IR_graph.topological_sort:",
    "current_node = self.IR_graph.get_node(layer)",
    "print(\"========current_node=========\\n{}\".format(current_node.layer), file=f)",
    "test end",
    "print(\"========current_node={}\".format(current_node.layer))",
    "check if have pad layer",
    "Pad_h < kernel_h (vgg19 caffe2caffe)",
    "implement asymmetric paddings by applying symmetric padding then cropping",
    "keys = []",
    "for key in self.weights_dict[IR_node.name].keys():",
    "keys.append(key)",
    "print(\"=======Layer: {}, keys: {}\".format(IR_node.name, keys))",
    "if asymmetric padding, set offset to 1",
    "Change the layer name",
    "check if need crop output shape",
    "change the key \"name\" to \"variable_name\", in case of the layer name has invalid characters",
    "Convert NHWC (IR) to NCHW (Caffe): [0,1,2,3]->[0,3,1,2]",
    "def emit_Square(self, IR_node):",
    "input_layers = ', '.join(('n.' + self.IR_graph.get_node(edge).real_variable_name) for edge in IR_node.in_edges)",
    "self.add_body(1, \"n.{:<15} = L.Square({}, ntop=1)\".format(",
    "IR_node.variable_name,",
    "input_layers))",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "self.graph = NodeRenamer()(graph)",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "assert mapped_node is not None",
    "skip when mapped_node is None",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "try:",
    "except ImportError:",
    "# # Fall back to the protobuf implementation",
    "# from mmdnn.conversion.caffe import caffe_pb2",
    "# self.caffepb = caffe_pb2",
    "# show_fallback_warning()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from tensorflow.core.framework.node_def_pb2 import NodeDef",
    "from tensorflow.core.framework import attr_value_pb2",
    "pass",
    "print(\"\\n\")",
    "print(i)",
    "print(block)",
    "continue",
    "NHWC",
    "assert False",
    "print(shortcut_layer['input'] )",
    "spacetodepth",
    "print(block)",
    "print(region_layer)",
    "assert False",
    "print line",
    "set default value",
    "yolo3(608) start at 1, yolo2(608) start at 0. yolo2(416) start at 1, yolo3(416) start at 0",
    "load weight by original order",
    "print(node_type)",
    "print(IR_node)",
    "assert False",
    "strides",
    "assert False",
    "padding",
    "only load weight conv",
    "print(\"----------------\",self.start)",
    "print(kernel.shape)",
    "print(k_bias.shape)",
    "buf, start, scale_layer['name'], bn_layer['name'], conv_layer['name']",
    "print(\"==============\",self.start)",
    "print(bias.shape)",
    "print(scale.shape)",
    "print(mean.shape)",
    "print(var.shape)",
    "print(kernel.shape)",
    "print(W)",
    "assert False",
    "no use",
    "print(source_node.layer)",
    "for image classification(resnet) AVG pooling",
    "print(source_node.layer)",
    "print(source_node.layer)",
    "kwargs['ignore_thresh'] = source_node.get_attr('ignore_thresh')",
    "print(source_node.get_attr('anchors'))",
    "kwargs['anchors'] = ['0.52','0.22']",
    "kwargs['mask'] = source_node.get_attr('mask')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "tensorflow dump tag",
    "Reference: 1) Keras image preprocess: https://github.com/keras-team/keras/blob/master/keras/applications/imagenet_utils.py",
    "2) tensorflow github issue: https://github.com/tensorflow/models/issues/517",
    "R-G-B for Imagenet === [123.68, 116.78, 103.94]",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load a real image and do default tf imageNet preprocessing",
    "[Batch, Height, Width, Channels] --> [Batch, Channels, Height, Width]",
    "We only deal with non-recurrent networks for now",
    "(H,W,C) --> (C,H,W)",
    "Load TensorFlow model",
    "Prepare inputs",
    "Run TF session",
    "Evaluate coreml model",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "@unittest.skip(\"Failing GPU backend: related to https://github.com/tf-coreml/tf-coreml/issues/26\")",
    "? style transfer image size and style number?",
    "Test predictions on an image",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "compare_tf_coreml_outputs(tf_out_flatten, coreml_out_flatten)",
    "#Download model",
    "url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception_v3_2016_08_28_frozen.pb.tar.gz'",
    "tf_model_dir = _download_file(url = url)",
    "tf_model_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28_frozen.pb')",
    "#Convert to coreml",
    "mlmodel_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28.mlmodel')",
    "mlmodel = tf_converter.convert(",
    "tf_model_path = tf_model_path,",
    "mlmodel_path = mlmodel_path,",
    "output_feature_names = ['InceptionV3/Predictions/Softmax:0'],",
    "input_name_shape_dict = {'input:0':[1,299,299,3]},",
    "image_input_names = ['input:0'],",
    "red_bias = -1,",
    "green_bias = -1,",
    "blue_bias = -1,",
    "image_scale = 2.0/255.0)",
    "#Test predictions on an image",
    "_test_coreml_model_image_input(",
    "tf_model_path = tf_model_path,",
    "coreml_model = mlmodel,",
    "input_tensor_name = 'input:0',",
    "output_tensor_name = 'InceptionV3/Predictions/Softmax:0',",
    "img_size = 299)",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "self.test_truth()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from collections import namedtuple",
    "Batch = namedtuple('Batch', ['data'])",
    "TODO",
    "Apple has published some of their own models. They can be downloaded from https://developer.apple.com/machine-learning/.",
    "Those published models are: SqueezeNet, Places205-GoogLeNet, ResNet50, Inception v3, VGG16",
    "TODO",
    "load model",
    "TODO: Multiple inputs",
    "TODO: Multiple outputs",
    "inference",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "caffe uses NCHW",
    "self.print_intermediate_result('pooling0', False)",
    "delete tmp model files",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "net = caffe.Net(arch_fn, weight_fn, caffe.TEST)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "# Image Classification",
    "# Semantic Segmentation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "print(r)",
    "d = darknet_extractor()",
    "model_filename = d.download('yolov3')",
    "print(model_filename)",
    "image_path = \"./mmdnn/conversion/examples/data/dog.jpg\"",
    "model_path = \"./\"",
    "d = darknet_extractor()",
    "result = d.inference('yolov3', model_filename, model_path, image_path = image_path)",
    "print(result)",
    "print(i)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('pooling0', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "need to be updated",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "raise NotImplementedError()",
    "load file",
    "Using cuDNN since vanilla RNN",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Notes for training NASNet Cifar Model",
    "-------------------------------------",
    "batch_size: 32",
    "learning rate: 0.025",
    "cosine (single period) learning rate decay",
    "auxiliary head loss weighting: 0.4",
    "clip global norm of all gradients by 5",
    "600 epochs with a batch size of 32",
    "This is used for the drop path probabilities since it needs to increase",
    "the drop out probability over the course of training.",
    "Notes for training large NASNet model on ImageNet",
    "-------------------------------------",
    "batch size (per replica): 16",
    "learning rate: 0.015 * 100",
    "learning rate decay factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 100 replicas",
    "auxiliary head loss weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Notes for training the mobile NASNet ImageNet model",
    "-------------------------------------",
    "batch size (per replica): 32",
    "learning rate: 0.04 * 50",
    "learning rate scaling factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 50 replicas",
    "auxiliary head weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Shape of feature map before the final layer.",
    "149 x 149 x 32",
    "Run the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Find where to place the reduction cells or stride normal cells",
    "Setup for building in the auxiliary head.",
    "Run the cells",
    "true_cell_num accounts for the stem cells",
    "Final softmax layer",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 192",
    "35 x 35 x 320",
    "TODO(alemi): Register intermediate endpoints",
    "17 x 17 x 1088 if output_stride == 8,",
    "33 x 33 x 1088 if output_stride == 16",
    "TODO(alemi): register intermediate endpoints",
    "TODO(gpapan): Properly support output_stride for the rest of the net.",
    "8 x 8 x 2080",
    "TODO(alemi): register intermediate endpoints",
    "8 x 8 x 1536",
    "TODO(sguada,arnoegw): Consider adding a parameter global_pool which",
    "can be set to False to disable pooling here (as in resnet_*()).",
    "Set weight_decay for weights in conv2d and fully_connected layers.",
    "Set activation_fn and parameters for batch_norm.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "=============================================================================",
    "Tensorflow mandates these.",
    "Conv and DepthSepConv namedtuple define layers of the MobileNet architecture",
    "Conv defines 3x3 convolution layers",
    "DepthSepConv defines 3x3 depthwise convolution followed by 1x1 convolution.",
    "stride is the stride of the convolution",
    "depth is the number of channels or filters in a layer",
    "_CONV_DEFS specifies the MobileNet body",
    "Used to find thinned depths for each layer.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "By passing filters=None",
    "separable_conv2d produces only a depthwise convolution layer",
    "Global average pooling.",
    "Pooling with a fixed kernel size.",
    "1 x 1 x 1024",
    "Set weight_decay for weights in Conv and DepthSepConv layers.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Skip path 1",
    "Skip path 2",
    "First pad with 0's on the right and bottom, then shift the filter to",
    "include those 0's that were added.",
    "Concat and apply BN",
    "Set the prev layer to the current layer if it is none",
    "Check to be sure prev layer stuff is setup correctly",
    "Apply conv operations",
    "Combine hidden states using 'add'.",
    "Add hiddenstate to the list of hiddenstates we can choose from",
    "Dont stride if this is not one of the original hiddenstates",
    "Check if a stride is needed, then use a strided 1x1 here",
    "Determine if a reduction should be applied to make the number of",
    "filters match.",
    "Return the concat of all the states",
    "Scale keep prob by layer number",
    "The added 2 is for the reduction cells",
    "Decrease the keep probability over time",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Inception-Resnet-A",
    "Inception-Resnet-B",
    "Inception-Resnet-C",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "force in-place updates of mean and variance estimates",
    "Moving averages ends up in the trainable variables collection",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 256",
    "5 x Inception-resnet-A",
    "Reduction-A",
    "10 x Inception-Resnet-B",
    "Reduction-B",
    "5 x Inception-Resnet-C",
    "pylint: disable=no-member",
    "net = slim.fully_connected(net, bottleneck_layer_size, activation_fn=None,",
    "scope='Bottleneck', reuse=False)",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Note: want to round down, we adjust each split to match the total.",
    "We use scope_depthwise, scope_pointwise for compatibility with V1 ckpts.",
    "which provide numbered scopes.",
    "b1 -> b2 * r -> b2",
    "i -> (o * r) (bottleneck) -> o",
    "Note in contrast with expansion, we always have",
    "projection to produce the desired output size.",
    "stride check enforces that we don't add residuals when spatial",
    "dimensions are None",
    "Depth matches",
    "Don't do any splitting if we end up with less than 8 filters",
    "on either side.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Set conv defs defaults and overrides.",
    "a) Set the tensorflow scope",
    "b) set padding to default: note we might consider removing this",
    "since it is also set by mobilenet_scope",
    "c) set all defaults",
    "d) set all extra overrides.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "Insert default parameters before the base scope which includes",
    "any custom overrides set in mobilenet.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "Update params.",
    "Only insert rate to params if rate > 1.",
    "Set padding",
    "Add all tensors that end with 'output' to",
    "endpoints",
    "1 x 1 x num_classes",
    "Note: legacy scope name.",
    "Recover output shape, for unknown shape.",
    "the network created will be trainble with dropout/batch norm",
    "initialized appropriately.",
    "Note: do not introduce parameters that would change the inference",
    "model here (for example whether to use bias), modify conv_def instead.",
    "Set weight_decay for weights in Conv and FC layers.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "pyformat: disable",
    "Architecture: https://arxiv.org/abs/1801.04381",
    "Note: these parameters of batch norm affect the architecture",
    "that's why they are here and not in training_scope.",
    "pyformat: enable",
    "NB: do not set depth_args unless they are provided to avoid overriding",
    "whatever default depth_multiplier might have thanks to arg_scope.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "import self.model",
    "self.model",
    "how the model can not load from `***.bin`",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "the channel of input feature is 3",
    "depth should be one of 20, 32, 44, 56, 110, 1202",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.anchors = np.array([[10,13], [16,30],[33,23],[30,61],[62,45], [59,119],[116,90],[156,198],[373,326]])",
    "print(output)",
    "print(out_boxes, out_scores, out_classes)",
    "get random colors",
    "My kingdom for a good redistributable image drawing library.",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "yolov3 80 classes",
    "Reshape to batch, height, width, num_anchors, box_params.",
    "Adjust preditions to each spatial grid point and anchor size.",
    "Note: YOLO iterates over height index before width index.",
    "TODO: It works with +1, don't know why.",
    "Scale boxes back to original image shape.",
    "print(\"feats,anchors, num_classes, input_shape\", feats, anchors, num_classes, input_shape)",
    "print(box_xy, box_wh, box_confidence, box_class_probs)",
    "yolo_outputs order 13,26,52",
    "TODO: use keras backend instead of tf.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Convert network architecture only",
    "MXNet",
    "Caffe",
    "For CoreML",
    "Caffe",
    "Darknet",
    "exts = ['.pb', '.npy', '.py']",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "We use the real_name for specifying the input layer in data_names",
    "since MXNet API wants the actual name of the layer. On the other",
    "hand, the module API wants the last symbol in the symbol chain, so",
    "for the output node we need to use the actual python variable name",
    "of the last layer (real_variable_name).",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if layout not in MXNetEmitter.channels_last:",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "def emit_ConvTranspose(self, IR_node):",
    "if self.weight_loaded:",
    "weight_dict = self.weights[IR_node.name]",
    "weights = weight_dict['weights']",
    "dim = len(IR_node.IR_layer.attr[\"kernel_shape\"].list.i) - 2",
    "kernel = list()",
    "for idx in range(0, dim):",
    "kernel.append(IR_node.IR_layer.attr[\"kernel_shape\"].list.i[idx])",
    "stride = list()",
    "for e in IR_node.IR_layer.attr[\"strides\"].list.i[1:-1]:",
    "stride.append(e)",
    "dilate = list()",
    "for e in IR_node.IR_layer.attr[\"dilations\"].list.i[1:-1]:",
    "dilate.append(e)",
    "dilate = ', '.join('%s' % i for i in dilate)",
    "defuse_pad = False",
    "pad = list()",
    "if \"pads\" in IR_node.IR_layer.attr:",
    "output_shape = list()",
    "for e in IR_node.IR_layer.attr[\"_output_shapes\"].list.shape[0].dim:",
    "output_shape.append(e.size)",
    "# print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "defuse_pad, pad = MXNetEmitter.transfer_pad(IR_node.IR_layer.attr[\"pads\"].list.i)",
    "pad = ', '.join('%s' % i for i in pad)",
    "kernel = ', '.join('%s' % i for i in kernel)",
    "stride = ', '.join('%s' % i for i in stride)",
    "num_filter = IR_node.IR_layer.attr[\"kernel_shape\"].list.i[-2]",
    "no_bias = not IR_node.IR_layer.attr[\"use_bias\"].b",
    "if not no_bias and self.weight_loaded:",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_bias\"] = weight_dict['bias']",
    "# layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NCHW'",
    "elif dim == 3:",
    "layout = 'NCDHW'",
    "if self.weight_loaded:",
    "# if layout not in MXNetEmitter.channels_last:",
    "weights = MXNetEmitter.transpose(weights, dim)",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_weight\"] = weights",
    "code = \"\"",
    "if not defuse_pad:",
    "code = \"{:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), pad = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "kernel,",
    "stride,",
    "dilate,",
    "pad,",
    "num_filter,",
    "no_bias,",
    "layout,",
    "IR_node.replace_scope(IR_node.name))",
    "else:",
    "code = self.set_pad(IR_node, code, pad)",
    "code += \"\\n    {:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name) + \"_pad\", kernel, stride, dilate, num_filter, no_bias, layout, IR_node.replace_scope(IR_node.name))",
    "return code",
    "reverse cannot support yet",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(\"trans\", self.parent_variable_name(IR_node))",
    "save the constant into weight dict",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "Load the model network and weights",
    "digraph = mx.viz.plot_network(sym, save_format='jpg') # For debugging",
    "digraph.render()",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "load the model network",
    "adjust the data format",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "for e in pad:",
    "IR_node.attr[\"pads\"].list.i.extend([e, e])",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "name, op",
    "input edge",
    "units",
    "use bias (no_bias default = False)",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "input edge",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "groups",
    "in_channel = in_channel // group",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "padding",
    "weights",
    "axis",
    "scale",
    "epsilon",
    "momentum",
    "weights",
    "gamma",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "kernel_shape",
    "padding",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "dim",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "weights",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "IR only support elu and prelu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "return",
    "name, op",
    "gamma",
    "input edge",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "alpha",
    "beta",
    "knorm",
    "nsize",
    "keep_prob",
    "mode",
    "reverse cannot support yet",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "dim",
    "dtype",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "axis",
    "raise NotImplementedError(\"No matching IR api\")",
    "left strip the \"_\" at the beginning of the name",
    "Issue #85, #135",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "print(moving_variance.name)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into TensorFlow graph",
    "extract subgraph using in_nodes and dest_nodes",
    "Build network graph",
    "extract subgraph using dest_nodes",
    "Graph Transform",
    "Get input node name",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Matmul Layer",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "print (source_node)",
    "print (source_node.layer)",
    "assert False",
    "def rename_RandomShuffleQueueV2(self, source_node):",
    "# print(source_node.layer)",
    "IR_node = self._convert_identity_operation(source_node, in_edge_count = 0, new_op = 'DataInput')",
    "# IR_node.attr['shape'].shape.MergeFromString(source_node.layer.attr['_output_shapes'].list.shape[0].SerializeToString())",
    "# IR_node.attr['shape'].shape.dim[0].size = -1",
    "IR_node.attr['dtype'].type = self.dtype_map[source_node.layer.attr['component_types'].list.type[0]]",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "TODO: Current it is only for slice",
    "TODO:  only for 1D",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "check whether flatten operator should be added",
    "flatten is needed",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "param_code does not need parameter slice.",
    "skip_prefix = [",
    "\"^\",",
    "\"train_op\",",
    "\"save\",",
    "\"gradients\",",
    "\"init\",",
    "\"global_step\",",
    "\"distort_image\",",
    "\"Adagrad\",",
    "]",
    "\"Switch\"",
    "\"RequantizationRange\",",
    "\"Requantize\",",
    "\"Identity\",",
    "\"Mean\",",
    "\"Cast\"",
    "load model files into TensorFlow graph",
    "Save it to an output file",
    "keep dims",
    "axes",
    "ssd model is transformed",
    "Ax - (Au - b)",
    "A",
    "b",
    "print(sub_content)",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "print(Rsqrt.out_edges)",
    "beta  (bias)",
    "moving mean (mean)",
    "input node",
    "epsilon",
    "beta",
    "gamma (scale)",
    "output_node = self.get_son(source_node.name, [0, 0, 0, 0], True)",
    "assert False",
    "Quantized model type",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "assert variable.get_attr('_output_shapes')[0].dim[0].size == IR_node.attr['kernel_shape'].list.i[-1]",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "In facenet or other newtwork using slim.batch_norm,",
    "There are two BN(train, test) skip switch and merge.",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "beta  (bias)",
    "moving mean (mean)",
    "ReduceMean",
    "keep dims",
    "axes",
    "Skip the node as merge",
    "weights",
    "alpha",
    "beta",
    "Skip BiasAdd",
    "weights",
    "input_node_perm = self.check_const(self.get_parent(source_node.name, [1], True))",
    "paddings",
    "for attr.shape >= 2",
    "For models built by slim.batch_norm, remove duplicate BN (eg.facenet)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "PaddleParser._set_output_shape(source_node, IR_node)",
    "name, op",
    "input edge",
    "For concat axis",
    "only for training",
    "name, op",
    "input edge",
    "input edge",
    "layer and spec",
    "width <=> x or height <=> y",
    "output shape",
    "name, op",
    "it should be in the shape of height x width x inputchannel x outputchannel",
    "use_bias: TODO",
    "pad_dim",
    "fail report because of auto_pad",
    "if dilation_x == 1 and dilation_y == 1:",
    "if output_x * stride_x == input_x and output_y * stride_y == input_y:",
    "auto_pad = \"SAME\"",
    "kwargs['auto_pad'] = auto_pad",
    "elif output_x * stride_x == input_x - width + 1 and output_y * stride_y == input_y - height + 1:",
    "auto_pad = \"VALID\"",
    "kwargs['auto_pad'] = auto_pad",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "channels_first, then axis = 1",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "flatten",
    "mean",
    "var",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "assert False",
    "output shape",
    "pad_dim",
    "padding mode",
    "If padding == \"SAME\": output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])",
    "If padding == \"VALID\": output_spatial_shape[i] = ceil((input_spatial_shape[i] - (spatial_filter_shape[i]-1) * dilation_rate[i]) / strides[i]).",
    "name, op",
    "input edge",
    "layer and spec",
    "units",
    "output shape",
    "use_bias",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "need the shape TODO",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "alpha",
    "beta",
    "nsize",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "TODO: Handle square",
    "self._print_layer(source_node)",
    "print (source_node.name)",
    "print (self.src_graph.get_parent(source_node.name, [0]).real_name)",
    "assert False",
    "Convolution",
    "Kernel",
    "Attributes",
    "Bias",
    "Activation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "BlockFunction node",
    "redirect the composite's inputs to the true inputs",
    "BlockFunctions are short-circuited, and not added to accum[]",
    "Function node",
    "OutputVariable node",
    "def build(self):",
    "_traverse_graph(self, self.model.root_function)",
    "super(CntkGraph, self).build()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "IR_node.get_attr('output_dim'),",
    "??",
    "print(IR_node.layer)",
    "assert False",
    "def emit_Unstack(self, IR_node):",
    "num_str = \"{}.shape[{}]\".format(self.parent_variable_name(IR_node), IR_node.get_attr('axis'))",
    "axis = IR_node.get_attr('axis')",
    "parent_variable_shape = \"list({}.shape)\".format(self.parent_variable_name(IR_node)",
    "if self.IR_graph.get_parent(IR_node.name, [0]).type != 'Embedding'",
    "else self.parent_variable_name(IR_node)+'.E')",
    "if axis==1:",
    "shape_str = \"tuple([{}[0]*{}[{}], 1].extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "else:",
    "shape_str = \"tuple([{}[0]*{}[{}]].extend({}[1:{}]).append(1).extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "code = \"{:<15} = cntk.reshape({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "shape_str,",
    "IR_node.variable_name)",
    "code = \"{: <15} = cntk.reshape({}, {}.shape, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name",
    ")",
    "return code",
    "def emit_Fill(self, IR_node):",
    "code = \"{:<15} = cntk.Constant({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "IR_node.get_attr('value'),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name)",
    "return code",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "network library",
    "not support multi-threads download",
    "key: layer_name    value: keras layer",
    "private functions",
    "next_node_info.left_in_edges -= 1",
    "print ('{} --> {}'.format(src, dst))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "If pattern.inputs is empty, skips the rest and accepts all the inputs.",
    "If order doesn't matter for the inputs, then make sure we match at least",
    "one permutation of the inputs.",
    "def get_tensor(self, pattern_or_name):",
    "op_tensor = self._get_op_tensor(pattern_or_name)",
    "return op_tensor[1] if op_tensor else None",
    "pylint: disable=protected-access",
    "pylint: enable=protected-access",
    "Python 3.3.2+ implements `yield from`, but for now:",
    "check the same pattern scope node whether have same inputs, outputs and weights.",
    "For those don't have, rename their scope names.",
    "clear out scope node, typically input constant node.",
    "get sub_scopes",
    "decline the suffix number",
    "Obtain nodes where the scope name that satisfies top_level is top_scope and sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in top_level is top_scope",
    "Obtain all nodes grouped by sub_level sub_scope",
    "cover the node",
    "store idx, node into a dict and sort it later to keep its topology sort.",
    "in_node's out edges replace n_name with scope node name.",
    "no out nodes means the last node in scope nodes should be returned",
    "if out_node is scope node, replace the scope node's inner topology list node.",
    "the input parameter shoule be sliced when call func.",
    "modify the in_edges in scope inner nodes. decline the :idx.",
    "1. initilize scope node",
    "2. get scope nodes' topology list.",
    "3. rebuild the edges connection after folding these scope nodes into one node and",
    "get this scope node's return variables.",
    "4. rebuild graph.",
    "RNN-related attrs.",
    "get input params",
    "self.store_const_to_top(result)",
    "self.set_top_node_prop(result, pattern_name)",
    "Do not include input op.",
    "TODO: pytorch, mxnet, keras, cntk",
    "-*- coding: utf-8 -*-",
    "from keras.layers.core import Layer",
    "Arguments",
    "Input shape",
    "Output shape",
    "Prepare broadcasting shape.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "Keras 2.1.6",
    "Keras. 2.2.2",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "size",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "weights",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "for target shape",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot weights",
    "print(\"Converting layer {}({})\".format(current_node.name, node_type))",
    "TODO",
    "return input_node, 'same'",
    "assert IR_node.get_attr('group', 1) == 1",
    "change dw from filters to 1",
    "reset the default dilation",
    "############",
    "Operators #",
    "############",
    "code = self._emit_merge(IR_node, \"subtract\")",
    "TODO",
    "when converting from coreml model, reshape is needed after the global pooling",
    "for Keras",
    "It arouses some problems:",
    "it can be implemented by Lambda Layer",
    "https://github.com/keras-team/keras/issues/890",
    "Keras == 2.1.6",
    "Keras == 2.2.2",
    "TODO: arguments won't be saved in keras export model",
    "param_code does not need parameter slice.",
    "Prepare broadcasting shape.",
    "output = Lambda(lambda x: tf.fill(x, value))(input)",
    "return output",
    "def _layer_Constant(self):",
    "self.add_body(0, '''",
    "class my_constant(keras.layers.Layer):",
    "def __init__(self, value, **kwargs):",
    "super(my_constant, self).__init__(**kwargs)",
    "self._value = value",
    "# the input is dummy, just for creating keras graph.",
    "def call(self, dummy):",
    "res = K.constant(self._value)",
    "self.output_shapes = K.int_shape(res)",
    "return res",
    "def compute_output_shape(self, input_shape):",
    "return self.output_shapes",
    "''')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "with open('modelmapbydataset.json', 'w') as outfile:",
    "json.dump(new_data, outfile)",
    "generate makedown script",
    "add Image Classification",
    "add Object Detection",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "generate makedown script",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "remove list",
    "draw",
    "mode;",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "rm the '_'",
    "Base64 encode: https://developers.google.com/protocol-buffers/docs/proto3",
    "Search the node",
    "select by id: https://stackoverflow.com/questions/37270787/uncaught-syntaxerror-failed-to-execute-queryselector-on-document",
    "Scroll",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ],
  "0.2.3": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "Communication to TensorFlow server via gRPC",
    "TensorFlow serving stuff to send messages",
    "Command line arguments",
    "Send request",
    "request.inputs['input'].CopyFrom()",
    "'xception'     : [TestModels.onnx_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "omit tensorflow lead to crash",
    "'nasnet-a_large'       : [TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'inception_resnet_v2'  : [TestModels.caffe_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "Function self.assertEquals has deprecated, change to assertEqual",
    "self.assertEqual(original_predict.shape, converted_predict.shape)",
    "get original model prediction result",
    "original to IR",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "print(original_predict)",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "get shape",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "IR to code",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "The list is in RGB oder",
    "IR to Model",
    "converted_file = original_framework + '_coreml_' + architecture_name + \"_converted\"",
    "converted_file = converted_file.replace('.', '_')",
    "load model",
    "save model",
    "coremltools.utils.save_spec(model.get_spec(), converted_file)",
    "inference",
    "IR to code",
    "import converted model",
    "In case of odd number add the extra padding at the end for SAME_UPPER(eg. pads:[0, 2, 2, 0, 0, 3, 3, 0]) and at the beginning for SAME_LOWER(eg. pads:[0, 3, 3, 0, 0, 2, 2, 0])",
    "'xception'     : [onnx_emit],",
    "'nasnet'       : [onnx_emit],",
    "'voc-fcn8s'     : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn16s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn32s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'resnet_v1_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v1_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'nasnet-a_large'        : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "TODO: coredump",
    "'alexnet'       : [cntk_emit, keras_emit, tensorflow_emit],",
    "'nasnet'       : [tensorflow_emit, keras_emit, coreml_emit],",
    "'facenet'      : [tensorflow_emit, coreml_emit,mxnet_emit,keras_emit]  # TODO",
    "'vgg16': [tensorflow_emit],",
    "'alexnet': [tensorflow_emit]",
    "get original model prediction result",
    "def test_caffe(self):",
    "try:",
    "import caffe",
    "self._test_function('caffe', self.caffe_parse)",
    "except ImportError:",
    "print('Please install caffe! Or caffe is not supported in your platform.', file=sys.stderr)",
    "def test_cntk(self):",
    "try:",
    "import cntk",
    "self._test_function('cntk', self.cntk_parse)",
    "except ImportError:",
    "print('Please install cntk! Or cntk is not supported in your platform.', file=sys.stderr)",
    "def test_coreml(self):",
    "from coremltools.models.utils import macos_version",
    "if macos_version() < (10, 13):",
    "print('Coreml is not supported in your platform.', file=sys.stderr)",
    "else:",
    "self._test_function('coreml', self.coreml_parse)",
    "def test_keras(self):",
    "self._test_function('keras', self.keras_parse)",
    "def test_mxnet(self):",
    "self._test_function('mxnet', self.mxnet_parse)",
    "def test_darknet(self):",
    "self._test_function('darknet', self.darknet_parse)",
    "def test_paddle(self):",
    "# omit tensorflow lead to crash",
    "import tensorflow as tf",
    "try:",
    "import paddle.v2 as paddle",
    "self._test_function('paddle', self.paddle_parse)",
    "except ImportError:",
    "print('Please install Paddlepaddle! Or Paddlepaddle is not supported in your platform.', file=sys.stderr)",
    "def test_pytorch(self):",
    "self._test_function('pytorch', self.pytorch_parse)",
    "def test_tensorflow(self):",
    "self._test_function('tensorflow', self.tensorflow_parse)",
    "def test_tensorflow_frozen(self):",
    "self._test_function('tensorflow_frozen', self.tensorflow_frozen_parse)",
    "'vgg19'         : [TestModels.onnx_emit],",
    "'voc-fcn8s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'vgg19'         : [TestModels.caffe_emit, TestModels.cntk_emit, TestModels.coreml_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'voc-fcn8s'     : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'voc-fcn16s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'voc-fcn32s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "'vgg19'         : [TestModels.onnx_emit],",
    "'alexnet'       : [TestModels.caffe_emit, TestModels.cntk_emit, TestModels.coreml_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'nasnet-a_large'       : [TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'inception_resnet_v2'  : [TestModels.caffe_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'xception'     : [TestModels.onnx_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "!/usr/bin/python",
    "major python major_python_versions as python2 and python3",
    "operating system",
    "do not deal",
    "I don't want to deal with auto_pad",
    "Don't support auto_pad current!",
    "2018-02-28",
    "if group is None:",
    "group = 1",
    "group is not support yet too.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "node",
    "input",
    "edge(node a <-> node b)",
    "",
    "key is edge name, value is src/dst node name",
    "key is initializer name, value is TensorProto",
    "print(name)",
    "print(layer.op_type)",
    "n is input data",
    "n is input edge",
    "omit node of some type",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "if node len(in_edges), generate additional DataInput node",
    "print",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "TODO",
    "'max_pool2d': convert_maxpool,",
    "'onnx::Mul': convert_elementwise_mul,",
    "'onnx::Sub': convert_elementwise_sub,",
    "'onnx::ConvTranspose': convert_convtranspose,",
    "'onnx::LeakyRelu': convert_lrelu,",
    "'onnx::Sigmoid': convert_sigmoid,",
    "'onnx::Softmax': convert_softmax,",
    "'onnx::Selu': convert_selu,",
    "'onnx::Transpose': convert_transpose,",
    "'onnx::Reshape': convert_reshape,",
    "'onnx::MatMul': convert_matmul,",
    "'onnx::Gather': convert_gather,",
    "'onnx::ReduceSum': convert_reduce_sum,",
    "'onnx::Constant': convert_constant,",
    "'onnx::Upsample': convert_upsample,",
    "'onnx::Pad': convert_padding,",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "test",
    "cpu: https://github.com/pytorch/pytorch/issues/5286",
    "Build network graph",
    "(batch, C, H, W)  & NHWC",
    "#########",
    "Layers #",
    "#########",
    "dilation",
    "handle bias",
    "TODO",
    "output_shape",
    "epsilon",
    "mean",
    "var",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "use_bias",
    "units",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Scopes created in a nested scope may have initial characters",
    "that are illegal as the initial character of an op name",
    "(viz. '-', '\\', '/', and '_').",
    "sanity check.",
    "run dce first to eliminate dead parts of the graph that might have been",
    "left behind by things like symbolic_override",
    "construct graph",
    "nodes",
    "input layer",
    "TODO",
    "build each layer",
    "input",
    "print(node_input_name ,'->', node_name)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "padding,",
    "exstr = \", value=float('-Inf')\"",
    "exstr = \"\"",
    "Change to padding defuse",
    "input_node = self._defuse_padding(IR_node, exstr)",
    "Ignore it in Pytorch",
    "for Keras",
    "self.add_init(2, \"self.{:<15} = torch.from_numpy(__weights_dict['{}']['value'])\".format(",
    "IR_node.variable_name,",
    "IR_node.name))",
    "param_code does not need parameter slice.",
    "from torch.nn.parameter import Parameter",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._type = layer.__class__.__name__.replace('Backward', '')",
    "self._name = \"{}_{}\".format(self.type, id)",
    "TODO",
    "\"\"\"",
    "build graph for pytorch 0.2.0",
    "\"\"\"",
    "dummy_input = torch.autograd.Variable(torch.randn(shape))",
    "output_node = self.model(dummy_input)",
    "search_queue = [output_node.grad_fn]",
    "tmp_node = PyTorchGraphNode(output_node.grad_fn, 0)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "visited = {output_node.grad_fn : self.layer_map[tmp_node.name]}",
    "idx = 0",
    "node_count = 1",
    "while (idx < len(search_queue)):",
    "current_node = search_queue[idx]",
    "current_type = visited[current_node].type",
    "if hasattr(current_node, 'next_functions'):",
    "for parent, _ in current_node.next_functions:",
    "parent_type = parent.__class__.__name__.replace('Backward', '')",
    "if parent_type != 'AccumulateGrad' and \\",
    "(parent_type != 'Transpose' or current_type != 'Addmm'):",
    "if not parent in visited:",
    "tmp_node = PyTorchGraphNode(parent, node_count)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "node_count += 1",
    "visited[parent] = tmp_node",
    "search_queue.append(parent)",
    "self._make_connection(visited[parent].name, visited[current_node].name)",
    "idx += 1",
    "try:",
    "return TorchGraph._forward_torch_random_input(",
    "torch_model,",
    "input_shapes,",
    "is_batch=False",
    ")",
    "except:",
    "# try batch mode",
    "# return TorchGraph._forward_torch_random_input(",
    "#     torch_model,",
    "#     input_shapes,",
    "#     is_batch=True",
    "# )",
    "pass",
    "tensor = torch.rand(*shape).float()",
    "multi output",
    "single output",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "Build network graph",
    "#########",
    "Layers #",
    "#########",
    "handle weight",
    "handle bias",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "load model file into Coreml Graph",
    "model.encode() convert to str --- python2 may crash due to type 'unicode'",
    "Build Network Graph",
    "self.data_format ? TODO",
    "load the model network",
    "convert to Model_pb2.Model",
    "determine the type of the current_node",
    "staticmethods",
    "(seq, batch, C, H, W)  & NHWC",
    "TODO dtype_map",
    "##### convert methods",
    "convolution",
    "input edge",
    "important!",
    "reshape the weight!",
    "[2, 3, 0, 1]",
    "pads",
    "use_bias",
    "isDeconvolution",
    "name, op",
    "kwargs['kernel_shape'] = weights.shape",
    "strides",
    "[1, sd, sh, sw, 1]",
    "activation",
    "TODO",
    "padding in conv",
    "pad in IR is [x1_b, x2_b, ..., x1_e, x2_e, ...]",
    "padding",
    "compute padding for 'same'",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "https://www.jianshu.com/p/05c4f1621c7e",
    "padding in pooling",
    "padding",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "TODO",
    "symmetric padding",
    "name, op",
    "input edge",
    "For concat axis",
    "NO axis in coreml, so set the last axis",
    "The first -1 means in coreml there is one-more axis,",
    "The second -1 means the last axis",
    "name, op",
    "input edge",
    "padding",
    "Future Module TODO",
    "#### rename methods",
    "name, op",
    "activation type",
    "else:",
    "assert False",
    "input edge",
    "Merge layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "NHWC channel last",
    "in fact, here is NWHC",
    "name, op",
    "input edge",
    "axis TODO",
    "channels_first, then axis = 1",
    "scale",
    "bias",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "mean",
    "var",
    "name, op",
    "input edge",
    "bias",
    "name, op",
    "input edge",
    "MAX = 0, AVERAGE = 1, L2 = 2",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "change to single because of the tf matmul",
    "name, op",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "the end of the tensorflow_resnet_v2_50's squeeze shape is [unknown_rank: true] with len 0",
    "1001 means the 1001 classes for tensorflow_resnet_v2_50",
    "!Alert! TODO",
    "Future implement can be changed to the last two layer",
    "TODO - remove style transfer 1D hack",
    "Input is 1D but it goes to the width dimension: (1,1,W)",
    "assume (Batch, Channels) - Batch dimension should be dropped",
    "assume (Batch, Sequence-Length, channels)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Add classifier classes (if applicable)",
    "Set pre-processing paramsters",
    "image_input_names,",
    "Return the protobuf spec",
    "model = _MLModel(self.builder.spec)",
    "if IR_node.name in self.weights_dict and 'weights' in self.weights_dict[IR_node.name]:",
    "pass",
    "self._emit_merge(IR_node,'DOT')",
    "Get input and output names",
    "Dimensions and weights",
    "W should have shape (height, width, kernel_channels, output_channels), where kernel_channel = input_channels / groups",
    "Dilations",
    "see protobuf",
    "assert False",
    "Get the weights.",
    "Dilations",
    "see protobuf",
    "depth-wise convolution",
    "Dilations",
    "see protobuf",
    "Get input and output names",
    "Pooling layer type",
    "if it's global, set the global flag",
    "TODO  global pooling modification",
    "Padding",
    "see protobuf",
    "Padding",
    "see protobuf",
    "Get input and output names",
    "type: \"list(int). A 1-D values of (leftBorder, topBorder, rightBorder, bottomBorder).\"",
    "This is central crop",
    "Now add the layer",
    "Allowed values: 'CHW', 'HW', 'C', 'H', 'W'",
    "Get input and output names",
    "Get input and output names",
    "Get the weights from keras",
    "Get input and output names",
    "blob_order == 0 if the input blob needs not be rearranged",
    "blob_order == 1 if the input blob needs to be rearranged",
    "using keras_layer.input.shape have a \"?\" (Dimension[None] at the front),",
    "making a 3D tensor with unknown batch size 4D",
    "Get input and output names",
    "activation emit",
    "Get input and output names",
    "negate it",
    "apply threshold",
    "negate it back",
    "for Keras",
    "Get input and output names",
    "Set parameters",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "padding type TODO",
    "Type of the padding. Can be one of 'constant', 'reflection' or 'replication",
    "Now add the layer",
    "self.emit_Flatten(IR_node)",
    "depth_radius: Half-width of the 1-D normalization window.\"",
    "Get the weights",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "input layer",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "The information of the layer",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "print(node.parameters)",
    "assert False",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "if parent.output_shape.height > 1 or parent.output_shape.width > 1:",
    "TODO: The gamma parameter has to be set (in node.data?) and this should work.",
    "Also, mean should be set to 0, and var to 1, just to be safe.",
    "skip the split node",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For some reason argparser gives us unicode, so we need to conver to str first",
    "for test",
    "with open(\"graph.txt\", 'w') as f:",
    "for layer in self.IR_graph.topological_sort:",
    "current_node = self.IR_graph.get_node(layer)",
    "print(\"========current_node=========\\n{}\".format(current_node.layer), file=f)",
    "test end",
    "print(\"========current_node={}\".format(current_node.layer))",
    "check if have pad layer",
    "Pad_h < kernel_h (vgg19 caffe2caffe)",
    "implement asymmetric paddings by applying symmetric padding then cropping",
    "keys = []",
    "for key in self.weights_dict[IR_node.name].keys():",
    "keys.append(key)",
    "print(\"=======Layer: {}, keys: {}\".format(IR_node.name, keys))",
    "if asymmetric padding, set offset to 1",
    "Change the layer name",
    "check if need crop output shape",
    "change the key \"name\" to \"variable_name\", in case of the layer name has invalid characters",
    "Convert NHWC (IR) to NCHW (Caffe): [0,1,2,3]->[0,3,1,2]",
    "def emit_Square(self, IR_node):",
    "input_layers = ', '.join(('n.' + self.IR_graph.get_node(edge).real_variable_name) for edge in IR_node.in_edges)",
    "self.add_body(1, \"n.{:<15} = L.Square({}, ntop=1)\".format(",
    "IR_node.variable_name,",
    "input_layers))",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "self.graph = NodeRenamer()(graph)",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "assert mapped_node is not None",
    "skip when mapped_node is None",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "try:",
    "except ImportError:",
    "# # Fall back to the protobuf implementation",
    "# from mmdnn.conversion.caffe import caffe_pb2",
    "# self.caffepb = caffe_pb2",
    "# show_fallback_warning()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from tensorflow.core.framework.node_def_pb2 import NodeDef",
    "from tensorflow.core.framework import attr_value_pb2",
    "pass",
    "print(\"\\n\")",
    "print(i)",
    "print(block)",
    "continue",
    "NHWC",
    "assert False",
    "print(shortcut_layer['input'] )",
    "spacetodepth",
    "print(block)",
    "print(region_layer)",
    "assert False",
    "print line",
    "set default value",
    "yolo3(608) start at 1, yolo2(608) start at 0. yolo2(416) start at 1, yolo3(416) start at 0",
    "load weight by original order",
    "print(node_type)",
    "print(IR_node)",
    "assert False",
    "strides",
    "assert False",
    "padding",
    "only load weight conv",
    "print(\"----------------\",self.start)",
    "print(kernel.shape)",
    "print(k_bias.shape)",
    "buf, start, scale_layer['name'], bn_layer['name'], conv_layer['name']",
    "print(\"==============\",self.start)",
    "print(bias.shape)",
    "print(scale.shape)",
    "print(mean.shape)",
    "print(var.shape)",
    "print(kernel.shape)",
    "print(W)",
    "assert False",
    "no use",
    "print(source_node.layer)",
    "for image classification(resnet) AVG pooling",
    "print(source_node.layer)",
    "print(source_node.layer)",
    "kwargs['ignore_thresh'] = source_node.get_attr('ignore_thresh')",
    "print(source_node.get_attr('anchors'))",
    "kwargs['anchors'] = ['0.52','0.22']",
    "kwargs['mask'] = source_node.get_attr('mask')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "tensorflow dump tag",
    "Reference: 1) Keras image preprocess: https://github.com/keras-team/keras/blob/master/keras/applications/imagenet_utils.py",
    "2) tensorflow github issue: https://github.com/tensorflow/models/issues/517",
    "R-G-B for Imagenet === [123.68, 116.78, 103.94]",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load a real image and do default tf imageNet preprocessing",
    "[Batch, Height, Width, Channels] --> [Batch, Channels, Height, Width]",
    "We only deal with non-recurrent networks for now",
    "(H,W,C) --> (C,H,W)",
    "Load TensorFlow model",
    "Prepare inputs",
    "Run TF session",
    "Evaluate coreml model",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "@unittest.skip(\"Failing GPU backend: related to https://github.com/tf-coreml/tf-coreml/issues/26\")",
    "? style transfer image size and style number?",
    "Test predictions on an image",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "compare_tf_coreml_outputs(tf_out_flatten, coreml_out_flatten)",
    "#Download model",
    "url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception_v3_2016_08_28_frozen.pb.tar.gz'",
    "tf_model_dir = _download_file(url = url)",
    "tf_model_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28_frozen.pb')",
    "#Convert to coreml",
    "mlmodel_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28.mlmodel')",
    "mlmodel = tf_converter.convert(",
    "tf_model_path = tf_model_path,",
    "mlmodel_path = mlmodel_path,",
    "output_feature_names = ['InceptionV3/Predictions/Softmax:0'],",
    "input_name_shape_dict = {'input:0':[1,299,299,3]},",
    "image_input_names = ['input:0'],",
    "red_bias = -1,",
    "green_bias = -1,",
    "blue_bias = -1,",
    "image_scale = 2.0/255.0)",
    "#Test predictions on an image",
    "_test_coreml_model_image_input(",
    "tf_model_path = tf_model_path,",
    "coreml_model = mlmodel,",
    "input_tensor_name = 'input:0',",
    "output_tensor_name = 'InceptionV3/Predictions/Softmax:0',",
    "img_size = 299)",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "self.test_truth()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from collections import namedtuple",
    "Batch = namedtuple('Batch', ['data'])",
    "TODO",
    "Apple has published some of their own models. They can be downloaded from https://developer.apple.com/machine-learning/.",
    "Those published models are: SqueezeNet, Places205-GoogLeNet, ResNet50, Inception v3, VGG16",
    "TODO",
    "load model",
    "TODO: Multiple inputs",
    "TODO: Multiple outputs",
    "inference",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "caffe uses NCHW",
    "self.print_intermediate_result('pooling0', False)",
    "delete tmp model files",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "net = caffe.Net(arch_fn, weight_fn, caffe.TEST)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "# Image Classification",
    "# Semantic Segmentation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "print(r)",
    "d = darknet_extractor()",
    "model_filename = d.download('yolov3')",
    "print(model_filename)",
    "image_path = \"./mmdnn/conversion/examples/data/dog.jpg\"",
    "model_path = \"./\"",
    "d = darknet_extractor()",
    "result = d.inference('yolov3', model_filename, model_path, image_path = image_path)",
    "print(result)",
    "print(i)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('pooling0', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "need to be updated",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "raise NotImplementedError()",
    "load file",
    "Using cuDNN since vanilla RNN",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Notes for training NASNet Cifar Model",
    "-------------------------------------",
    "batch_size: 32",
    "learning rate: 0.025",
    "cosine (single period) learning rate decay",
    "auxiliary head loss weighting: 0.4",
    "clip global norm of all gradients by 5",
    "600 epochs with a batch size of 32",
    "This is used for the drop path probabilities since it needs to increase",
    "the drop out probability over the course of training.",
    "Notes for training large NASNet model on ImageNet",
    "-------------------------------------",
    "batch size (per replica): 16",
    "learning rate: 0.015 * 100",
    "learning rate decay factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 100 replicas",
    "auxiliary head loss weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Notes for training the mobile NASNet ImageNet model",
    "-------------------------------------",
    "batch size (per replica): 32",
    "learning rate: 0.04 * 50",
    "learning rate scaling factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 50 replicas",
    "auxiliary head weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Shape of feature map before the final layer.",
    "149 x 149 x 32",
    "Run the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Find where to place the reduction cells or stride normal cells",
    "Setup for building in the auxiliary head.",
    "Run the cells",
    "true_cell_num accounts for the stem cells",
    "Final softmax layer",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 192",
    "35 x 35 x 320",
    "TODO(alemi): Register intermediate endpoints",
    "17 x 17 x 1088 if output_stride == 8,",
    "33 x 33 x 1088 if output_stride == 16",
    "TODO(alemi): register intermediate endpoints",
    "TODO(gpapan): Properly support output_stride for the rest of the net.",
    "8 x 8 x 2080",
    "TODO(alemi): register intermediate endpoints",
    "8 x 8 x 1536",
    "TODO(sguada,arnoegw): Consider adding a parameter global_pool which",
    "can be set to False to disable pooling here (as in resnet_*()).",
    "Set weight_decay for weights in conv2d and fully_connected layers.",
    "Set activation_fn and parameters for batch_norm.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "=============================================================================",
    "Tensorflow mandates these.",
    "Conv and DepthSepConv namedtuple define layers of the MobileNet architecture",
    "Conv defines 3x3 convolution layers",
    "DepthSepConv defines 3x3 depthwise convolution followed by 1x1 convolution.",
    "stride is the stride of the convolution",
    "depth is the number of channels or filters in a layer",
    "_CONV_DEFS specifies the MobileNet body",
    "Used to find thinned depths for each layer.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "By passing filters=None",
    "separable_conv2d produces only a depthwise convolution layer",
    "Global average pooling.",
    "Pooling with a fixed kernel size.",
    "1 x 1 x 1024",
    "Set weight_decay for weights in Conv and DepthSepConv layers.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Skip path 1",
    "Skip path 2",
    "First pad with 0's on the right and bottom, then shift the filter to",
    "include those 0's that were added.",
    "Concat and apply BN",
    "Set the prev layer to the current layer if it is none",
    "Check to be sure prev layer stuff is setup correctly",
    "Apply conv operations",
    "Combine hidden states using 'add'.",
    "Add hiddenstate to the list of hiddenstates we can choose from",
    "Dont stride if this is not one of the original hiddenstates",
    "Check if a stride is needed, then use a strided 1x1 here",
    "Determine if a reduction should be applied to make the number of",
    "filters match.",
    "Return the concat of all the states",
    "Scale keep prob by layer number",
    "The added 2 is for the reduction cells",
    "Decrease the keep probability over time",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Inception-Resnet-A",
    "Inception-Resnet-B",
    "Inception-Resnet-C",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "force in-place updates of mean and variance estimates",
    "Moving averages ends up in the trainable variables collection",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 256",
    "5 x Inception-resnet-A",
    "Reduction-A",
    "10 x Inception-Resnet-B",
    "Reduction-B",
    "5 x Inception-Resnet-C",
    "pylint: disable=no-member",
    "net = slim.fully_connected(net, bottleneck_layer_size, activation_fn=None,",
    "scope='Bottleneck', reuse=False)",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Note: want to round down, we adjust each split to match the total.",
    "We use scope_depthwise, scope_pointwise for compatibility with V1 ckpts.",
    "which provide numbered scopes.",
    "b1 -> b2 * r -> b2",
    "i -> (o * r) (bottleneck) -> o",
    "Note in contrast with expansion, we always have",
    "projection to produce the desired output size.",
    "stride check enforces that we don't add residuals when spatial",
    "dimensions are None",
    "Depth matches",
    "Don't do any splitting if we end up with less than 8 filters",
    "on either side.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Set conv defs defaults and overrides.",
    "a) Set the tensorflow scope",
    "b) set padding to default: note we might consider removing this",
    "since it is also set by mobilenet_scope",
    "c) set all defaults",
    "d) set all extra overrides.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "Insert default parameters before the base scope which includes",
    "any custom overrides set in mobilenet.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "Update params.",
    "Only insert rate to params if rate > 1.",
    "Set padding",
    "Add all tensors that end with 'output' to",
    "endpoints",
    "1 x 1 x num_classes",
    "Note: legacy scope name.",
    "Recover output shape, for unknown shape.",
    "the network created will be trainble with dropout/batch norm",
    "initialized appropriately.",
    "Note: do not introduce parameters that would change the inference",
    "model here (for example whether to use bias), modify conv_def instead.",
    "Set weight_decay for weights in Conv and FC layers.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "pyformat: disable",
    "Architecture: https://arxiv.org/abs/1801.04381",
    "Note: these parameters of batch norm affect the architecture",
    "that's why they are here and not in training_scope.",
    "pyformat: enable",
    "NB: do not set depth_args unless they are provided to avoid overriding",
    "whatever default depth_multiplier might have thanks to arg_scope.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "import self.model",
    "self.model",
    "how the model can not load from `***.bin`",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "the channel of input feature is 3",
    "depth should be one of 20, 32, 44, 56, 110, 1202",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.anchors = np.array([[10,13], [16,30],[33,23],[30,61],[62,45], [59,119],[116,90],[156,198],[373,326]])",
    "print(output)",
    "print(out_boxes, out_scores, out_classes)",
    "get random colors",
    "My kingdom for a good redistributable image drawing library.",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "yolov3 80 classes",
    "Reshape to batch, height, width, num_anchors, box_params.",
    "Adjust preditions to each spatial grid point and anchor size.",
    "Note: YOLO iterates over height index before width index.",
    "TODO: It works with +1, don't know why.",
    "Scale boxes back to original image shape.",
    "print(\"feats,anchors, num_classes, input_shape\", feats, anchors, num_classes, input_shape)",
    "print(box_xy, box_wh, box_confidence, box_class_probs)",
    "yolo_outputs order 13,26,52",
    "TODO: use keras backend instead of tf.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Convert network architecture only",
    "MXNet",
    "Caffe",
    "For CoreML",
    "Caffe",
    "Darknet",
    "exts = ['.pb', '.npy', '.py']",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "We use the real_name for specifying the input layer in data_names",
    "since MXNet API wants the actual name of the layer. On the other",
    "hand, the module API wants the last symbol in the symbol chain, so",
    "for the output node we need to use the actual python variable name",
    "of the last layer (real_variable_name).",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if layout not in MXNetEmitter.channels_last:",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "def emit_ConvTranspose(self, IR_node):",
    "if self.weight_loaded:",
    "weight_dict = self.weights[IR_node.name]",
    "weights = weight_dict['weights']",
    "dim = len(IR_node.IR_layer.attr[\"kernel_shape\"].list.i) - 2",
    "kernel = list()",
    "for idx in range(0, dim):",
    "kernel.append(IR_node.IR_layer.attr[\"kernel_shape\"].list.i[idx])",
    "stride = list()",
    "for e in IR_node.IR_layer.attr[\"strides\"].list.i[1:-1]:",
    "stride.append(e)",
    "dilate = list()",
    "for e in IR_node.IR_layer.attr[\"dilations\"].list.i[1:-1]:",
    "dilate.append(e)",
    "dilate = ', '.join('%s' % i for i in dilate)",
    "defuse_pad = False",
    "pad = list()",
    "if \"pads\" in IR_node.IR_layer.attr:",
    "output_shape = list()",
    "for e in IR_node.IR_layer.attr[\"_output_shapes\"].list.shape[0].dim:",
    "output_shape.append(e.size)",
    "# print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "defuse_pad, pad = MXNetEmitter.transfer_pad(IR_node.IR_layer.attr[\"pads\"].list.i)",
    "pad = ', '.join('%s' % i for i in pad)",
    "kernel = ', '.join('%s' % i for i in kernel)",
    "stride = ', '.join('%s' % i for i in stride)",
    "num_filter = IR_node.IR_layer.attr[\"kernel_shape\"].list.i[-2]",
    "no_bias = not IR_node.IR_layer.attr[\"use_bias\"].b",
    "if not no_bias and self.weight_loaded:",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_bias\"] = weight_dict['bias']",
    "# layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NCHW'",
    "elif dim == 3:",
    "layout = 'NCDHW'",
    "if self.weight_loaded:",
    "# if layout not in MXNetEmitter.channels_last:",
    "weights = MXNetEmitter.transpose(weights, dim)",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_weight\"] = weights",
    "code = \"\"",
    "if not defuse_pad:",
    "code = \"{:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), pad = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "kernel,",
    "stride,",
    "dilate,",
    "pad,",
    "num_filter,",
    "no_bias,",
    "layout,",
    "IR_node.replace_scope(IR_node.name))",
    "else:",
    "code = self.set_pad(IR_node, code, pad)",
    "code += \"\\n    {:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name) + \"_pad\", kernel, stride, dilate, num_filter, no_bias, layout, IR_node.replace_scope(IR_node.name))",
    "return code",
    "reverse cannot support yet",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(\"trans\", self.parent_variable_name(IR_node))",
    "save the constant into weight dict",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "Load the model network and weights",
    "digraph = mx.viz.plot_network(sym, save_format='jpg') # For debugging",
    "digraph.render()",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "load the model network",
    "adjust the data format",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "for e in pad:",
    "IR_node.attr[\"pads\"].list.i.extend([e, e])",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "name, op",
    "input edge",
    "units",
    "use bias (no_bias default = False)",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "input edge",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "groups",
    "in_channel = in_channel // group",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "padding",
    "weights",
    "axis",
    "scale",
    "epsilon",
    "momentum",
    "weights",
    "gamma",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "kernel_shape",
    "padding",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "dim",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "weights",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "IR only support elu and prelu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "return",
    "name, op",
    "gamma",
    "input edge",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "alpha",
    "beta",
    "knorm",
    "nsize",
    "keep_prob",
    "mode",
    "reverse cannot support yet",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "dim",
    "dtype",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "axis",
    "raise NotImplementedError(\"No matching IR api\")",
    "left strip the \"_\" at the beginning of the name",
    "Issue #85, #135",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "print(moving_variance.name)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into TensorFlow graph",
    "extract subgraph using in_nodes and dest_nodes",
    "Build network graph",
    "extract subgraph using dest_nodes",
    "Graph Transform",
    "Get input node name",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Matmul Layer",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "print (source_node)",
    "print (source_node.layer)",
    "assert False",
    "def rename_RandomShuffleQueueV2(self, source_node):",
    "# print(source_node.layer)",
    "IR_node = self._convert_identity_operation(source_node, in_edge_count = 0, new_op = 'DataInput')",
    "# IR_node.attr['shape'].shape.MergeFromString(source_node.layer.attr['_output_shapes'].list.shape[0].SerializeToString())",
    "# IR_node.attr['shape'].shape.dim[0].size = -1",
    "IR_node.attr['dtype'].type = self.dtype_map[source_node.layer.attr['component_types'].list.type[0]]",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "TODO: Current it is only for slice",
    "TODO:  only for 1D",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "check whether flatten operator should be added",
    "flatten is needed",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "param_code does not need parameter slice.",
    "skip_prefix = [",
    "\"^\",",
    "\"train_op\",",
    "\"save\",",
    "\"gradients\",",
    "\"init\",",
    "\"global_step\",",
    "\"distort_image\",",
    "\"Adagrad\",",
    "]",
    "\"Switch\"",
    "\"RequantizationRange\",",
    "\"Requantize\",",
    "\"Identity\",",
    "\"Mean\",",
    "\"Cast\"",
    "load model files into TensorFlow graph",
    "Save it to an output file",
    "keep dims",
    "axes",
    "ssd model is transformed",
    "Ax - (Au - b)",
    "A",
    "b",
    "print(sub_content)",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "print(Rsqrt.out_edges)",
    "beta  (bias)",
    "moving mean (mean)",
    "input node",
    "epsilon",
    "beta",
    "gamma (scale)",
    "output_node = self.get_son(source_node.name, [0, 0, 0, 0], True)",
    "assert False",
    "Quantized model type",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "assert variable.get_attr('_output_shapes')[0].dim[0].size == IR_node.attr['kernel_shape'].list.i[-1]",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "In facenet or other newtwork using slim.batch_norm,",
    "There are two BN(train, test) skip switch and merge.",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "beta  (bias)",
    "moving mean (mean)",
    "ReduceMean",
    "keep dims",
    "axes",
    "Skip the node as merge",
    "weights",
    "alpha",
    "beta",
    "Skip BiasAdd",
    "weights",
    "input_node_perm = self.check_const(self.get_parent(source_node.name, [1], True))",
    "paddings",
    "for attr.shape >= 2",
    "For models built by slim.batch_norm, remove duplicate BN (eg.facenet)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "PaddleParser._set_output_shape(source_node, IR_node)",
    "name, op",
    "input edge",
    "For concat axis",
    "only for training",
    "name, op",
    "input edge",
    "input edge",
    "layer and spec",
    "width <=> x or height <=> y",
    "output shape",
    "name, op",
    "it should be in the shape of height x width x inputchannel x outputchannel",
    "use_bias: TODO",
    "pad_dim",
    "fail report because of auto_pad",
    "if dilation_x == 1 and dilation_y == 1:",
    "if output_x * stride_x == input_x and output_y * stride_y == input_y:",
    "auto_pad = \"SAME\"",
    "kwargs['auto_pad'] = auto_pad",
    "elif output_x * stride_x == input_x - width + 1 and output_y * stride_y == input_y - height + 1:",
    "auto_pad = \"VALID\"",
    "kwargs['auto_pad'] = auto_pad",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "channels_first, then axis = 1",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "flatten",
    "mean",
    "var",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "assert False",
    "output shape",
    "pad_dim",
    "padding mode",
    "If padding == \"SAME\": output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])",
    "If padding == \"VALID\": output_spatial_shape[i] = ceil((input_spatial_shape[i] - (spatial_filter_shape[i]-1) * dilation_rate[i]) / strides[i]).",
    "name, op",
    "input edge",
    "layer and spec",
    "units",
    "output shape",
    "use_bias",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "need the shape TODO",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "alpha",
    "beta",
    "nsize",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "TODO: Handle square",
    "self._print_layer(source_node)",
    "print (source_node.name)",
    "print (self.src_graph.get_parent(source_node.name, [0]).real_name)",
    "assert False",
    "Convolution",
    "Kernel",
    "Attributes",
    "Bias",
    "Activation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "BlockFunction node",
    "redirect the composite's inputs to the true inputs",
    "BlockFunctions are short-circuited, and not added to accum[]",
    "Function node",
    "OutputVariable node",
    "def build(self):",
    "_traverse_graph(self, self.model.root_function)",
    "super(CntkGraph, self).build()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "IR_node.get_attr('output_dim'),",
    "??",
    "print(IR_node.layer)",
    "assert False",
    "def emit_Unstack(self, IR_node):",
    "num_str = \"{}.shape[{}]\".format(self.parent_variable_name(IR_node), IR_node.get_attr('axis'))",
    "axis = IR_node.get_attr('axis')",
    "parent_variable_shape = \"list({}.shape)\".format(self.parent_variable_name(IR_node)",
    "if self.IR_graph.get_parent(IR_node.name, [0]).type != 'Embedding'",
    "else self.parent_variable_name(IR_node)+'.E')",
    "if axis==1:",
    "shape_str = \"tuple([{}[0]*{}[{}], 1].extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "else:",
    "shape_str = \"tuple([{}[0]*{}[{}]].extend({}[1:{}]).append(1).extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "code = \"{:<15} = cntk.reshape({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "shape_str,",
    "IR_node.variable_name)",
    "code = \"{: <15} = cntk.reshape({}, {}.shape, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name",
    ")",
    "return code",
    "def emit_Fill(self, IR_node):",
    "code = \"{:<15} = cntk.Constant({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "IR_node.get_attr('value'),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name)",
    "return code",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "network library",
    "not support multi-threads download",
    "key: layer_name    value: keras layer",
    "private functions",
    "next_node_info.left_in_edges -= 1",
    "print ('{} --> {}'.format(src, dst))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "If pattern.inputs is empty, skips the rest and accepts all the inputs.",
    "If order doesn't matter for the inputs, then make sure we match at least",
    "one permutation of the inputs.",
    "def get_tensor(self, pattern_or_name):",
    "op_tensor = self._get_op_tensor(pattern_or_name)",
    "return op_tensor[1] if op_tensor else None",
    "pylint: disable=protected-access",
    "pylint: enable=protected-access",
    "Python 3.3.2+ implements `yield from`, but for now:",
    "check the same pattern scope node whether have same inputs, outputs and weights.",
    "For those don't have, rename their scope names.",
    "clear out scope node, typically input constant node.",
    "get sub_scopes",
    "decline the suffix number",
    "Obtain nodes where the scope name that satisfies top_level is top_scope and sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in top_level is top_scope",
    "Obtain all nodes grouped by sub_level sub_scope",
    "cover the node",
    "store idx, node into a dict and sort it later to keep its topology sort.",
    "in_node's out edges replace n_name with scope node name.",
    "no out nodes means the last node in scope nodes should be returned",
    "if out_node is scope node, replace the scope node's inner topology list node.",
    "the input parameter shoule be sliced when call func.",
    "modify the in_edges in scope inner nodes. decline the :idx.",
    "1. initilize scope node",
    "2. get scope nodes' topology list.",
    "3. rebuild the edges connection after folding these scope nodes into one node and",
    "get this scope node's return variables.",
    "4. rebuild graph.",
    "RNN-related attrs.",
    "get input params",
    "self.store_const_to_top(result)",
    "self.set_top_node_prop(result, pattern_name)",
    "Do not include input op.",
    "TODO: pytorch, mxnet, keras, cntk",
    "-*- coding: utf-8 -*-",
    "from keras.layers.core import Layer",
    "Arguments",
    "Input shape",
    "Output shape",
    "Prepare broadcasting shape.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "Keras 2.1.6",
    "Keras. 2.2.2",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "size",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "weights",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "for target shape",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot weights",
    "print(\"Converting layer {}({})\".format(current_node.name, node_type))",
    "TODO",
    "return input_node, 'same'",
    "assert IR_node.get_attr('group', 1) == 1",
    "change dw from filters to 1",
    "reset the default dilation",
    "############",
    "Operators #",
    "############",
    "code = self._emit_merge(IR_node, \"subtract\")",
    "TODO",
    "when converting from coreml model, reshape is needed after the global pooling",
    "for Keras",
    "It arouses some problems:",
    "it can be implemented by Lambda Layer",
    "https://github.com/keras-team/keras/issues/890",
    "Keras == 2.1.6",
    "Keras == 2.2.2",
    "TODO: arguments won't be saved in keras export model",
    "param_code does not need parameter slice.",
    "Prepare broadcasting shape.",
    "output = Lambda(lambda x: tf.fill(x, value))(input)",
    "return output",
    "def _layer_Constant(self):",
    "self.add_body(0, '''",
    "class my_constant(keras.layers.Layer):",
    "def __init__(self, value, **kwargs):",
    "super(my_constant, self).__init__(**kwargs)",
    "self._value = value",
    "# the input is dummy, just for creating keras graph.",
    "def call(self, dummy):",
    "res = K.constant(self._value)",
    "self.output_shapes = K.int_shape(res)",
    "return res",
    "def compute_output_shape(self, input_shape):",
    "return self.output_shapes",
    "''')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "with open('modelmapbydataset.json', 'w') as outfile:",
    "json.dump(new_data, outfile)",
    "generate makedown script",
    "add Image Classification",
    "add Object Detection",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "generate makedown script",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "remove list",
    "draw",
    "mode;",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "rm the '_'",
    "Base64 encode: https://developers.google.com/protocol-buffers/docs/proto3",
    "Search the node",
    "select by id: https://stackoverflow.com/questions/37270787/uncaught-syntaxerror-failed-to-execute-queryselector-on-document",
    "Scroll",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ],
  "0.2.2": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "Communication to TensorFlow server via gRPC",
    "TensorFlow serving stuff to send messages",
    "Command line arguments",
    "Send request",
    "request.inputs['input'].CopyFrom()",
    "'xception'     : [TestModels.onnx_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "omit tensorflow lead to crash",
    "'nasnet-a_large'       : [TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'inception_resnet_v2'  : [TestModels.caffe_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "Function self.assertEquals has deprecated, change to assertEqual",
    "self.assertEqual(original_predict.shape, converted_predict.shape)",
    "get original model prediction result",
    "original to IR",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "print(original_predict)",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "get shape",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "IR to code",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "The list is in RGB oder",
    "IR to Model",
    "converted_file = original_framework + '_coreml_' + architecture_name + \"_converted\"",
    "converted_file = converted_file.replace('.', '_')",
    "load model",
    "save model",
    "coremltools.utils.save_spec(model.get_spec(), converted_file)",
    "inference",
    "IR to code",
    "import converted model",
    "In case of odd number add the extra padding at the end for SAME_UPPER(eg. pads:[0, 2, 2, 0, 0, 3, 3, 0]) and at the beginning for SAME_LOWER(eg. pads:[0, 3, 3, 0, 0, 2, 2, 0])",
    "'xception'     : [onnx_emit],",
    "'nasnet'       : [onnx_emit],",
    "'voc-fcn8s'     : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn16s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'voc-fcn32s'    : [onnx_emit], # TODO: ConvTranspose, Crop",
    "'resnet_v1_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v1_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_50'          : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'resnet_v2_152'         : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "'nasnet-a_large'        : [onnx_emit], # POOL: strides > window_shape not supported due to inconsistency between CPU and GPU implementations",
    "TODO: coredump",
    "'alexnet'       : [cntk_emit, keras_emit, tensorflow_emit],",
    "'nasnet'       : [tensorflow_emit, keras_emit, coreml_emit],",
    "'facenet'      : [tensorflow_emit, coreml_emit,mxnet_emit,keras_emit]  # TODO",
    "'vgg16': [tensorflow_emit],",
    "'alexnet': [tensorflow_emit]",
    "get original model prediction result",
    "def test_caffe(self):",
    "try:",
    "import caffe",
    "self._test_function('caffe', self.caffe_parse)",
    "except ImportError:",
    "print('Please install caffe! Or caffe is not supported in your platform.', file=sys.stderr)",
    "def test_cntk(self):",
    "try:",
    "import cntk",
    "self._test_function('cntk', self.cntk_parse)",
    "except ImportError:",
    "print('Please install cntk! Or cntk is not supported in your platform.', file=sys.stderr)",
    "def test_coreml(self):",
    "from coremltools.models.utils import macos_version",
    "if macos_version() < (10, 13):",
    "print('Coreml is not supported in your platform.', file=sys.stderr)",
    "else:",
    "self._test_function('coreml', self.coreml_parse)",
    "def test_keras(self):",
    "self._test_function('keras', self.keras_parse)",
    "def test_mxnet(self):",
    "self._test_function('mxnet', self.mxnet_parse)",
    "def test_darknet(self):",
    "self._test_function('darknet', self.darknet_parse)",
    "def test_paddle(self):",
    "# omit tensorflow lead to crash",
    "import tensorflow as tf",
    "try:",
    "import paddle.v2 as paddle",
    "self._test_function('paddle', self.paddle_parse)",
    "except ImportError:",
    "print('Please install Paddlepaddle! Or Paddlepaddle is not supported in your platform.', file=sys.stderr)",
    "def test_pytorch(self):",
    "self._test_function('pytorch', self.pytorch_parse)",
    "def test_tensorflow(self):",
    "self._test_function('tensorflow', self.tensorflow_parse)",
    "def test_tensorflow_frozen(self):",
    "self._test_function('tensorflow_frozen', self.tensorflow_frozen_parse)",
    "'vgg19'         : [TestModels.onnx_emit],",
    "'voc-fcn8s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'vgg19'         : [TestModels.caffe_emit, TestModels.cntk_emit, TestModels.coreml_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'voc-fcn8s'     : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'voc-fcn16s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'voc-fcn32s'    : [TestModels.cntk_emit, TestModels.coreml_emit, TestModels.tensorflow_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "'vgg19'         : [TestModels.onnx_emit],",
    "'alexnet'       : [TestModels.caffe_emit, TestModels.cntk_emit, TestModels.coreml_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'nasnet-a_large'       : [TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'inception_resnet_v2'  : [TestModels.caffe_emit, TestModels.keras_emit, TestModels.mxnet_emit, TestModels.pytorch_emit, TestModels.tensorflow_emit],",
    "'xception'     : [TestModels.onnx_emit],",
    "'nasnet'       : [TestModels.onnx_emit],",
    "!/usr/bin/python",
    "major python major_python_versions as python2 and python3",
    "operating system",
    "do not deal",
    "I don't want to deal with auto_pad",
    "Don't support auto_pad current!",
    "2018-02-28",
    "if group is None:",
    "group = 1",
    "group is not support yet too.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "node",
    "input",
    "edge(node a <-> node b)",
    "",
    "key is edge name, value is src/dst node name",
    "key is initializer name, value is TensorProto",
    "print(name)",
    "print(layer.op_type)",
    "n is input data",
    "n is input edge",
    "omit node of some type",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "if node len(in_edges), generate additional DataInput node",
    "print",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "TODO",
    "'max_pool2d': convert_maxpool,",
    "'onnx::Mul': convert_elementwise_mul,",
    "'onnx::Sub': convert_elementwise_sub,",
    "'onnx::ConvTranspose': convert_convtranspose,",
    "'onnx::LeakyRelu': convert_lrelu,",
    "'onnx::Sigmoid': convert_sigmoid,",
    "'onnx::Softmax': convert_softmax,",
    "'onnx::Selu': convert_selu,",
    "'onnx::Transpose': convert_transpose,",
    "'onnx::Reshape': convert_reshape,",
    "'onnx::MatMul': convert_matmul,",
    "'onnx::Gather': convert_gather,",
    "'onnx::ReduceSum': convert_reduce_sum,",
    "'onnx::Constant': convert_constant,",
    "'onnx::Upsample': convert_upsample,",
    "'onnx::Pad': convert_padding,",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "test",
    "cpu: https://github.com/pytorch/pytorch/issues/5286",
    "Build network graph",
    "(batch, C, H, W)  & NHWC",
    "#########",
    "Layers #",
    "#########",
    "dilation",
    "handle bias",
    "TODO",
    "output_shape",
    "epsilon",
    "mean",
    "var",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "use_bias",
    "units",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Scopes created in a nested scope may have initial characters",
    "that are illegal as the initial character of an op name",
    "(viz. '-', '\\', '/', and '_').",
    "sanity check.",
    "run dce first to eliminate dead parts of the graph that might have been",
    "left behind by things like symbolic_override",
    "construct graph",
    "nodes",
    "input layer",
    "TODO",
    "build each layer",
    "input",
    "print(node_input_name ,'->', node_name)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "padding,",
    "exstr = \", value=float('-Inf')\"",
    "exstr = \"\"",
    "Change to padding defuse",
    "input_node = self._defuse_padding(IR_node, exstr)",
    "Ignore it in Pytorch",
    "for Keras",
    "self.add_init(2, \"self.{:<15} = torch.from_numpy(__weights_dict['{}']['value'])\".format(",
    "IR_node.variable_name,",
    "IR_node.name))",
    "param_code does not need parameter slice.",
    "from torch.nn.parameter import Parameter",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._type = layer.__class__.__name__.replace('Backward', '')",
    "self._name = \"{}_{}\".format(self.type, id)",
    "TODO",
    "\"\"\"",
    "build graph for pytorch 0.2.0",
    "\"\"\"",
    "dummy_input = torch.autograd.Variable(torch.randn(shape))",
    "output_node = self.model(dummy_input)",
    "search_queue = [output_node.grad_fn]",
    "tmp_node = PyTorchGraphNode(output_node.grad_fn, 0)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "visited = {output_node.grad_fn : self.layer_map[tmp_node.name]}",
    "idx = 0",
    "node_count = 1",
    "while (idx < len(search_queue)):",
    "current_node = search_queue[idx]",
    "current_type = visited[current_node].type",
    "if hasattr(current_node, 'next_functions'):",
    "for parent, _ in current_node.next_functions:",
    "parent_type = parent.__class__.__name__.replace('Backward', '')",
    "if parent_type != 'AccumulateGrad' and \\",
    "(parent_type != 'Transpose' or current_type != 'Addmm'):",
    "if not parent in visited:",
    "tmp_node = PyTorchGraphNode(parent, node_count)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "node_count += 1",
    "visited[parent] = tmp_node",
    "search_queue.append(parent)",
    "self._make_connection(visited[parent].name, visited[current_node].name)",
    "idx += 1",
    "try:",
    "return TorchGraph._forward_torch_random_input(",
    "torch_model,",
    "input_shapes,",
    "is_batch=False",
    ")",
    "except:",
    "# try batch mode",
    "# return TorchGraph._forward_torch_random_input(",
    "#     torch_model,",
    "#     input_shapes,",
    "#     is_batch=True",
    "# )",
    "pass",
    "tensor = torch.rand(*shape).float()",
    "multi output",
    "single output",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "Build network graph",
    "#########",
    "Layers #",
    "#########",
    "handle weight",
    "handle bias",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "load model file into Coreml Graph",
    "model.encode() convert to str --- python2 may crash due to type 'unicode'",
    "Build Network Graph",
    "self.data_format ? TODO",
    "load the model network",
    "convert to Model_pb2.Model",
    "determine the type of the current_node",
    "staticmethods",
    "(seq, batch, C, H, W)  & NHWC",
    "TODO dtype_map",
    "##### convert methods",
    "convolution",
    "input edge",
    "important!",
    "reshape the weight!",
    "[2, 3, 0, 1]",
    "pads",
    "use_bias",
    "isDeconvolution",
    "name, op",
    "kwargs['kernel_shape'] = weights.shape",
    "strides",
    "[1, sd, sh, sw, 1]",
    "activation",
    "TODO",
    "padding in conv",
    "pad in IR is [x1_b, x2_b, ..., x1_e, x2_e, ...]",
    "padding",
    "compute padding for 'same'",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "https://www.jianshu.com/p/05c4f1621c7e",
    "padding in pooling",
    "padding",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "TODO",
    "symmetric padding",
    "name, op",
    "input edge",
    "For concat axis",
    "NO axis in coreml, so set the last axis",
    "The first -1 means in coreml there is one-more axis,",
    "The second -1 means the last axis",
    "name, op",
    "input edge",
    "padding",
    "Future Module TODO",
    "#### rename methods",
    "name, op",
    "activation type",
    "else:",
    "assert False",
    "input edge",
    "Merge layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "NHWC channel last",
    "in fact, here is NWHC",
    "name, op",
    "input edge",
    "axis TODO",
    "channels_first, then axis = 1",
    "scale",
    "bias",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "mean",
    "var",
    "name, op",
    "input edge",
    "bias",
    "name, op",
    "input edge",
    "MAX = 0, AVERAGE = 1, L2 = 2",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "change to single because of the tf matmul",
    "name, op",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "the end of the tensorflow_resnet_v2_50's squeeze shape is [unknown_rank: true] with len 0",
    "1001 means the 1001 classes for tensorflow_resnet_v2_50",
    "!Alert! TODO",
    "Future implement can be changed to the last two layer",
    "TODO - remove style transfer 1D hack",
    "Input is 1D but it goes to the width dimension: (1,1,W)",
    "assume (Batch, Channels) - Batch dimension should be dropped",
    "assume (Batch, Sequence-Length, channels)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Add classifier classes (if applicable)",
    "Set pre-processing paramsters",
    "image_input_names,",
    "Return the protobuf spec",
    "model = _MLModel(self.builder.spec)",
    "if IR_node.name in self.weights_dict and 'weights' in self.weights_dict[IR_node.name]:",
    "pass",
    "self._emit_merge(IR_node,'DOT')",
    "Get input and output names",
    "Dimensions and weights",
    "W should have shape (height, width, kernel_channels, output_channels), where kernel_channel = input_channels / groups",
    "Dilations",
    "see protobuf",
    "assert False",
    "Get the weights.",
    "Dilations",
    "see protobuf",
    "depth-wise convolution",
    "Dilations",
    "see protobuf",
    "Get input and output names",
    "Pooling layer type",
    "if it's global, set the global flag",
    "TODO  global pooling modification",
    "Padding",
    "see protobuf",
    "Padding",
    "see protobuf",
    "Get input and output names",
    "type: \"list(int). A 1-D values of (leftBorder, topBorder, rightBorder, bottomBorder).\"",
    "This is central crop",
    "Now add the layer",
    "Allowed values: 'CHW', 'HW', 'C', 'H', 'W'",
    "Get input and output names",
    "Get input and output names",
    "Get the weights from keras",
    "Get input and output names",
    "blob_order == 0 if the input blob needs not be rearranged",
    "blob_order == 1 if the input blob needs to be rearranged",
    "using keras_layer.input.shape have a \"?\" (Dimension[None] at the front),",
    "making a 3D tensor with unknown batch size 4D",
    "Get input and output names",
    "activation emit",
    "Get input and output names",
    "negate it",
    "apply threshold",
    "negate it back",
    "for Keras",
    "Get input and output names",
    "Set parameters",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "padding type TODO",
    "Type of the padding. Can be one of 'constant', 'reflection' or 'replication",
    "Now add the layer",
    "self.emit_Flatten(IR_node)",
    "depth_radius: Half-width of the 1-D normalization window.\"",
    "Get the weights",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "input layer",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "The information of the layer",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "print(node.parameters)",
    "assert False",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "if parent.output_shape.height > 1 or parent.output_shape.width > 1:",
    "TODO: The gamma parameter has to be set (in node.data?) and this should work.",
    "Also, mean should be set to 0, and var to 1, just to be safe.",
    "skip the split node",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For some reason argparser gives us unicode, so we need to conver to str first",
    "for test",
    "with open(\"graph.txt\", 'w') as f:",
    "for layer in self.IR_graph.topological_sort:",
    "current_node = self.IR_graph.get_node(layer)",
    "print(\"========current_node=========\\n{}\".format(current_node.layer), file=f)",
    "test end",
    "print(\"========current_node={}\".format(current_node.layer))",
    "check if have pad layer",
    "Pad_h < kernel_h (vgg19 caffe2caffe)",
    "implement asymmetric paddings by applying symmetric padding then cropping",
    "keys = []",
    "for key in self.weights_dict[IR_node.name].keys():",
    "keys.append(key)",
    "print(\"=======Layer: {}, keys: {}\".format(IR_node.name, keys))",
    "if asymmetric padding, set offset to 1",
    "Change the layer name",
    "check if need crop output shape",
    "change the key \"name\" to \"variable_name\", in case of the layer name has invalid characters",
    "Convert NHWC (IR) to NCHW (Caffe): [0,1,2,3]->[0,3,1,2]",
    "def emit_Square(self, IR_node):",
    "input_layers = ', '.join(('n.' + self.IR_graph.get_node(edge).real_variable_name) for edge in IR_node.in_edges)",
    "self.add_body(1, \"n.{:<15} = L.Square({}, ntop=1)\".format(",
    "IR_node.variable_name,",
    "input_layers))",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "self.graph = NodeRenamer()(graph)",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "assert mapped_node is not None",
    "skip when mapped_node is None",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "try:",
    "except ImportError:",
    "# # Fall back to the protobuf implementation",
    "# from mmdnn.conversion.caffe import caffe_pb2",
    "# self.caffepb = caffe_pb2",
    "# show_fallback_warning()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from tensorflow.core.framework.node_def_pb2 import NodeDef",
    "from tensorflow.core.framework import attr_value_pb2",
    "pass",
    "print(\"\\n\")",
    "print(i)",
    "print(block)",
    "continue",
    "NHWC",
    "assert False",
    "print(shortcut_layer['input'] )",
    "spacetodepth",
    "print(block)",
    "print(region_layer)",
    "assert False",
    "print line",
    "set default value",
    "yolo3(608) start at 1, yolo2(608) start at 0. yolo2(416) start at 1, yolo3(416) start at 0",
    "load weight by original order",
    "print(node_type)",
    "print(IR_node)",
    "assert False",
    "strides",
    "assert False",
    "padding",
    "only load weight conv",
    "print(\"----------------\",self.start)",
    "print(kernel.shape)",
    "print(k_bias.shape)",
    "buf, start, scale_layer['name'], bn_layer['name'], conv_layer['name']",
    "print(\"==============\",self.start)",
    "print(bias.shape)",
    "print(scale.shape)",
    "print(mean.shape)",
    "print(var.shape)",
    "print(kernel.shape)",
    "print(W)",
    "assert False",
    "no use",
    "print(source_node.layer)",
    "for image classification(resnet) AVG pooling",
    "print(source_node.layer)",
    "print(source_node.layer)",
    "kwargs['ignore_thresh'] = source_node.get_attr('ignore_thresh')",
    "print(source_node.get_attr('anchors'))",
    "kwargs['anchors'] = ['0.52','0.22']",
    "kwargs['mask'] = source_node.get_attr('mask')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "tensorflow dump tag",
    "Reference: 1) Keras image preprocess: https://github.com/keras-team/keras/blob/master/keras/applications/imagenet_utils.py",
    "2) tensorflow github issue: https://github.com/tensorflow/models/issues/517",
    "R-G-B for Imagenet === [123.68, 116.78, 103.94]",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load a real image and do default tf imageNet preprocessing",
    "[Batch, Height, Width, Channels] --> [Batch, Channels, Height, Width]",
    "We only deal with non-recurrent networks for now",
    "(H,W,C) --> (C,H,W)",
    "Load TensorFlow model",
    "Prepare inputs",
    "Run TF session",
    "Evaluate coreml model",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "@unittest.skip(\"Failing GPU backend: related to https://github.com/tf-coreml/tf-coreml/issues/26\")",
    "? style transfer image size and style number?",
    "Test predictions on an image",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "compare_tf_coreml_outputs(tf_out_flatten, coreml_out_flatten)",
    "#Download model",
    "url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception_v3_2016_08_28_frozen.pb.tar.gz'",
    "tf_model_dir = _download_file(url = url)",
    "tf_model_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28_frozen.pb')",
    "#Convert to coreml",
    "mlmodel_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28.mlmodel')",
    "mlmodel = tf_converter.convert(",
    "tf_model_path = tf_model_path,",
    "mlmodel_path = mlmodel_path,",
    "output_feature_names = ['InceptionV3/Predictions/Softmax:0'],",
    "input_name_shape_dict = {'input:0':[1,299,299,3]},",
    "image_input_names = ['input:0'],",
    "red_bias = -1,",
    "green_bias = -1,",
    "blue_bias = -1,",
    "image_scale = 2.0/255.0)",
    "#Test predictions on an image",
    "_test_coreml_model_image_input(",
    "tf_model_path = tf_model_path,",
    "coreml_model = mlmodel,",
    "input_tensor_name = 'input:0',",
    "output_tensor_name = 'InceptionV3/Predictions/Softmax:0',",
    "img_size = 299)",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "self.test_truth()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from collections import namedtuple",
    "Batch = namedtuple('Batch', ['data'])",
    "TODO",
    "Apple has published some of their own models. They can be downloaded from https://developer.apple.com/machine-learning/.",
    "Those published models are: SqueezeNet, Places205-GoogLeNet, ResNet50, Inception v3, VGG16",
    "TODO",
    "load model",
    "TODO: Multiple inputs",
    "TODO: Multiple outputs",
    "inference",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "caffe uses NCHW",
    "self.print_intermediate_result('pooling0', False)",
    "delete tmp model files",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "net = caffe.Net(arch_fn, weight_fn, caffe.TEST)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "# Image Classification",
    "# Semantic Segmentation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "print(r)",
    "d = darknet_extractor()",
    "model_filename = d.download('yolov3')",
    "print(model_filename)",
    "image_path = \"./mmdnn/conversion/examples/data/dog.jpg\"",
    "model_path = \"./\"",
    "d = darknet_extractor()",
    "result = d.inference('yolov3', model_filename, model_path, image_path = image_path)",
    "print(result)",
    "print(i)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('pooling0', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "need to be updated",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "raise NotImplementedError()",
    "load file",
    "Using cuDNN since vanilla RNN",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Notes for training NASNet Cifar Model",
    "-------------------------------------",
    "batch_size: 32",
    "learning rate: 0.025",
    "cosine (single period) learning rate decay",
    "auxiliary head loss weighting: 0.4",
    "clip global norm of all gradients by 5",
    "600 epochs with a batch size of 32",
    "This is used for the drop path probabilities since it needs to increase",
    "the drop out probability over the course of training.",
    "Notes for training large NASNet model on ImageNet",
    "-------------------------------------",
    "batch size (per replica): 16",
    "learning rate: 0.015 * 100",
    "learning rate decay factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 100 replicas",
    "auxiliary head loss weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Notes for training the mobile NASNet ImageNet model",
    "-------------------------------------",
    "batch size (per replica): 32",
    "learning rate: 0.04 * 50",
    "learning rate scaling factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 50 replicas",
    "auxiliary head weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Shape of feature map before the final layer.",
    "149 x 149 x 32",
    "Run the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Find where to place the reduction cells or stride normal cells",
    "Setup for building in the auxiliary head.",
    "Run the cells",
    "true_cell_num accounts for the stem cells",
    "Final softmax layer",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 192",
    "35 x 35 x 320",
    "TODO(alemi): Register intermediate endpoints",
    "17 x 17 x 1088 if output_stride == 8,",
    "33 x 33 x 1088 if output_stride == 16",
    "TODO(alemi): register intermediate endpoints",
    "TODO(gpapan): Properly support output_stride for the rest of the net.",
    "8 x 8 x 2080",
    "TODO(alemi): register intermediate endpoints",
    "8 x 8 x 1536",
    "TODO(sguada,arnoegw): Consider adding a parameter global_pool which",
    "can be set to False to disable pooling here (as in resnet_*()).",
    "Set weight_decay for weights in conv2d and fully_connected layers.",
    "Set activation_fn and parameters for batch_norm.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "=============================================================================",
    "Tensorflow mandates these.",
    "Conv and DepthSepConv namedtuple define layers of the MobileNet architecture",
    "Conv defines 3x3 convolution layers",
    "DepthSepConv defines 3x3 depthwise convolution followed by 1x1 convolution.",
    "stride is the stride of the convolution",
    "depth is the number of channels or filters in a layer",
    "_CONV_DEFS specifies the MobileNet body",
    "Used to find thinned depths for each layer.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "By passing filters=None",
    "separable_conv2d produces only a depthwise convolution layer",
    "Global average pooling.",
    "Pooling with a fixed kernel size.",
    "1 x 1 x 1024",
    "Set weight_decay for weights in Conv and DepthSepConv layers.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Skip path 1",
    "Skip path 2",
    "First pad with 0's on the right and bottom, then shift the filter to",
    "include those 0's that were added.",
    "Concat and apply BN",
    "Set the prev layer to the current layer if it is none",
    "Check to be sure prev layer stuff is setup correctly",
    "Apply conv operations",
    "Combine hidden states using 'add'.",
    "Add hiddenstate to the list of hiddenstates we can choose from",
    "Dont stride if this is not one of the original hiddenstates",
    "Check if a stride is needed, then use a strided 1x1 here",
    "Determine if a reduction should be applied to make the number of",
    "filters match.",
    "Return the concat of all the states",
    "Scale keep prob by layer number",
    "The added 2 is for the reduction cells",
    "Decrease the keep probability over time",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Inception-Resnet-A",
    "Inception-Resnet-B",
    "Inception-Resnet-C",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "force in-place updates of mean and variance estimates",
    "Moving averages ends up in the trainable variables collection",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 256",
    "5 x Inception-resnet-A",
    "Reduction-A",
    "10 x Inception-Resnet-B",
    "Reduction-B",
    "5 x Inception-Resnet-C",
    "pylint: disable=no-member",
    "net = slim.fully_connected(net, bottleneck_layer_size, activation_fn=None,",
    "scope='Bottleneck', reuse=False)",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Note: want to round down, we adjust each split to match the total.",
    "We use scope_depthwise, scope_pointwise for compatibility with V1 ckpts.",
    "which provide numbered scopes.",
    "b1 -> b2 * r -> b2",
    "i -> (o * r) (bottleneck) -> o",
    "Note in contrast with expansion, we always have",
    "projection to produce the desired output size.",
    "stride check enforces that we don't add residuals when spatial",
    "dimensions are None",
    "Depth matches",
    "Don't do any splitting if we end up with less than 8 filters",
    "on either side.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Set conv defs defaults and overrides.",
    "a) Set the tensorflow scope",
    "b) set padding to default: note we might consider removing this",
    "since it is also set by mobilenet_scope",
    "c) set all defaults",
    "d) set all extra overrides.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "Insert default parameters before the base scope which includes",
    "any custom overrides set in mobilenet.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "Update params.",
    "Only insert rate to params if rate > 1.",
    "Set padding",
    "Add all tensors that end with 'output' to",
    "endpoints",
    "1 x 1 x num_classes",
    "Note: legacy scope name.",
    "Recover output shape, for unknown shape.",
    "the network created will be trainble with dropout/batch norm",
    "initialized appropriately.",
    "Note: do not introduce parameters that would change the inference",
    "model here (for example whether to use bias), modify conv_def instead.",
    "Set weight_decay for weights in Conv and FC layers.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "pyformat: disable",
    "Architecture: https://arxiv.org/abs/1801.04381",
    "Note: these parameters of batch norm affect the architecture",
    "that's why they are here and not in training_scope.",
    "pyformat: enable",
    "NB: do not set depth_args unless they are provided to avoid overriding",
    "whatever default depth_multiplier might have thanks to arg_scope.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "import self.model",
    "self.model",
    "how the model can not load from `***.bin`",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "refer to https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/v2/tests/test_rnn_layer.py#L35",
    "refer to https://github.com/PaddlePaddle/Paddle/issues/7403",
    "the channel of input feature is 3",
    "depth should be one of 20, 32, 44, 56, 110, 1202",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.anchors = np.array([[10,13], [16,30],[33,23],[30,61],[62,45], [59,119],[116,90],[156,198],[373,326]])",
    "print(output)",
    "print(out_boxes, out_scores, out_classes)",
    "get random colors",
    "My kingdom for a good redistributable image drawing library.",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "yolov3 80 classes",
    "Reshape to batch, height, width, num_anchors, box_params.",
    "Adjust preditions to each spatial grid point and anchor size.",
    "Note: YOLO iterates over height index before width index.",
    "TODO: It works with +1, don't know why.",
    "Scale boxes back to original image shape.",
    "print(\"feats,anchors, num_classes, input_shape\", feats, anchors, num_classes, input_shape)",
    "print(box_xy, box_wh, box_confidence, box_class_probs)",
    "yolo_outputs order 13,26,52",
    "TODO: use keras backend instead of tf.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Convert network architecture only",
    "MXNet",
    "Caffe",
    "For CoreML",
    "Caffe",
    "Darknet",
    "exts = ['.pb', '.npy', '.py']",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "We use the real_name for specifying the input layer in data_names",
    "since MXNet API wants the actual name of the layer. On the other",
    "hand, the module API wants the last symbol in the symbol chain, so",
    "for the output node we need to use the actual python variable name",
    "of the last layer (real_variable_name).",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if layout not in MXNetEmitter.channels_last:",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "def emit_ConvTranspose(self, IR_node):",
    "if self.weight_loaded:",
    "weight_dict = self.weights[IR_node.name]",
    "weights = weight_dict['weights']",
    "dim = len(IR_node.IR_layer.attr[\"kernel_shape\"].list.i) - 2",
    "kernel = list()",
    "for idx in range(0, dim):",
    "kernel.append(IR_node.IR_layer.attr[\"kernel_shape\"].list.i[idx])",
    "stride = list()",
    "for e in IR_node.IR_layer.attr[\"strides\"].list.i[1:-1]:",
    "stride.append(e)",
    "dilate = list()",
    "for e in IR_node.IR_layer.attr[\"dilations\"].list.i[1:-1]:",
    "dilate.append(e)",
    "dilate = ', '.join('%s' % i for i in dilate)",
    "defuse_pad = False",
    "pad = list()",
    "if \"pads\" in IR_node.IR_layer.attr:",
    "output_shape = list()",
    "for e in IR_node.IR_layer.attr[\"_output_shapes\"].list.shape[0].dim:",
    "output_shape.append(e.size)",
    "# print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "defuse_pad, pad = MXNetEmitter.transfer_pad(IR_node.IR_layer.attr[\"pads\"].list.i)",
    "pad = ', '.join('%s' % i for i in pad)",
    "kernel = ', '.join('%s' % i for i in kernel)",
    "stride = ', '.join('%s' % i for i in stride)",
    "num_filter = IR_node.IR_layer.attr[\"kernel_shape\"].list.i[-2]",
    "no_bias = not IR_node.IR_layer.attr[\"use_bias\"].b",
    "if not no_bias and self.weight_loaded:",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_bias\"] = weight_dict['bias']",
    "# layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NCHW'",
    "elif dim == 3:",
    "layout = 'NCDHW'",
    "if self.weight_loaded:",
    "# if layout not in MXNetEmitter.channels_last:",
    "weights = MXNetEmitter.transpose(weights, dim)",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_weight\"] = weights",
    "code = \"\"",
    "if not defuse_pad:",
    "code = \"{:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), pad = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "kernel,",
    "stride,",
    "dilate,",
    "pad,",
    "num_filter,",
    "no_bias,",
    "layout,",
    "IR_node.replace_scope(IR_node.name))",
    "else:",
    "code = self.set_pad(IR_node, code, pad)",
    "code += \"\\n    {:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name) + \"_pad\", kernel, stride, dilate, num_filter, no_bias, layout, IR_node.replace_scope(IR_node.name))",
    "return code",
    "reverse cannot support yet",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(\"trans\", self.parent_variable_name(IR_node))",
    "save the constant into weight dict",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "Load the model network and weights",
    "digraph = mx.viz.plot_network(sym, save_format='jpg') # For debugging",
    "digraph.render()",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "load the model network",
    "adjust the data format",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "for e in pad:",
    "IR_node.attr[\"pads\"].list.i.extend([e, e])",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "name, op",
    "input edge",
    "units",
    "use bias (no_bias default = False)",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "input edge",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "groups",
    "in_channel = in_channel // group",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "padding",
    "weights",
    "axis",
    "scale",
    "epsilon",
    "momentum",
    "weights",
    "gamma",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "kernel_shape",
    "padding",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "dim",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "weights",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "IR only support elu and prelu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "return",
    "name, op",
    "gamma",
    "input edge",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "alpha",
    "beta",
    "knorm",
    "nsize",
    "keep_prob",
    "mode",
    "reverse cannot support yet",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "dim",
    "dtype",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "axis",
    "raise NotImplementedError(\"No matching IR api\")",
    "left strip the \"_\" at the beginning of the name",
    "Issue #85, #135",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "print(moving_variance.name)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into TensorFlow graph",
    "extract subgraph using in_nodes and dest_nodes",
    "Build network graph",
    "extract subgraph using dest_nodes",
    "Graph Transform",
    "Get input node name",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Matmul Layer",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "print (source_node)",
    "print (source_node.layer)",
    "assert False",
    "def rename_RandomShuffleQueueV2(self, source_node):",
    "# print(source_node.layer)",
    "IR_node = self._convert_identity_operation(source_node, in_edge_count = 0, new_op = 'DataInput')",
    "# IR_node.attr['shape'].shape.MergeFromString(source_node.layer.attr['_output_shapes'].list.shape[0].SerializeToString())",
    "# IR_node.attr['shape'].shape.dim[0].size = -1",
    "IR_node.attr['dtype'].type = self.dtype_map[source_node.layer.attr['component_types'].list.type[0]]",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "TODO: Current it is only for slice",
    "TODO:  only for 1D",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "check whether flatten operator should be added",
    "flatten is needed",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "param_code does not need parameter slice.",
    "skip_prefix = [",
    "\"^\",",
    "\"train_op\",",
    "\"save\",",
    "\"gradients\",",
    "\"init\",",
    "\"global_step\",",
    "\"distort_image\",",
    "\"Adagrad\",",
    "]",
    "\"Switch\"",
    "\"RequantizationRange\",",
    "\"Requantize\",",
    "\"Identity\",",
    "\"Mean\",",
    "\"Cast\"",
    "load model files into TensorFlow graph",
    "Save it to an output file",
    "keep dims",
    "axes",
    "ssd model is transformed",
    "Ax - (Au - b)",
    "A",
    "b",
    "print(sub_content)",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "print(Rsqrt.out_edges)",
    "beta  (bias)",
    "moving mean (mean)",
    "input node",
    "epsilon",
    "beta",
    "gamma (scale)",
    "output_node = self.get_son(source_node.name, [0, 0, 0, 0], True)",
    "assert False",
    "Quantized model type",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "assert variable.get_attr('_output_shapes')[0].dim[0].size == IR_node.attr['kernel_shape'].list.i[-1]",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "In facenet or other newtwork using slim.batch_norm,",
    "There are two BN(train, test) skip switch and merge.",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "beta  (bias)",
    "moving mean (mean)",
    "ReduceMean",
    "keep dims",
    "axes",
    "Skip the node as merge",
    "weights",
    "alpha",
    "beta",
    "Skip BiasAdd",
    "weights",
    "input_node_perm = self.check_const(self.get_parent(source_node.name, [1], True))",
    "paddings",
    "for attr.shape >= 2",
    "For models built by slim.batch_norm, remove duplicate BN (eg.facenet)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "PaddleParser._set_output_shape(source_node, IR_node)",
    "name, op",
    "input edge",
    "For concat axis",
    "only for training",
    "name, op",
    "input edge",
    "input edge",
    "layer and spec",
    "width <=> x or height <=> y",
    "output shape",
    "name, op",
    "it should be in the shape of height x width x inputchannel x outputchannel",
    "use_bias: TODO",
    "pad_dim",
    "fail report because of auto_pad",
    "if dilation_x == 1 and dilation_y == 1:",
    "if output_x * stride_x == input_x and output_y * stride_y == input_y:",
    "auto_pad = \"SAME\"",
    "kwargs['auto_pad'] = auto_pad",
    "elif output_x * stride_x == input_x - width + 1 and output_y * stride_y == input_y - height + 1:",
    "auto_pad = \"VALID\"",
    "kwargs['auto_pad'] = auto_pad",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "channels_first, then axis = 1",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "flatten",
    "mean",
    "var",
    "defuse the activation layer",
    "name, op",
    "input edge",
    "layer and spec",
    "assert False",
    "output shape",
    "pad_dim",
    "padding mode",
    "If padding == \"SAME\": output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])",
    "If padding == \"VALID\": output_spatial_shape[i] = ceil((input_spatial_shape[i] - (spatial_filter_shape[i]-1) * dilation_rate[i]) / strides[i]).",
    "name, op",
    "input edge",
    "layer and spec",
    "units",
    "output shape",
    "use_bias",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "need the shape TODO",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "name, op",
    "input edge",
    "layer and spec",
    "output shape",
    "alpha",
    "beta",
    "nsize",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "TODO: Handle square",
    "self._print_layer(source_node)",
    "print (source_node.name)",
    "print (self.src_graph.get_parent(source_node.name, [0]).real_name)",
    "assert False",
    "Convolution",
    "Kernel",
    "Attributes",
    "Bias",
    "Activation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "BlockFunction node",
    "redirect the composite's inputs to the true inputs",
    "BlockFunctions are short-circuited, and not added to accum[]",
    "Function node",
    "OutputVariable node",
    "def build(self):",
    "_traverse_graph(self, self.model.root_function)",
    "super(CntkGraph, self).build()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "IR_node.get_attr('output_dim'),",
    "??",
    "print(IR_node.layer)",
    "assert False",
    "def emit_Unstack(self, IR_node):",
    "num_str = \"{}.shape[{}]\".format(self.parent_variable_name(IR_node), IR_node.get_attr('axis'))",
    "axis = IR_node.get_attr('axis')",
    "parent_variable_shape = \"list({}.shape)\".format(self.parent_variable_name(IR_node)",
    "if self.IR_graph.get_parent(IR_node.name, [0]).type != 'Embedding'",
    "else self.parent_variable_name(IR_node)+'.E')",
    "if axis==1:",
    "shape_str = \"tuple([{}[0]*{}[{}], 1].extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "else:",
    "shape_str = \"tuple([{}[0]*{}[{}]].extend({}[1:{}]).append(1).extend({}[{}+1:]))\".format(",
    "parent_variable_shape,",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis),",
    "parent_variable_shape,",
    "str(axis))",
    "code = \"{:<15} = cntk.reshape({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "shape_str,",
    "IR_node.variable_name)",
    "code = \"{: <15} = cntk.reshape({}, {}.shape, name='{}')\".format(",
    "IR_node.variable_name,",
    "self.parent_variable_name(IR_node),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name",
    ")",
    "return code",
    "def emit_Fill(self, IR_node):",
    "code = \"{:<15} = cntk.Constant({}, {}, name='{}')\".format(",
    "IR_node.variable_name,",
    "IR_node.get_attr('value'),",
    "self.parent_variable_name(IR_node),",
    "IR_node.name)",
    "return code",
    "param_code does not need parameter slice.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "network library",
    "not support multi-threads download",
    "key: layer_name    value: keras layer",
    "private functions",
    "next_node_info.left_in_edges -= 1",
    "print ('{} --> {}'.format(src, dst))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "If pattern.inputs is empty, skips the rest and accepts all the inputs.",
    "If order doesn't matter for the inputs, then make sure we match at least",
    "one permutation of the inputs.",
    "def get_tensor(self, pattern_or_name):",
    "op_tensor = self._get_op_tensor(pattern_or_name)",
    "return op_tensor[1] if op_tensor else None",
    "pylint: disable=protected-access",
    "pylint: enable=protected-access",
    "Python 3.3.2+ implements `yield from`, but for now:",
    "check the same pattern scope node whether have same inputs, outputs and weights.",
    "For those don't have, rename their scope names.",
    "clear out scope node, typically input constant node.",
    "get sub_scopes",
    "decline the suffix number",
    "Obtain nodes where the scope name that satisfies top_level is top_scope and sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in sub_level is sub_scope",
    "Obtain nodes where the scope name that satisfies in top_level is top_scope",
    "Obtain all nodes grouped by sub_level sub_scope",
    "cover the node",
    "store idx, node into a dict and sort it later to keep its topology sort.",
    "in_node's out edges replace n_name with scope node name.",
    "no out nodes means the last node in scope nodes should be returned",
    "if out_node is scope node, replace the scope node's inner topology list node.",
    "the input parameter shoule be sliced when call func.",
    "modify the in_edges in scope inner nodes. decline the :idx.",
    "1. initilize scope node",
    "2. get scope nodes' topology list.",
    "3. rebuild the edges connection after folding these scope nodes into one node and",
    "get this scope node's return variables.",
    "4. rebuild graph.",
    "RNN-related attrs.",
    "get input params",
    "self.store_const_to_top(result)",
    "self.set_top_node_prop(result, pattern_name)",
    "Do not include input op.",
    "TODO: pytorch, mxnet, keras, cntk",
    "-*- coding: utf-8 -*-",
    "from keras.layers.core import Layer",
    "Arguments",
    "Input shape",
    "Output shape",
    "Prepare broadcasting shape.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "Keras 2.1.6",
    "Keras. 2.2.2",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "size",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "weights",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "for target shape",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot weights",
    "print(\"Converting layer {}({})\".format(current_node.name, node_type))",
    "TODO",
    "return input_node, 'same'",
    "assert IR_node.get_attr('group', 1) == 1",
    "change dw from filters to 1",
    "reset the default dilation",
    "############",
    "Operators #",
    "############",
    "code = self._emit_merge(IR_node, \"subtract\")",
    "TODO",
    "when converting from coreml model, reshape is needed after the global pooling",
    "for Keras",
    "It arouses some problems:",
    "it can be implemented by Lambda Layer",
    "https://github.com/keras-team/keras/issues/890",
    "Keras == 2.1.6",
    "Keras == 2.2.2",
    "TODO: arguments won't be saved in keras export model",
    "param_code does not need parameter slice.",
    "Prepare broadcasting shape.",
    "output = Lambda(lambda x: tf.fill(x, value))(input)",
    "return output",
    "def _layer_Constant(self):",
    "self.add_body(0, '''",
    "class my_constant(keras.layers.Layer):",
    "def __init__(self, value, **kwargs):",
    "super(my_constant, self).__init__(**kwargs)",
    "self._value = value",
    "# the input is dummy, just for creating keras graph.",
    "def call(self, dummy):",
    "res = K.constant(self._value)",
    "self.output_shapes = K.int_shape(res)",
    "return res",
    "def compute_output_shape(self, input_shape):",
    "return self.output_shapes",
    "''')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "with open('modelmapbydataset.json', 'w') as outfile:",
    "json.dump(new_data, outfile)",
    "generate makedown script",
    "add Image Classification",
    "add Object Detection",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "generate makedown script",
    "MMdnn introduction",
    "steps for model conversion",
    "Generate model converter description",
    "Generate models list",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "remove list",
    "draw",
    "mode;",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "rm the '_'",
    "Base64 encode: https://developers.google.com/protocol-buffers/docs/proto3",
    "Search the node",
    "select by id: https://stackoverflow.com/questions/37270787/uncaught-syntaxerror-failed-to-execute-queryselector-on-document",
    "Scroll",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ],
  "0.2.1": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "Function self.assertEquals has deprecated, change to assertEqual",
    "self.assertEqual(original_predict.shape, converted_predict.shape)",
    "get original model prediction result",
    "original to IR",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "print(original_predict)",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "get shape",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "IR to code",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "The list is in RGB oder",
    "IR to Model",
    "converted_file = original_framework + '_coreml_' + architecture_name + \"_converted\"",
    "converted_file = converted_file.replace('.', '_')",
    "load model",
    "save model",
    "coremltools.utils.save_spec(model.get_spec(), converted_file)",
    "inference",
    "IR to code",
    "import converted model",
    "In case of odd number add the extra padding at the end for SAME_UPPER(eg. pads:[0, 2, 2, 0, 0, 3, 3, 0]) and at the beginning for SAME_LOWER(eg. pads:[0, 3, 3, 0, 0, 2, 2, 0])",
    "'alexnet'       : [CntkEmit, KerasEmit, TensorflowEmit],",
    "'inception_resnet_v2' : [TensorflowEmit], # TODO PytorchEmit",
    "get original model prediction result",
    "do not deal",
    "I don't want to deal with auto_pad",
    "Don't support auto_pad current!",
    "2018-02-28",
    "if group is None:",
    "group = 1",
    "group is not support yet too.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "node",
    "input",
    "edge(node a <-> node b)",
    "",
    "key is edge name, value is src/dst node name",
    "key is initializer name, value is TensorProto",
    "print(name)",
    "print(layer.op_type)",
    "n is input data",
    "n is input edge",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "if node len(in_edges), generate additional DataInput node",
    "print",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "TODO",
    "'max_pool2d': convert_maxpool,",
    "'onnx::Mul': convert_elementwise_mul,",
    "'onnx::Sub': convert_elementwise_sub,",
    "'onnx::ConvTranspose': convert_convtranspose,",
    "'onnx::LeakyRelu': convert_lrelu,",
    "'onnx::Sigmoid': convert_sigmoid,",
    "'onnx::Softmax': convert_softmax,",
    "'onnx::Tanh': convert_tanh,",
    "'onnx::Selu': convert_selu,",
    "'onnx::Transpose': convert_transpose,",
    "'onnx::Reshape': convert_reshape,",
    "'onnx::MatMul': convert_matmul,",
    "'onnx::Gather': convert_gather,",
    "'onnx::ReduceSum': convert_reduce_sum,",
    "'onnx::Constant': convert_constant,",
    "'onnx::Upsample': convert_upsample,",
    "'onnx::Pad': convert_padding,",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "test",
    "Build network graph",
    "(batch, C, H, W)  & NHWC",
    "#########",
    "Layers #",
    "#########",
    "dilation",
    "handle bias",
    "TODO",
    "output_shape",
    "epsilon",
    "mean",
    "var",
    "Kit weight tranpose",
    "weight: N x M -> C x H x W x M -> H x W x C x M -> N x M",
    "",
    "weights",
    "use_bias",
    "units",
    "axis",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Scopes created in a nested scope may have initial characters",
    "that are illegal as the initial character of an op name",
    "(viz. '-', '\\', '/', and '_').",
    "sanity check.",
    "run dce first to eliminate dead parts of the graph that might have been",
    "left behind by things like symbolic_override",
    "construct graph",
    "nodes",
    "input layer",
    "TODO",
    "build each layer",
    "input",
    "print(node_input_name ,'->', node_name)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "padding,",
    "exstr = \", value=float('-Inf')\"",
    "exstr = \"\"",
    "Change to padding defuse",
    "input_node = self._defuse_padding(IR_node, exstr)",
    "Ignore it in Pytorch",
    "for Keras",
    "self.add_init(2, \"self.{:<15} = torch.from_numpy(__weights_dict['{}']['value'])\".format(",
    "IR_node.variable_name,",
    "IR_node.name))",
    "from torch.nn.parameter import Parameter",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._type = layer.__class__.__name__.replace('Backward', '')",
    "self._name = \"{}_{}\".format(self.type, id)",
    "TODO",
    "\"\"\"",
    "build graph for pytorch 0.2.0",
    "\"\"\"",
    "dummy_input = torch.autograd.Variable(torch.randn(shape))",
    "output_node = self.model(dummy_input)",
    "search_queue = [output_node.grad_fn]",
    "tmp_node = PyTorchGraphNode(output_node.grad_fn, 0)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "visited = {output_node.grad_fn : self.layer_map[tmp_node.name]}",
    "idx = 0",
    "node_count = 1",
    "while (idx < len(search_queue)):",
    "current_node = search_queue[idx]",
    "current_type = visited[current_node].type",
    "if hasattr(current_node, 'next_functions'):",
    "for parent, _ in current_node.next_functions:",
    "parent_type = parent.__class__.__name__.replace('Backward', '')",
    "if parent_type != 'AccumulateGrad' and \\",
    "(parent_type != 'Transpose' or current_type != 'Addmm'):",
    "if not parent in visited:",
    "tmp_node = PyTorchGraphNode(parent, node_count)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "node_count += 1",
    "visited[parent] = tmp_node",
    "search_queue.append(parent)",
    "self._make_connection(visited[parent].name, visited[current_node].name)",
    "idx += 1",
    "try:",
    "return TorchGraph._forward_torch_random_input(",
    "torch_model,",
    "input_shapes,",
    "is_batch=False",
    ")",
    "except:",
    "# try batch mode",
    "# return TorchGraph._forward_torch_random_input(",
    "#     torch_model,",
    "#     input_shapes,",
    "#     is_batch=True",
    "# )",
    "pass",
    "tensor = torch.rand(*shape).float()",
    "multi output",
    "single output",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "Build network graph",
    "#########",
    "Layers #",
    "#########",
    "handle weight",
    "handle bias",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "load model file into Coreml Graph",
    "model.encode() convert to str --- python2 may crash due to type 'unicode'",
    "Build Network Graph",
    "self.data_format ? TODO",
    "load the model network",
    "convert to Model_pb2.Model",
    "determine the type of the current_node",
    "staticmethods",
    "(seq, batch, C, H, W)  & NHWC",
    "TODO dtype_map",
    "##### convert methods",
    "convolution",
    "input edge",
    "important!",
    "reshape the weight!",
    "[2, 3, 0, 1]",
    "pads",
    "use_bias",
    "isDeconvolution",
    "name, op",
    "kwargs['kernel_shape'] = weights.shape",
    "strides",
    "[1, sd, sh, sw, 1]",
    "activation",
    "TODO",
    "padding in conv",
    "pad in IR is [x1_b, x2_b, ..., x1_e, x2_e, ...]",
    "padding",
    "compute padding for 'same'",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "https://www.jianshu.com/p/05c4f1621c7e",
    "padding in pooling",
    "padding",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "TODO",
    "symmetric padding",
    "name, op",
    "input edge",
    "For concat axis",
    "NO axis in coreml, so set the last axis",
    "The first -1 means in coreml there is one-more axis,",
    "The second -1 means the last axis",
    "name, op",
    "input edge",
    "padding",
    "Future Module TODO",
    "#### rename methods",
    "name, op",
    "activation type",
    "else:",
    "assert False",
    "input edge",
    "Merge layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "NHWC channel last",
    "in fact, here is NWHC",
    "name, op",
    "input edge",
    "axis TODO",
    "channels_first, then axis = 1",
    "scale",
    "bias",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "mean",
    "var",
    "name, op",
    "input edge",
    "bias",
    "name, op",
    "input edge",
    "MAX = 0, AVERAGE = 1, L2 = 2",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "name, op",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "the end of the tensorflow_resnet_v2_50's squeeze shape is [unknown_rank: true] with len 0",
    "1001 means the 1001 classes for tensorflow_resnet_v2_50",
    "!Alert! TODO",
    "Future implement can be changed to the last two layer",
    "TODO - remove style transfer 1D hack",
    "Input is 1D but it goes to the width dimension: (1,1,W)",
    "assume (Batch, Channels) - Batch dimension should be dropped",
    "assume (Batch, Sequence-Length, channels)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Add classifier classes (if applicable)",
    "Set pre-processing paramsters",
    "image_input_names,",
    "Return the protobuf spec",
    "model = _MLModel(self.builder.spec)",
    "Get input and output names",
    "Dimensions and weights",
    "W should have shape (height, width, kernel_channels, output_channels), where kernel_channel = input_channels / groups",
    "Dilations",
    "see protobuf",
    "assert False",
    "Get the weights.",
    "Dilations",
    "see protobuf",
    "depth-wise convolution",
    "Dilations",
    "see protobuf",
    "Get input and output names",
    "Pooling layer type",
    "if it's global, set the global flag",
    "TODO  global pooling modification",
    "Padding",
    "see protobuf",
    "Padding",
    "see protobuf",
    "Get input and output names",
    "type: \"list(int). A 1-D values of (leftBorder, topBorder, rightBorder, bottomBorder).\"",
    "This is central crop",
    "Now add the layer",
    "Allowed values: 'CHW', 'HW', 'C', 'H', 'W'",
    "Get input and output names",
    "Get input and output names",
    "Get the weights from keras",
    "Get input and output names",
    "blob_order == 0 if the input blob needs not be rearranged",
    "blob_order == 1 if the input blob needs to be rearranged",
    "using keras_layer.input.shape have a \"?\" (Dimension[None] at the front),",
    "making a 3D tensor with unknown batch size 4D",
    "Get input and output names",
    "activation emit",
    "Get input and output names",
    "negate it",
    "apply threshold",
    "negate it back",
    "for Keras",
    "Get input and output names",
    "Set parameters",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "padding type TODO",
    "Type of the padding. Can be one of 'constant', 'reflection' or 'replication",
    "Now add the layer",
    "self.emit_Flatten(IR_node)",
    "depth_radius: Half-width of the 1-D normalization window.\"",
    "Get the weights",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "input layer",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "The information of the layer",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "print(node.parameters)",
    "assert False",
    "kwargs['gamma'] = 0.25",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "if parent.output_shape.height > 1 or parent.output_shape.width > 1:",
    "TODO: The gamma parameter has to be set (in node.data?) and this should work.",
    "Also, mean should be set to 0, and var to 1, just to be safe.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For some reason argparser gives us unicode, so we need to conver to str first",
    "for test",
    "with open(\"graph.txt\", 'w') as f:",
    "for layer in self.IR_graph.topological_sort:",
    "current_node = self.IR_graph.get_node(layer)",
    "print(\"========current_node=========\\n{}\".format(current_node.layer), file=f)",
    "test end",
    "print(\"========current_node={}\".format(current_node.layer))",
    "check if have pad layer",
    "keys = []",
    "for key in self.weights_dict[IR_node.name].keys():",
    "keys.append(key)",
    "print(\"=======Layer: {}, keys: {}\".format(IR_node.name, keys))",
    "Change the layer name",
    "check if need crop output shape",
    "change the key \"name\" to \"variable_name\", in case of the layer name has invalid characters",
    "def emit_Tanh(self, IR_node):",
    "self._emit_activation(IR_node, 'ops.tanh')",
    "Convert NHWC (IR) to NCHW (Caffe): [0,1,2,3]->[0,3,1,2]",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "self.graph = NodeRenamer()(graph)",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "Kit",
    "mapped_node.input.extend(['%s:%s' % (input.name, idx) for input, idx in node.parents])",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "try:",
    "except ImportError:",
    "# # Fall back to the protobuf implementation",
    "# from mmdnn.conversion.caffe import caffe_pb2",
    "# self.caffepb = caffe_pb2",
    "# show_fallback_warning()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from tensorflow.core.framework.node_def_pb2 import NodeDef",
    "from tensorflow.core.framework import attr_value_pb2",
    "pass",
    "print(\"\\n\")",
    "print(i)",
    "print(block)",
    "continue",
    "NHWC",
    "assert False",
    "print(shortcut_layer['input'] )",
    "spacetodepth",
    "print(block)",
    "print(region_layer)",
    "assert False",
    "print line",
    "set default value",
    "load weight by original order",
    "print(node_type)",
    "print(IR_node)",
    "assert False",
    "strides",
    "assert False",
    "padding",
    "only load weight conv",
    "print(\"----------------\",self.start)",
    "print(kernel.shape)",
    "print(k_bias.shape)",
    "buf, start, scale_layer['name'], bn_layer['name'], conv_layer['name']",
    "print(\"==============\",self.start)",
    "print(bias.shape)",
    "print(scale.shape)",
    "print(mean.shape)",
    "print(var.shape)",
    "print(kernel.shape)",
    "print(W)",
    "assert False",
    "no use",
    "print(source_node.layer)",
    "for image classification(resnet) AVG pooling",
    "print(source_node.layer)",
    "print(source_node.layer)",
    "kwargs['ignore_thresh'] = source_node.get_attr('ignore_thresh')",
    "print(source_node.get_attr('anchors'))",
    "kwargs['anchors'] = ['0.52','0.22']",
    "kwargs['mask'] = source_node.get_attr('mask')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Reference: 1) Keras image preprocess: https://github.com/keras-team/keras/blob/master/keras/applications/imagenet_utils.py",
    "2) tensorflow github issue: https://github.com/tensorflow/models/issues/517",
    "R-G-B for Imagenet === [123.68, 116.78, 103.94]",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load a real image and do default tf imageNet preprocessing",
    "[Batch, Height, Width, Channels] --> [Batch, Channels, Height, Width]",
    "We only deal with non-recurrent networks for now",
    "(H,W,C) --> (C,H,W)",
    "Load TensorFlow model",
    "Prepare inputs",
    "Run TF session",
    "Evaluate coreml model",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "@unittest.skip(\"Failing GPU backend: related to https://github.com/tf-coreml/tf-coreml/issues/26\")",
    "? style transfer image size and style number?",
    "Test predictions on an image",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "compare_tf_coreml_outputs(tf_out_flatten, coreml_out_flatten)",
    "#Download model",
    "url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception_v3_2016_08_28_frozen.pb.tar.gz'",
    "tf_model_dir = _download_file(url = url)",
    "tf_model_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28_frozen.pb')",
    "#Convert to coreml",
    "mlmodel_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28.mlmodel')",
    "mlmodel = tf_converter.convert(",
    "tf_model_path = tf_model_path,",
    "mlmodel_path = mlmodel_path,",
    "output_feature_names = ['InceptionV3/Predictions/Softmax:0'],",
    "input_name_shape_dict = {'input:0':[1,299,299,3]},",
    "image_input_names = ['input:0'],",
    "red_bias = -1,",
    "green_bias = -1,",
    "blue_bias = -1,",
    "image_scale = 2.0/255.0)",
    "#Test predictions on an image",
    "_test_coreml_model_image_input(",
    "tf_model_path = tf_model_path,",
    "coreml_model = mlmodel,",
    "input_tensor_name = 'input:0',",
    "output_tensor_name = 'InceptionV3/Predictions/Softmax:0',",
    "img_size = 299)",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "self.test_truth()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from collections import namedtuple",
    "Batch = namedtuple('Batch', ['data'])",
    "TODO",
    "Apple has published some of their own models. They can be downloaded from https://developer.apple.com/machine-learning/.",
    "Those published models are: SqueezeNet, Places205-GoogLeNet, ResNet50, Inception v3, VGG16",
    "TODO",
    "load model",
    "TODO: Multiple inputs",
    "TODO: Multiple outputs",
    "inference",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "caffe uses NCHW",
    "self.print_intermediate_result('pooling0', False)",
    "delete tmp model files",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "net = caffe.Net(arch_fn, weight_fn, caffe.TEST)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "# Image Classification",
    "# Semantic Segmentation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "print(r)",
    "d = darknet_extractor()",
    "model_filename = d.download('yolov3')",
    "print(model_filename)",
    "image_path = \"./mmdnn/conversion/examples/data/dog.jpg\"",
    "model_path = \"./\"",
    "d = darknet_extractor()",
    "result = d.inference('yolov3', model_filename, model_path, image_path = image_path)",
    "print(result)",
    "print(i)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('pooling0', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "need to be updated",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "raise NotImplementedError()",
    "load file",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Notes for training NASNet Cifar Model",
    "-------------------------------------",
    "batch_size: 32",
    "learning rate: 0.025",
    "cosine (single period) learning rate decay",
    "auxiliary head loss weighting: 0.4",
    "clip global norm of all gradients by 5",
    "600 epochs with a batch size of 32",
    "This is used for the drop path probabilities since it needs to increase",
    "the drop out probability over the course of training.",
    "Notes for training large NASNet model on ImageNet",
    "-------------------------------------",
    "batch size (per replica): 16",
    "learning rate: 0.015 * 100",
    "learning rate decay factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 100 replicas",
    "auxiliary head loss weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Notes for training the mobile NASNet ImageNet model",
    "-------------------------------------",
    "batch size (per replica): 32",
    "learning rate: 0.04 * 50",
    "learning rate scaling factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 50 replicas",
    "auxiliary head weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Shape of feature map before the final layer.",
    "149 x 149 x 32",
    "Run the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Find where to place the reduction cells or stride normal cells",
    "Setup for building in the auxiliary head.",
    "Run the cells",
    "true_cell_num accounts for the stem cells",
    "Final softmax layer",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 192",
    "35 x 35 x 320",
    "TODO(alemi): Register intermediate endpoints",
    "17 x 17 x 1088 if output_stride == 8,",
    "33 x 33 x 1088 if output_stride == 16",
    "TODO(alemi): register intermediate endpoints",
    "TODO(gpapan): Properly support output_stride for the rest of the net.",
    "8 x 8 x 2080",
    "TODO(alemi): register intermediate endpoints",
    "8 x 8 x 1536",
    "TODO(sguada,arnoegw): Consider adding a parameter global_pool which",
    "can be set to False to disable pooling here (as in resnet_*()).",
    "Set weight_decay for weights in conv2d and fully_connected layers.",
    "Set activation_fn and parameters for batch_norm.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "=============================================================================",
    "Tensorflow mandates these.",
    "Conv and DepthSepConv namedtuple define layers of the MobileNet architecture",
    "Conv defines 3x3 convolution layers",
    "DepthSepConv defines 3x3 depthwise convolution followed by 1x1 convolution.",
    "stride is the stride of the convolution",
    "depth is the number of channels or filters in a layer",
    "_CONV_DEFS specifies the MobileNet body",
    "Used to find thinned depths for each layer.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "By passing filters=None",
    "separable_conv2d produces only a depthwise convolution layer",
    "Global average pooling.",
    "Pooling with a fixed kernel size.",
    "1 x 1 x 1024",
    "Set weight_decay for weights in Conv and DepthSepConv layers.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Skip path 1",
    "Skip path 2",
    "First pad with 0's on the right and bottom, then shift the filter to",
    "include those 0's that were added.",
    "Concat and apply BN",
    "Set the prev layer to the current layer if it is none",
    "Check to be sure prev layer stuff is setup correctly",
    "Apply conv operations",
    "Combine hidden states using 'add'.",
    "Add hiddenstate to the list of hiddenstates we can choose from",
    "Dont stride if this is not one of the original hiddenstates",
    "Check if a stride is needed, then use a strided 1x1 here",
    "Determine if a reduction should be applied to make the number of",
    "filters match.",
    "Return the concat of all the states",
    "Scale keep prob by layer number",
    "The added 2 is for the reduction cells",
    "Decrease the keep probability over time",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Note: want to round down, we adjust each split to match the total.",
    "We use scope_depthwise, scope_pointwise for compatibility with V1 ckpts.",
    "which provide numbered scopes.",
    "b1 -> b2 * r -> b2",
    "i -> (o * r) (bottleneck) -> o",
    "Note in contrast with expansion, we always have",
    "projection to produce the desired output size.",
    "stride check enforces that we don't add residuals when spatial",
    "dimensions are None",
    "Depth matches",
    "Don't do any splitting if we end up with less than 8 filters",
    "on either side.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Set conv defs defaults and overrides.",
    "a) Set the tensorflow scope",
    "b) set padding to default: note we might consider removing this",
    "since it is also set by mobilenet_scope",
    "c) set all defaults",
    "d) set all extra overrides.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "Insert default parameters before the base scope which includes",
    "any custom overrides set in mobilenet.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "Update params.",
    "Only insert rate to params if rate > 1.",
    "Set padding",
    "Add all tensors that end with 'output' to",
    "endpoints",
    "1 x 1 x num_classes",
    "Note: legacy scope name.",
    "Recover output shape, for unknown shape.",
    "the network created will be trainble with dropout/batch norm",
    "initialized appropriately.",
    "Note: do not introduce parameters that would change the inference",
    "model here (for example whether to use bias), modify conv_def instead.",
    "Set weight_decay for weights in Conv and FC layers.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "pyformat: disable",
    "Architecture: https://arxiv.org/abs/1801.04381",
    "Note: these parameters of batch norm affect the architecture",
    "that's why they are here and not in training_scope.",
    "pyformat: enable",
    "NB: do not set depth_args unless they are provided to avoid overriding",
    "whatever default depth_multiplier might have thanks to arg_scope.",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.anchors = np.array([[10,13], [16,30],[33,23],[30,61],[62,45], [59,119],[116,90],[156,198],[373,326]])",
    "print(output)",
    "print(out_boxes, out_scores, out_classes)",
    "get random colors",
    "My kingdom for a good redistributable image drawing library.",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "yolov3 80 classes",
    "Reshape to batch, height, width, num_anchors, box_params.",
    "Adjust preditions to each spatial grid point and anchor size.",
    "Note: YOLO iterates over height index before width index.",
    "TODO: It works with +1, don't know why.",
    "Scale boxes back to original image shape.",
    "print(\"feats,anchors, num_classes, input_shape\", feats, anchors, num_classes, input_shape)",
    "print(box_xy, box_wh, box_confidence, box_class_probs)",
    "yolo_outputs order 13,26,52",
    "TODO: use keras backend instead of tf.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Convert network architecture only",
    "MXNet",
    "Caffe",
    "For CoreML",
    "assert args.network or args.frozen_pb",
    "Caffe",
    "Darknet",
    "exts = ['.pb', '.npy', '.py']",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if layout not in MXNetEmitter.channels_last:",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "def emit_ConvTranspose(self, IR_node):",
    "if self.weight_loaded:",
    "weight_dict = self.weights[IR_node.name]",
    "weights = weight_dict['weights']",
    "dim = len(IR_node.IR_layer.attr[\"kernel_shape\"].list.i) - 2",
    "kernel = list()",
    "for idx in range(0, dim):",
    "kernel.append(IR_node.IR_layer.attr[\"kernel_shape\"].list.i[idx])",
    "stride = list()",
    "for e in IR_node.IR_layer.attr[\"strides\"].list.i[1:-1]:",
    "stride.append(e)",
    "dilate = list()",
    "for e in IR_node.IR_layer.attr[\"dilations\"].list.i[1:-1]:",
    "dilate.append(e)",
    "dilate = ', '.join('%s' % i for i in dilate)",
    "defuse_pad = False",
    "pad = list()",
    "if \"pads\" in IR_node.IR_layer.attr:",
    "output_shape = list()",
    "for e in IR_node.IR_layer.attr[\"_output_shapes\"].list.shape[0].dim:",
    "output_shape.append(e.size)",
    "# print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "defuse_pad, pad = MXNetEmitter.transfer_pad(IR_node.IR_layer.attr[\"pads\"].list.i)",
    "pad = ', '.join('%s' % i for i in pad)",
    "kernel = ', '.join('%s' % i for i in kernel)",
    "stride = ', '.join('%s' % i for i in stride)",
    "num_filter = IR_node.IR_layer.attr[\"kernel_shape\"].list.i[-2]",
    "no_bias = not IR_node.IR_layer.attr[\"use_bias\"].b",
    "if not no_bias and self.weight_loaded:",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_bias\"] = weight_dict['bias']",
    "# layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NCHW'",
    "elif dim == 3:",
    "layout = 'NCDHW'",
    "if self.weight_loaded:",
    "# if layout not in MXNetEmitter.channels_last:",
    "weights = MXNetEmitter.transpose(weights, dim)",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_weight\"] = weights",
    "code = \"\"",
    "if not defuse_pad:",
    "code = \"{:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), pad = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "kernel,",
    "stride,",
    "dilate,",
    "pad,",
    "num_filter,",
    "no_bias,",
    "layout,",
    "IR_node.replace_scope(IR_node.name))",
    "else:",
    "code = self.set_pad(IR_node, code, pad)",
    "code += \"\\n    {:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name) + \"_pad\", kernel, stride, dilate, num_filter, no_bias, layout, IR_node.replace_scope(IR_node.name))",
    "return code",
    "reverse cannot support yet",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(\"trans\", self.parent_variable_name(IR_node))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "Load the model network and weights",
    "digraph = mx.viz.plot_network(sym, save_format='jpg') # For debugging",
    "digraph.render()",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "load the model network",
    "adjust the data format",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "for e in pad:",
    "IR_node.attr[\"pads\"].list.i.extend([e, e])",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "name, op",
    "input edge",
    "units",
    "use bias (no_bias default = False)",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "input edge",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "groups",
    "in_channel = in_channel // group",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "padding",
    "weights",
    "axis",
    "scale",
    "epsilon",
    "momentum",
    "weights",
    "gamma",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "kernel_shape",
    "padding",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "dim",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "weights",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "IR only support elu and prelu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "return",
    "name, op",
    "gamma",
    "input edge",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "alpha",
    "beta",
    "knorm",
    "nsize",
    "keep_prob",
    "mode",
    "reverse cannot support yet",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "dim",
    "dtype",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "axis",
    "raise NotImplementedError(\"No matching IR api\")",
    "left strip the \"_\" at the beginning of the name",
    "Issue #85, #135",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into TensorFlow graph",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Matmul Layer",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "TODO: Current it is only for slice",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "check whether flatten operator should be added",
    "flatten is needed",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "skip_prefix = [",
    "\"^\",",
    "\"train_op\",",
    "\"save\",",
    "\"gradients\",",
    "\"init\",",
    "\"global_step\",",
    "\"distort_image\",",
    "\"Adagrad\",",
    "]",
    "\"Switch\"",
    "\"RequantizationRange\",",
    "\"Requantize\",",
    "\"Cast\"",
    "load model files into TensorFlow graph",
    "model = original_gdef",
    "Save it to an output file",
    "for pytest",
    "assert False",
    "keep dims",
    "axes",
    "name, op",
    "ssd model is transformed",
    "Ax - (Au - b)",
    "A",
    "print(A_content)",
    "b",
    "print(sub_content)",
    "print(IR_node.input)",
    "print(IR_node.output)",
    "assert False",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "gamma = self.get_parent(son.name, [1, 1, 0, 0, 0, 1], True)",
    "print(output_node.layer)",
    "print(Mul.layer)",
    "beta  (bias)",
    "moving mean (mean)",
    "input node",
    "output node",
    "epsilon",
    "beta",
    "gamma (scale)",
    "output_node = self.get_son(source_node.name, [0, 0, 0, 0], True)",
    "assert False",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "assert variable.get_attr('_output_shapes')[0].dim[0].size == IR_node.attr['kernel_shape'].list.i[-1]",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "beta  (bias)",
    "moving mean (mean)",
    "print(source_node.in_edges)",
    "print(source_node.out_edges)",
    "print(source_node.layer)",
    "print(tensor_content)",
    "print(IR_node)",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "print(source_node.in_edges)",
    "print(source_node.out_edges)",
    "assert False",
    "input_node_0 = self.src_graph.get_parent(source_node.name, [0])",
    "# mean/read",
    "if input_node_0.type == 'Identity':",
    "input_node_0_read = self.src_graph.get_parent(input_node_0.name, [0])",
    "tensor_content = input_node_0_read.get_attr('value')",
    "tensor_content = tensor_util.MakeNdarray(tensor_content)",
    "self.set_weight(source_node.name, 'weights', tensor_content)",
    "IR_node = self._convert_identity_operation(source_node, start_idx = 1)",
    "else:",
    "print(scopes)",
    "print(scopes)",
    "print(source_node.layer)",
    "def rename_Pack(self, source_node):",
    "IR_node = self._convert_identity_operation(source_node, new_op = 'Pack')",
    "kwargs['shape'] = self.tensor_shape_to_list(input_node.get_attr('_output_shapes'))[0]",
    "kwargs['shape'] = self.tensor_shape_to_list(input_node.get_attr('_output_shapes'))[0]",
    "def rename_ExpandDims(self, source_node):",
    "IR_node = self._convert_identity_operation(source_node, new_op = 'ExpandDims')",
    "input_node = self.src_graph.get_parent(source_node.name, [0])",
    "kwargs = {}",
    "kwargs['shape'] = self.tensor_shape_to_list(input_node.get_attr('_output_shapes'))[0]",
    "input_node_indices = self.src_graph.get_parent(source_node.name, [1])",
    "kwargs['exp_dim'] = input_node_indices.get_attr('value').int_val[0]",
    "assign_IRnode_values(IR_node, kwargs)",
    "weights",
    "alpha",
    "beta",
    "weights",
    "def rename_Dequantize(self, source_node):",
    "IR_node = self._convert_identity_operation(source_node,start_idx=0, end_idx= 1, new_op = 'Dequantize')",
    "kwargs = {}",
    "input_node = self.src_graph.get_parent(source_node.name, [0])",
    "kwargs['shape'] = self.tensor_shape_to_list(input_node.get_attr('_output_shapes'))[0]",
    "print(source_node.layer)",
    "print(source_node.layer)",
    "assert False",
    "kwargs = {}",
    "kwargs['mode'] = 'constant'",
    "kwargs['constant_values'] = 0.0",
    "# paddings",
    "padding = self.get_parent(source_node.name, [1]).layer.attr['value'].tensor",
    "shapes = tensor_util.MakeNdarray(padding)",
    "kwargs['pads'] = convert_tf_pad_to_onnx(shapes)",
    "assign_IRnode_values(IR_node, kwargs)",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "TODO: Handle square",
    "self._print_layer(source_node)",
    "print (source_node.name)",
    "print (self.src_graph.get_parent(source_node.name, [0]).real_name)",
    "assert False",
    "Convolution",
    "Kernel",
    "Attributes",
    "Bias",
    "Activation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "BlockFunction node",
    "redirect the composite's inputs to the true inputs",
    "BlockFunctions are short-circuited, and not added to accum[]",
    "Function node",
    "OutputVariable node",
    "def build(self):",
    "_traverse_graph(self, self.model.root_function)",
    "super(CntkGraph, self).build()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "??",
    "print(IR_node.layer)",
    "assert False",
    "print(IR_node.layer)",
    "assert False",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "network library",
    "not support multi-threads download",
    "key: layer_name    value: keras layer",
    "private functions",
    "print ('{} --> {}'.format(src, dst))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "-*- coding: utf-8 -*-",
    "from keras.layers.core import Layer",
    "Arguments",
    "Input shape",
    "Output shape",
    "Prepare broadcasting shape.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "weights",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "for target shape",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot weights",
    "print(\"Converting layer {}({})\".format(current_node.name, node_type))",
    "TODO",
    "return input_node, 'same'",
    "assert IR_node.get_attr('group', 1) == 1",
    "change dw from filters to 1",
    "reset the default dilation",
    "############",
    "Operators #",
    "############",
    "TODO",
    "when converting from coreml model, reshape is needed after the global pooling",
    "for Keras",
    "TODO: arguments won't be saved in keras export model",
    "print(IR_node.layer)",
    "print(IR_node.layer)",
    "Prepare broadcasting shape.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "remove list",
    "draw",
    "mode;",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "rm the '_'",
    "Base64 encode: https://developers.google.com/protocol-buffers/docs/proto3",
    "Search the node",
    "select by id: https://stackoverflow.com/questions/37270787/uncaught-syntaxerror-failed-to-execute-queryselector-on-document",
    "Scroll",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ],
  "0.2.0": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "Function self.assertEquals has deprecated, change to assertEqual",
    "self.assertEqual(original_predict.shape, converted_predict.shape)",
    "get original model prediction result",
    "original to IR",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "print(original_predict)",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "IR to code",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "The list is in RGB oder",
    "IR to Model",
    "converted_file = original_framework + '_coreml_' + architecture_name + \"_converted\"",
    "converted_file = converted_file.replace('.', '_')",
    "load model",
    "save model",
    "coremltools.utils.save_spec(model.get_spec(), converted_file)",
    "inference",
    "IR to code",
    "import converted model",
    "'alexnet'       : [CntkEmit, KerasEmit, TensorflowEmit],",
    "'inception_resnet_v2' : [TensorflowEmit], # TODO PytorchEmit",
    "get original model prediction result",
    "do not deal",
    "I don't want to deal with auto_pad",
    "Don't support auto_pad current!",
    "2018-02-28",
    "if group is None:",
    "group = 1",
    "group is not support yet too.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "node",
    "input",
    "edge(node a <-> node b)",
    "",
    "key is edge name, value is src/dst node name",
    "key is initializer name, value is TensorProto",
    "print(name)",
    "print(layer.op_type)",
    "n is input data",
    "n is input edge",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "if node len(in_edges), generate additional DataInput node",
    "print",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "padding,",
    "exstr = \", value=float('-Inf')\"",
    "exstr = \"\"",
    "input_node = self._defuse_padding(IR_node, exstr)",
    "Ignore it in Pytorch",
    "for Keras",
    "self.add_init(2, \"self.{:<15} = torch.from_numpy(__weights_dict['{}']['value'])\".format(",
    "IR_node.variable_name,",
    "IR_node.name))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._type = layer.__class__.__name__.replace('Backward', '')",
    "self._name = \"{}_{}\".format(self.type, id)",
    "TODO",
    "\"\"\"",
    "build graph for pytorch 0.2.0",
    "\"\"\"",
    "dummy_input = torch.autograd.Variable(torch.randn(shape))",
    "output_node = self.model(dummy_input)",
    "search_queue = [output_node.grad_fn]",
    "tmp_node = PyTorchGraphNode(output_node.grad_fn, 0)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "visited = {output_node.grad_fn : self.layer_map[tmp_node.name]}",
    "idx = 0",
    "node_count = 1",
    "while (idx < len(search_queue)):",
    "current_node = search_queue[idx]",
    "current_type = visited[current_node].type",
    "if hasattr(current_node, 'next_functions'):",
    "for parent, _ in current_node.next_functions:",
    "parent_type = parent.__class__.__name__.replace('Backward', '')",
    "if parent_type != 'AccumulateGrad' and \\",
    "(parent_type != 'Transpose' or current_type != 'Addmm'):",
    "if not parent in visited:",
    "tmp_node = PyTorchGraphNode(parent, node_count)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "node_count += 1",
    "visited[parent] = tmp_node",
    "search_queue.append(parent)",
    "self._make_connection(visited[parent].name, visited[current_node].name)",
    "idx += 1",
    "try:",
    "return TorchGraph._forward_torch_random_input(",
    "torch_model,",
    "input_shapes,",
    "is_batch=False",
    ")",
    "except:",
    "# try batch mode",
    "# return TorchGraph._forward_torch_random_input(",
    "#     torch_model,",
    "#     input_shapes,",
    "#     is_batch=True",
    "# )",
    "pass",
    "tensor = torch.rand(*shape).float()",
    "multi output",
    "single output",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "Build network graph",
    "#########",
    "Layers #",
    "#########",
    "handle weight",
    "handle bias",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "load model file into Coreml Graph",
    "model.encode() convert to str --- python2 may crash due to type 'unicode'",
    "Build Network Graph",
    "self.data_format ? TODO",
    "load the model network",
    "convert to Model_pb2.Model",
    "determine the type of the current_node",
    "staticmethods",
    "(seq, batch, C, H, W)  & NHWC",
    "TODO dtype_map",
    "##### convert methods",
    "convolution",
    "input edge",
    "important!",
    "reshape the weight!",
    "[2, 3, 0, 1]",
    "pads",
    "use_bias",
    "isDeconvolution",
    "name, op",
    "kwargs['kernel_shape'] = weights.shape",
    "strides",
    "[1, sd, sh, sw, 1]",
    "activation",
    "TODO",
    "padding in conv",
    "pad in IR is [x1_b, x2_b, ..., x1_e, x2_e, ...]",
    "padding",
    "compute padding for 'same'",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "https://www.jianshu.com/p/05c4f1621c7e",
    "padding in pooling",
    "padding",
    "https://discuss.mxnet.io/t/pooling-and-convolution-with-same-mode/528/3",
    "TODO",
    "symmetric padding",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "NO axis in coreml, so set the last axis",
    "The first -1 means in coreml there is one-more axis,",
    "The second -1 means the last axis",
    "name, op",
    "input edge",
    "padding",
    "Future Module TODO",
    "#### rename methods",
    "name, op",
    "activation type",
    "else:",
    "assert False",
    "input edge",
    "Merge layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "NHWC channel last",
    "in fact, here is NWHC",
    "name, op",
    "input edge",
    "axis TODO",
    "channels_first, then axis = 1",
    "scale",
    "bias",
    "epsilon",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "convert type because of tensorflow",
    "mean",
    "var",
    "name, op",
    "input edge",
    "bias",
    "name, op",
    "input edge",
    "MAX = 0, AVERAGE = 1, L2 = 2",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "name, op",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "the end of the tensorflow_resnet_v2_50's squeeze shape is [unknown_rank: true] with len 0",
    "1001 means the 1001 classes for tensorflow_resnet_v2_50",
    "!Alert! TODO",
    "Future implement can be changed to the last two layer",
    "TODO - remove style transfer 1D hack",
    "Input is 1D but it goes to the width dimension: (1,1,W)",
    "assume (Batch, Channels) - Batch dimension should be dropped",
    "assume (Batch, Sequence-Length, channels)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Add classifier classes (if applicable)",
    "Set pre-processing paramsters",
    "image_input_names,",
    "Return the protobuf spec",
    "model = _MLModel(self.builder.spec)",
    "Get input and output names",
    "Dimensions and weights",
    "W should have shape (height, width, kernel_channels, output_channels), where kernel_channel = input_channels / groups",
    "Dilations",
    "see protobuf",
    "assert False",
    "Get the weights.",
    "Dilations",
    "see protobuf",
    "depth-wise convolution",
    "Dilations",
    "see protobuf",
    "Get input and output names",
    "Pooling layer type",
    "if it's global, set the global flag",
    "TODO  global pooling modification",
    "Padding",
    "see protobuf",
    "Padding",
    "see protobuf",
    "Get input and output names",
    "type: \"list(int). A 1-D values of (leftBorder, topBorder, rightBorder, bottomBorder).\"",
    "This is central crop",
    "Now add the layer",
    "Allowed values: 'CHW', 'HW', 'C', 'H', 'W'",
    "Get input and output names",
    "Get input and output names",
    "Get the weights from keras",
    "Get input and output names",
    "blob_order == 0 if the input blob needs not be rearranged",
    "blob_order == 1 if the input blob needs to be rearranged",
    "using keras_layer.input.shape have a \"?\" (Dimension[None] at the front),",
    "making a 3D tensor with unknown batch size 4D",
    "Get input and output names",
    "activation emit",
    "Get input and output names",
    "negate it",
    "apply threshold",
    "negate it back",
    "for Keras",
    "Get input and output names",
    "Set parameters",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "compute adjusted parameters",
    "Reference: parameter transformation https://github.com/apple/coremltools/issues/153",
    "padding type TODO",
    "Type of the padding. Can be one of 'constant', 'reflection' or 'replication",
    "Now add the layer",
    "self.emit_Flatten(IR_node)",
    "depth_radius: Half-width of the 1-D normalization window.\"",
    "Get the weights",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "input layer",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "build each layer",
    "if A.output == B.input, then make the connection: A -> B",
    "print('{0:20}->     {1:20}'.format(layerA.name, layerB.name))",
    "if A.name == B.input, then make the connection: A -> B, here A is the input",
    "The information of the layer",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "print(node.parameters)",
    "assert False",
    "kwargs['gamma'] = 0.25",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "if parent.output_shape.height > 1 or parent.output_shape.width > 1:",
    "TODO: The gamma parameter has to be set (in node.data?) and this should work.",
    "Also, mean should be set to 0, and var to 1, just to be safe.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For some reason argparser gives us unicode, so we need to conver to str first",
    "for test",
    "with open(\"graph.txt\", 'w') as f:",
    "for layer in self.IR_graph.topological_sort:",
    "current_node = self.IR_graph.get_node(layer)",
    "print(\"========current_node=========\\n{}\".format(current_node.layer), file=f)",
    "test end",
    "print(\"========current_node={}\".format(current_node.layer))",
    "check if have pad layer",
    "keys = []",
    "for key in self.weights_dict[IR_node.name].keys():",
    "keys.append(key)",
    "print(\"=======Layer: {}, keys: {}\".format(IR_node.name, keys))",
    "Change the layer name",
    "check if need crop output shape",
    "change the key \"name\" to \"variable_name\", in case of the layer name has invalid characters",
    "def emit_Tanh(self, IR_node):",
    "self._emit_activation(IR_node, 'ops.tanh')",
    "Convert NHWC (IR) to NCHW (Caffe): [0,1,2,3]->[0,3,1,2]",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "self.graph = NodeRenamer()(graph)",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "Kit",
    "mapped_node.input.extend(['%s:%s' % (input.name, idx) for input, idx in node.parents])",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "try:",
    "except ImportError:",
    "# # Fall back to the protobuf implementation",
    "# from mmdnn.conversion.caffe import caffe_pb2",
    "# self.caffepb = caffe_pb2",
    "# show_fallback_warning()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from tensorflow.core.framework.node_def_pb2 import NodeDef",
    "from tensorflow.core.framework import attr_value_pb2",
    "pass",
    "print(\"\\n\")",
    "print(i)",
    "print(block)",
    "continue",
    "NHWC",
    "assert False",
    "print(shortcut_layer['input'] )",
    "spacetodepth",
    "print(block)",
    "print(region_layer)",
    "assert False",
    "print line",
    "set default value",
    "load weight by original order",
    "print(node_type)",
    "print(IR_node)",
    "assert False",
    "strides",
    "assert False",
    "padding",
    "only load weight conv",
    "print(\"----------------\",self.start)",
    "print(kernel.shape)",
    "print(k_bias.shape)",
    "buf, start, scale_layer['name'], bn_layer['name'], conv_layer['name']",
    "print(\"==============\",self.start)",
    "print(bias.shape)",
    "print(scale.shape)",
    "print(mean.shape)",
    "print(var.shape)",
    "print(kernel.shape)",
    "print(W)",
    "assert False",
    "no use",
    "print(source_node.layer)",
    "for image classification(resnet) AVG pooling",
    "print(source_node.layer)",
    "print(source_node.layer)",
    "kwargs['ignore_thresh'] = source_node.get_attr('ignore_thresh')",
    "print(source_node.get_attr('anchors'))",
    "kwargs['anchors'] = ['0.52','0.22']",
    "kwargs['mask'] = source_node.get_attr('mask')",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Reference: 1) Keras image preprocess: https://github.com/keras-team/keras/blob/master/keras/applications/imagenet_utils.py",
    "2) tensorflow github issue: https://github.com/tensorflow/models/issues/517",
    "R-G-B for Imagenet === [123.68, 116.78, 103.94]",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load a real image and do default tf imageNet preprocessing",
    "[Batch, Height, Width, Channels] --> [Batch, Channels, Height, Width]",
    "We only deal with non-recurrent networks for now",
    "(H,W,C) --> (C,H,W)",
    "Load TensorFlow model",
    "Prepare inputs",
    "Run TF session",
    "Evaluate coreml model",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "@unittest.skip(\"Failing GPU backend: related to https://github.com/tf-coreml/tf-coreml/issues/26\")",
    "? style transfer image size and style number?",
    "Test predictions on an image",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "compare_tf_coreml_outputs(tf_out_flatten, coreml_out_flatten)",
    "#Download model",
    "url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception_v3_2016_08_28_frozen.pb.tar.gz'",
    "tf_model_dir = _download_file(url = url)",
    "tf_model_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28_frozen.pb')",
    "#Convert to coreml",
    "mlmodel_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28.mlmodel')",
    "mlmodel = tf_converter.convert(",
    "tf_model_path = tf_model_path,",
    "mlmodel_path = mlmodel_path,",
    "output_feature_names = ['InceptionV3/Predictions/Softmax:0'],",
    "input_name_shape_dict = {'input:0':[1,299,299,3]},",
    "image_input_names = ['input:0'],",
    "red_bias = -1,",
    "green_bias = -1,",
    "blue_bias = -1,",
    "image_scale = 2.0/255.0)",
    "#Test predictions on an image",
    "_test_coreml_model_image_input(",
    "tf_model_path = tf_model_path,",
    "coreml_model = mlmodel,",
    "input_tensor_name = 'input:0',",
    "output_tensor_name = 'InceptionV3/Predictions/Softmax:0',",
    "img_size = 299)",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "self.test_truth()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "from collections import namedtuple",
    "Batch = namedtuple('Batch', ['data'])",
    "TODO",
    "Apple has published some of their own models. They can be downloaded from https://developer.apple.com/machine-learning/.",
    "Those published models are: SqueezeNet, Places205-GoogLeNet, ResNet50, Inception v3, VGG16",
    "TODO",
    "load model",
    "TODO: Multiple inputs",
    "TODO: Multiple outputs",
    "inference",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "caffe uses NCHW",
    "self.print_intermediate_result('pooling0', False)",
    "delete tmp model files",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "net = caffe.Net(arch_fn, weight_fn, caffe.TEST)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "# Image Classification",
    "# Semantic Segmentation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "print(r)",
    "d = darknet_extractor()",
    "model_filename = d.download('yolov3')",
    "print(model_filename)",
    "image_path = \"./mmdnn/conversion/examples/data/dog.jpg\"",
    "model_path = \"./\"",
    "d = darknet_extractor()",
    "result = d.inference('yolov3', model_filename, model_path, image_path = image_path)",
    "print(result)",
    "print(i)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('pooling0', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "need to be updated",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "tf.train.export_meta_graph(\"kit.meta\", as_text=True)",
    "writer = tf.summary.FileWriter('./graphs', sess.graph)",
    "writer.close()",
    "raise NotImplementedError()",
    "load file",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Notes for training NASNet Cifar Model",
    "-------------------------------------",
    "batch_size: 32",
    "learning rate: 0.025",
    "cosine (single period) learning rate decay",
    "auxiliary head loss weighting: 0.4",
    "clip global norm of all gradients by 5",
    "600 epochs with a batch size of 32",
    "This is used for the drop path probabilities since it needs to increase",
    "the drop out probability over the course of training.",
    "Notes for training large NASNet model on ImageNet",
    "-------------------------------------",
    "batch size (per replica): 16",
    "learning rate: 0.015 * 100",
    "learning rate decay factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 100 replicas",
    "auxiliary head loss weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Notes for training the mobile NASNet ImageNet model",
    "-------------------------------------",
    "batch size (per replica): 32",
    "learning rate: 0.04 * 50",
    "learning rate scaling factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 50 replicas",
    "auxiliary head weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Shape of feature map before the final layer.",
    "149 x 149 x 32",
    "Run the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Find where to place the reduction cells or stride normal cells",
    "Setup for building in the auxiliary head.",
    "Run the cells",
    "true_cell_num accounts for the stem cells",
    "Final softmax layer",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 192",
    "35 x 35 x 320",
    "TODO(alemi): Register intermediate endpoints",
    "17 x 17 x 1088 if output_stride == 8,",
    "33 x 33 x 1088 if output_stride == 16",
    "TODO(alemi): register intermediate endpoints",
    "TODO(gpapan): Properly support output_stride for the rest of the net.",
    "8 x 8 x 2080",
    "TODO(alemi): register intermediate endpoints",
    "8 x 8 x 1536",
    "TODO(sguada,arnoegw): Consider adding a parameter global_pool which",
    "can be set to False to disable pooling here (as in resnet_*()).",
    "Set weight_decay for weights in conv2d and fully_connected layers.",
    "Set activation_fn and parameters for batch_norm.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "=============================================================================",
    "Tensorflow mandates these.",
    "Conv and DepthSepConv namedtuple define layers of the MobileNet architecture",
    "Conv defines 3x3 convolution layers",
    "DepthSepConv defines 3x3 depthwise convolution followed by 1x1 convolution.",
    "stride is the stride of the convolution",
    "depth is the number of channels or filters in a layer",
    "_CONV_DEFS specifies the MobileNet body",
    "Used to find thinned depths for each layer.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "By passing filters=None",
    "separable_conv2d produces only a depthwise convolution layer",
    "Global average pooling.",
    "Pooling with a fixed kernel size.",
    "1 x 1 x 1024",
    "Set weight_decay for weights in Conv and DepthSepConv layers.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Skip path 1",
    "Skip path 2",
    "First pad with 0's on the right and bottom, then shift the filter to",
    "include those 0's that were added.",
    "Concat and apply BN",
    "Set the prev layer to the current layer if it is none",
    "Check to be sure prev layer stuff is setup correctly",
    "Apply conv operations",
    "Combine hidden states using 'add'.",
    "Add hiddenstate to the list of hiddenstates we can choose from",
    "Dont stride if this is not one of the original hiddenstates",
    "Check if a stride is needed, then use a strided 1x1 here",
    "Determine if a reduction should be applied to make the number of",
    "filters match.",
    "Return the concat of all the states",
    "Scale keep prob by layer number",
    "The added 2 is for the reduction cells",
    "Decrease the keep probability over time",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Note: want to round down, we adjust each split to match the total.",
    "We use scope_depthwise, scope_pointwise for compatibility with V1 ckpts.",
    "which provide numbered scopes.",
    "b1 -> b2 * r -> b2",
    "i -> (o * r) (bottleneck) -> o",
    "Note in contrast with expansion, we always have",
    "projection to produce the desired output size.",
    "stride check enforces that we don't add residuals when spatial",
    "dimensions are None",
    "Depth matches",
    "Don't do any splitting if we end up with less than 8 filters",
    "on either side.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Make sure that round down does not go down by more than 10%.",
    "Set conv defs defaults and overrides.",
    "a) Set the tensorflow scope",
    "b) set padding to default: note we might consider removing this",
    "since it is also set by mobilenet_scope",
    "c) set all defaults",
    "d) set all extra overrides.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "Insert default parameters before the base scope which includes",
    "any custom overrides set in mobilenet.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "Update params.",
    "Only insert rate to params if rate > 1.",
    "Set padding",
    "Add all tensors that end with 'output' to",
    "endpoints",
    "1 x 1 x num_classes",
    "Note: legacy scope name.",
    "Recover output shape, for unknown shape.",
    "the network created will be trainble with dropout/batch norm",
    "initialized appropriately.",
    "Note: do not introduce parameters that would change the inference",
    "model here (for example whether to use bias), modify conv_def instead.",
    "Set weight_decay for weights in Conv and FC layers.",
    "Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "pyformat: disable",
    "Architecture: https://arxiv.org/abs/1801.04381",
    "Note: these parameters of batch norm affect the architecture",
    "that's why they are here and not in training_scope.",
    "pyformat: enable",
    "NB: do not set depth_args unless they are provided to avoid overriding",
    "whatever default depth_multiplier might have thanks to arg_scope.",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.anchors = np.array([[10,13], [16,30],[33,23],[30,61],[62,45], [59,119],[116,90],[156,198],[373,326]])",
    "print(output)",
    "print(out_boxes, out_scores, out_classes)",
    "get random colors",
    "My kingdom for a good redistributable image drawing library.",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "yolov3 80 classes",
    "Reshape to batch, height, width, num_anchors, box_params.",
    "Adjust preditions to each spatial grid point and anchor size.",
    "Note: YOLO iterates over height index before width index.",
    "TODO: It works with +1, don't know why.",
    "Scale boxes back to original image shape.",
    "print(\"feats,anchors, num_classes, input_shape\", feats, anchors, num_classes, input_shape)",
    "print(box_xy, box_wh, box_confidence, box_class_probs)",
    "yolo_outputs order 13,26,52",
    "TODO: use keras backend instead of tf.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Convert network architecture only",
    "MXNet",
    "Caffe",
    "For CoreML",
    "assert args.network or args.frozen_pb",
    "Caffe",
    "Darknet",
    "exts = ['.pb', '.npy', '.py']",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if layout not in MXNetEmitter.channels_last:",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "def emit_ConvTranspose(self, IR_node):",
    "if self.weight_loaded:",
    "weight_dict = self.weights[IR_node.name]",
    "weights = weight_dict['weights']",
    "dim = len(IR_node.IR_layer.attr[\"kernel_shape\"].list.i) - 2",
    "kernel = list()",
    "for idx in range(0, dim):",
    "kernel.append(IR_node.IR_layer.attr[\"kernel_shape\"].list.i[idx])",
    "stride = list()",
    "for e in IR_node.IR_layer.attr[\"strides\"].list.i[1:-1]:",
    "stride.append(e)",
    "dilate = list()",
    "for e in IR_node.IR_layer.attr[\"dilations\"].list.i[1:-1]:",
    "dilate.append(e)",
    "dilate = ', '.join('%s' % i for i in dilate)",
    "defuse_pad = False",
    "pad = list()",
    "if \"pads\" in IR_node.IR_layer.attr:",
    "output_shape = list()",
    "for e in IR_node.IR_layer.attr[\"_output_shapes\"].list.shape[0].dim:",
    "output_shape.append(e.size)",
    "# print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "defuse_pad, pad = MXNetEmitter.transfer_pad(IR_node.IR_layer.attr[\"pads\"].list.i)",
    "pad = ', '.join('%s' % i for i in pad)",
    "kernel = ', '.join('%s' % i for i in kernel)",
    "stride = ', '.join('%s' % i for i in stride)",
    "num_filter = IR_node.IR_layer.attr[\"kernel_shape\"].list.i[-2]",
    "no_bias = not IR_node.IR_layer.attr[\"use_bias\"].b",
    "if not no_bias and self.weight_loaded:",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_bias\"] = weight_dict['bias']",
    "# layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NCHW'",
    "elif dim == 3:",
    "layout = 'NCDHW'",
    "if self.weight_loaded:",
    "# if layout not in MXNetEmitter.channels_last:",
    "weights = MXNetEmitter.transpose(weights, dim)",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_weight\"] = weights",
    "code = \"\"",
    "if not defuse_pad:",
    "code = \"{:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), pad = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "kernel,",
    "stride,",
    "dilate,",
    "pad,",
    "num_filter,",
    "no_bias,",
    "layout,",
    "IR_node.replace_scope(IR_node.name))",
    "else:",
    "code = self.set_pad(IR_node, code, pad)",
    "code += \"\\n    {:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name) + \"_pad\", kernel, stride, dilate, num_filter, no_bias, layout, IR_node.replace_scope(IR_node.name))",
    "return code",
    "reverse cannot support yet",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(\"trans\", self.parent_variable_name(IR_node))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "Load the model network and weights",
    "digraph = mx.viz.plot_network(sym, save_format='jpg') # For debugging",
    "digraph.render()",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "load the model network",
    "adjust the data format",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "for e in pad:",
    "IR_node.attr[\"pads\"].list.i.extend([e, e])",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "name, op",
    "input edge",
    "units",
    "use bias (no_bias default = False)",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "input edge",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "groups",
    "in_channel = in_channel // group",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "padding",
    "weights",
    "axis",
    "scale",
    "epsilon",
    "momentum",
    "weights",
    "gamma",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "kernel_shape",
    "padding",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "dim",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "weights",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "IR only support elu and prelu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "return",
    "name, op",
    "gamma",
    "input edge",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "alpha",
    "beta",
    "knorm",
    "nsize",
    "keep_prob",
    "mode",
    "reverse cannot support yet",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "dim",
    "dtype",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "axis",
    "raise NotImplementedError(\"No matching IR api\")",
    "left strip the \"_\" at the beginning of the name",
    "Issue #85, #135",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into TensorFlow graph",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Matmul Layer",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "TODO: Current it is only for slice",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "check whether flatten operator should be added",
    "flatten is needed",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "skip_prefix = [",
    "\"^\",",
    "\"train_op\",",
    "\"save\",",
    "\"gradients\",",
    "\"init\",",
    "\"global_step\",",
    "\"distort_image\",",
    "\"Adagrad\",",
    "]",
    "\"Switch\"",
    "\"RequantizationRange\",",
    "\"Requantize\",",
    "\"Cast\"",
    "load model files into TensorFlow graph",
    "model = original_gdef",
    "Save it to an output file",
    "for pytest",
    "assert False",
    "keep dims",
    "axes",
    "name, op",
    "ssd model is transformed",
    "Ax - (Au - b)",
    "A",
    "print(A_content)",
    "b",
    "print(sub_content)",
    "print(IR_node.input)",
    "print(IR_node.output)",
    "assert False",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "gamma = self.get_parent(son.name, [1, 1, 0, 0, 0, 1], True)",
    "print(output_node.layer)",
    "print(Mul.layer)",
    "beta  (bias)",
    "moving mean (mean)",
    "input node",
    "output node",
    "epsilon",
    "beta",
    "gamma (scale)",
    "output_node = self.get_son(source_node.name, [0, 0, 0, 0], True)",
    "assert False",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "assert variable.get_attr('_output_shapes')[0].dim[0].size == IR_node.attr['kernel_shape'].list.i[-1]",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "beta  (bias)",
    "moving mean (mean)",
    "print(source_node.in_edges)",
    "print(source_node.out_edges)",
    "print(source_node.layer)",
    "print(tensor_content)",
    "print(IR_node)",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "print(source_node.in_edges)",
    "print(source_node.out_edges)",
    "assert False",
    "input_node_0 = self.src_graph.get_parent(source_node.name, [0])",
    "# mean/read",
    "if input_node_0.type == 'Identity':",
    "input_node_0_read = self.src_graph.get_parent(input_node_0.name, [0])",
    "tensor_content = input_node_0_read.get_attr('value')",
    "tensor_content = tensor_util.MakeNdarray(tensor_content)",
    "self.set_weight(source_node.name, 'weights', tensor_content)",
    "IR_node = self._convert_identity_operation(source_node, start_idx = 1)",
    "else:",
    "print(scopes)",
    "print(scopes)",
    "print(source_node.layer)",
    "def rename_Pack(self, source_node):",
    "IR_node = self._convert_identity_operation(source_node, new_op = 'Pack')",
    "kwargs['shape'] = self.tensor_shape_to_list(input_node.get_attr('_output_shapes'))[0]",
    "kwargs['shape'] = self.tensor_shape_to_list(input_node.get_attr('_output_shapes'))[0]",
    "def rename_ExpandDims(self, source_node):",
    "IR_node = self._convert_identity_operation(source_node, new_op = 'ExpandDims')",
    "input_node = self.src_graph.get_parent(source_node.name, [0])",
    "kwargs = {}",
    "kwargs['shape'] = self.tensor_shape_to_list(input_node.get_attr('_output_shapes'))[0]",
    "input_node_indices = self.src_graph.get_parent(source_node.name, [1])",
    "kwargs['exp_dim'] = input_node_indices.get_attr('value').int_val[0]",
    "assign_IRnode_values(IR_node, kwargs)",
    "weights",
    "alpha",
    "beta",
    "weights",
    "def rename_Dequantize(self, source_node):",
    "IR_node = self._convert_identity_operation(source_node,start_idx=0, end_idx= 1, new_op = 'Dequantize')",
    "kwargs = {}",
    "input_node = self.src_graph.get_parent(source_node.name, [0])",
    "kwargs['shape'] = self.tensor_shape_to_list(input_node.get_attr('_output_shapes'))[0]",
    "print(source_node.layer)",
    "print(source_node.layer)",
    "assert False",
    "kwargs = {}",
    "kwargs['mode'] = 'constant'",
    "kwargs['constant_values'] = 0.0",
    "# paddings",
    "padding = self.get_parent(source_node.name, [1]).layer.attr['value'].tensor",
    "shapes = tensor_util.MakeNdarray(padding)",
    "kwargs['pads'] = convert_tf_pad_to_onnx(shapes)",
    "assign_IRnode_values(IR_node, kwargs)",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "TODO: Handle square",
    "self._print_layer(source_node)",
    "print (source_node.name)",
    "print (self.src_graph.get_parent(source_node.name, [0]).real_name)",
    "assert False",
    "Convolution",
    "Kernel",
    "Attributes",
    "Bias",
    "Activation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "BlockFunction node",
    "redirect the composite's inputs to the true inputs",
    "BlockFunctions are short-circuited, and not added to accum[]",
    "Function node",
    "OutputVariable node",
    "def build(self):",
    "_traverse_graph(self, self.model.root_function)",
    "super(CntkGraph, self).build()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "??",
    "print(IR_node.layer)",
    "assert False",
    "print(IR_node.layer)",
    "assert False",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "network library",
    "not support multi-threads download",
    "key: layer_name    value: keras layer",
    "private functions",
    "print ('{} --> {}'.format(src, dst))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "-*- coding: utf-8 -*-",
    "from keras.layers.core import Layer",
    "Arguments",
    "Input shape",
    "Output shape",
    "Prepare broadcasting shape.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "weights",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "name, op",
    "input edge",
    "for target shape",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot weights",
    "print(\"Converting layer {}({})\".format(current_node.name, node_type))",
    "TODO",
    "return input_node, 'same'",
    "assert IR_node.get_attr('group', 1) == 1",
    "change dw from filters to 1",
    "reset the default dilation",
    "############",
    "Operators #",
    "############",
    "TODO",
    "when converting from coreml model, reshape is needed after the global pooling",
    "for Keras",
    "TODO: arguments won't be saved in keras export model",
    "print(IR_node.layer)",
    "print(IR_node.layer)",
    "Prepare broadcasting shape.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ],
  "0.1.4": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "Function self.assertEquals has deprecated, change to assertEqual",
    "get original model prediction result",
    "original to IR",
    "get original model prediction result",
    "original to IR",
    "get original model prediction result",
    "download model",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "IR to code",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "'alexnet'       : [CntkEmit, TensorflowEmit, KerasEmit],",
    "'inception_resnet_v2' : [CntkEmit, TensorflowEmit, KerasEmit], # TODO PytorchEmit",
    "'nasnet-a_large' : [TensorflowEmit, KerasEmit, PytorchEmit], # TODO",
    "get original model prediction result",
    "do not deal",
    "I don't want to deal with auto_pad",
    "Don't support auto_pad current!",
    "2018-02-28",
    "if group is None:",
    "group = 1",
    "group is not support yet too.",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "padding,",
    "exstr = \", value=float('-Inf')\"",
    "exstr = \"\"",
    "input_node = self._defuse_padding(IR_node, exstr)",
    "Ignore it in Pytorch",
    "for Keras",
    "self.add_init(2, \"self.{:<15} = torch.from_numpy(__weights_dict['{}']['value'])\".format(",
    "IR_node.variable_name,",
    "IR_node.name))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._type = layer.__class__.__name__.replace('Backward', '')",
    "self._name = \"{}_{}\".format(self.type, id)",
    "TODO",
    "\"\"\"",
    "build graph for pytorch 0.2.0",
    "\"\"\"",
    "dummy_input = torch.autograd.Variable(torch.randn(shape))",
    "output_node = self.model(dummy_input)",
    "search_queue = [output_node.grad_fn]",
    "tmp_node = PyTorchGraphNode(output_node.grad_fn, 0)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "visited = {output_node.grad_fn : self.layer_map[tmp_node.name]}",
    "idx = 0",
    "node_count = 1",
    "while (idx < len(search_queue)):",
    "current_node = search_queue[idx]",
    "current_type = visited[current_node].type",
    "if hasattr(current_node, 'next_functions'):",
    "for parent, _ in current_node.next_functions:",
    "parent_type = parent.__class__.__name__.replace('Backward', '')",
    "if parent_type != 'AccumulateGrad' and \\",
    "(parent_type != 'Transpose' or current_type != 'Addmm'):",
    "if not parent in visited:",
    "tmp_node = PyTorchGraphNode(parent, node_count)",
    "self.layer_map[tmp_node.name] = tmp_node",
    "node_count += 1",
    "visited[parent] = tmp_node",
    "search_queue.append(parent)",
    "self._make_connection(visited[parent].name, visited[current_node].name)",
    "idx += 1",
    "try:",
    "return TorchGraph._forward_torch_random_input(",
    "torch_model,",
    "input_shapes,",
    "is_batch=False",
    ")",
    "except:",
    "# try batch mode",
    "# return TorchGraph._forward_torch_random_input(",
    "#     torch_model,",
    "#     input_shapes,",
    "#     is_batch=True",
    "# )",
    "pass",
    "tensor = torch.rand(*shape).float()",
    "multi output",
    "single output",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "###########",
    "property #",
    "###########",
    "###################",
    "Public Functions #",
    "###################",
    "Build network graph",
    "#########",
    "Layers #",
    "#########",
    "handle weight",
    "handle bias",
    "handle weight",
    "handle bias",
    "###################",
    "Helper Functions #",
    "###################",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "TODO - remove style transfer 1D hack",
    "Input is 1D but it goes to the width dimension: (1,1,W)",
    "assume (Batch, Channels) - Batch dimension should be dropped",
    "assume (Batch, Sequence-Length, channels)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "else:",
    "for i, in_node in enumerate(layer.input):",
    "layer.input[i] = self.IR_graph.get_node(in_node).real_name",
    "assert False",
    "self._connect_coreml_layers()",
    "Add classifier classes (if applicable)",
    "Set pre-processing paramsters",
    "image_input_names,",
    "Return the protobuf spec",
    "model = _MLModel(self.builder.spec)",
    "Get input and output names",
    "Get the weights.",
    "Dimensions and weights",
    "Dilations",
    "print(self.IR_graph.get_parent(IR_node.name, [0]).layer)",
    "print(input_name)",
    "print(IR_node.real_name)",
    "depth-wise convolution",
    "Dilations",
    "Get input and output names",
    "Pooling layer type",
    "if it's global, set the global flag",
    "Padding",
    "Now add the layer",
    "assert False",
    "Get input and output names",
    "Get the weights from keras",
    "Get input and output names",
    "blob_order == 0 if the input blob needs not be rearranged",
    "blob_order == 1 if the input blob needs to be rearranged",
    "using keras_layer.input.shape have a \"?\" (Dimension[None] at the front),",
    "making a 3D tensor with unknown batch size 4D",
    "Get input and output names",
    "Get input and output names",
    "print(IR_node.name)",
    "input_name =",
    "negate it",
    "apply threshold",
    "negate it back",
    "for Keras",
    "Get input and output names",
    "print(input_name)",
    "print(IR_node.real_name)",
    "Set parameters",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "compute adjusted parameters",
    "assert False",
    "Now add the layer",
    "if IR_node.name != \"MMdnn_Output\" :",
    "self.emit_Flatten(IR_node)",
    "self.emit_Reshape(IR_node)",
    "Get the weights",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "if parent.output_shape.height > 1 or parent.output_shape.width > 1:",
    "TODO: The gamma parameter has to be set (in node.data?) and this should work.",
    "Also, mean should be set to 0, and var to 1, just to be safe.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "for test",
    "with open(\"graph.txt\", 'w') as f:",
    "for layer in self.IR_graph.topological_sort:",
    "current_node = self.IR_graph.get_node(layer)",
    "print(\"========current_node=========\\n{}\".format(current_node.layer), file=f)",
    "test end",
    "print(\"========current_node={}\".format(current_node.layer))",
    "keys = []",
    "for key in self.weights_dict[IR_node.name].keys():",
    "keys.append(key)",
    "print(\"=======Layer: {}, keys: {}\".format(IR_node.name, keys))",
    "self.weights_dict[IR_node.name].pop('scale', None)",
    "def emit_Tanh(self, IR_node):",
    "self._emit_activation(IR_node, 'ops.tanh')",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "self.graph = NodeRenamer()(graph)",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "Kit",
    "mapped_node.input.extend(['%s:%s' % (input.name, idx) for input, idx in node.parents])",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "Fall back to the protobuf implementation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'alexnet'        : [(657, 0.41121086), (744, 0.20789686), (847, 0.086725488), (821, 0.059082959), (595, 0.058017101)],",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load a real image and do default tf imageNet preprocessing",
    "[Batch, Height, Width, Channels] --> [Batch, Channels, Height, Width]",
    "We only deal with non-recurrent networks for now",
    "(H,W,C) --> (C,H,W)",
    "Load TensorFlow model",
    "Prepare inputs",
    "Run TF session",
    "Evaluate coreml model",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "@unittest.skip(\"Failing GPU backend: related to https://github.com/tf-coreml/tf-coreml/issues/26\")",
    "? style transfer image size and style number?",
    "Test predictions on an image",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "compare_tf_coreml_outputs(tf_out_flatten, coreml_out_flatten)",
    "#Download model",
    "url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception_v3_2016_08_28_frozen.pb.tar.gz'",
    "tf_model_dir = _download_file(url = url)",
    "tf_model_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28_frozen.pb')",
    "#Convert to coreml",
    "mlmodel_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28.mlmodel')",
    "mlmodel = tf_converter.convert(",
    "tf_model_path = tf_model_path,",
    "mlmodel_path = mlmodel_path,",
    "output_feature_names = ['InceptionV3/Predictions/Softmax:0'],",
    "input_name_shape_dict = {'input:0':[1,299,299,3]},",
    "image_input_names = ['input:0'],",
    "red_bias = -1,",
    "green_bias = -1,",
    "blue_bias = -1,",
    "image_scale = 2.0/255.0)",
    "#Test predictions on an image",
    "_test_coreml_model_image_input(",
    "tf_model_path = tf_model_path,",
    "coreml_model = mlmodel,",
    "input_tensor_name = 'input:0',",
    "output_tensor_name = 'InceptionV3/Predictions/Softmax:0',",
    "img_size = 299)",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "self.test_truth()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "caffe uses NCHW",
    "self.print_intermediate_result('', False)",
    "delete tmp model files",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "net = caffe.Net(arch_fn, weight_fn, caffe.TEST)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('InceptionV3/InceptionV3/Mixed_5b/Branch_3/AvgPool_0a_3x3/AvgPool', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "need to be updated",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "tf.train.export_meta_graph(\"kit.meta\", as_text=True)",
    "writer = tf.summary.FileWriter('./graphs', sess.graph)",
    "raise NotImplementedError()",
    "load file",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Notes for training NASNet Cifar Model",
    "-------------------------------------",
    "batch_size: 32",
    "learning rate: 0.025",
    "cosine (single period) learning rate decay",
    "auxiliary head loss weighting: 0.4",
    "clip global norm of all gradients by 5",
    "600 epochs with a batch size of 32",
    "This is used for the drop path probabilities since it needs to increase",
    "the drop out probability over the course of training.",
    "Notes for training large NASNet model on ImageNet",
    "-------------------------------------",
    "batch size (per replica): 16",
    "learning rate: 0.015 * 100",
    "learning rate decay factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 100 replicas",
    "auxiliary head loss weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Notes for training the mobile NASNet ImageNet model",
    "-------------------------------------",
    "batch size (per replica): 32",
    "learning rate: 0.04 * 50",
    "learning rate scaling factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 50 replicas",
    "auxiliary head weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Shape of feature map before the final layer.",
    "149 x 149 x 32",
    "Run the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Find where to place the reduction cells or stride normal cells",
    "Setup for building in the auxiliary head.",
    "Run the cells",
    "true_cell_num accounts for the stem cells",
    "Final softmax layer",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 192",
    "35 x 35 x 320",
    "TODO(alemi): Register intermediate endpoints",
    "17 x 17 x 1088 if output_stride == 8,",
    "33 x 33 x 1088 if output_stride == 16",
    "TODO(alemi): register intermediate endpoints",
    "TODO(gpapan): Properly support output_stride for the rest of the net.",
    "8 x 8 x 2080",
    "TODO(alemi): register intermediate endpoints",
    "8 x 8 x 1536",
    "TODO(sguada,arnoegw): Consider adding a parameter global_pool which",
    "can be set to False to disable pooling here (as in resnet_*()).",
    "Set weight_decay for weights in conv2d and fully_connected layers.",
    "Set activation_fn and parameters for batch_norm.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "=============================================================================",
    "Tensorflow mandates these.",
    "Conv and DepthSepConv namedtuple define layers of the MobileNet architecture",
    "Conv defines 3x3 convolution layers",
    "DepthSepConv defines 3x3 depthwise convolution followed by 1x1 convolution.",
    "stride is the stride of the convolution",
    "depth is the number of channels or filters in a layer",
    "_CONV_DEFS specifies the MobileNet body",
    "Used to find thinned depths for each layer.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "By passing filters=None",
    "separable_conv2d produces only a depthwise convolution layer",
    "Global average pooling.",
    "Pooling with a fixed kernel size.",
    "1 x 1 x 1024",
    "Set weight_decay for weights in Conv and DepthSepConv layers.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Skip path 1",
    "Skip path 2",
    "First pad with 0's on the right and bottom, then shift the filter to",
    "include those 0's that were added.",
    "Concat and apply BN",
    "Set the prev layer to the current layer if it is none",
    "Check to be sure prev layer stuff is setup correctly",
    "Apply conv operations",
    "Combine hidden states using 'add'.",
    "Add hiddenstate to the list of hiddenstates we can choose from",
    "Dont stride if this is not one of the original hiddenstates",
    "Check if a stride is needed, then use a strided 1x1 here",
    "Determine if a reduction should be applied to make the number of",
    "filters match.",
    "Return the concat of all the states",
    "Scale keep prob by layer number",
    "The added 2 is for the reduction cells",
    "Decrease the keep probability over time",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Convert network architecture only",
    "MXNet",
    "Caffe",
    "For CoreML",
    "assert args.network or args.frozen_pb",
    "Caffe",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if layout not in MXNetEmitter.channels_last:",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "def emit_ConvTranspose(self, IR_node):",
    "if self.weight_loaded:",
    "weight_dict = self.weights[IR_node.name]",
    "weights = weight_dict['weights']",
    "dim = len(IR_node.IR_layer.attr[\"kernel_shape\"].list.i) - 2",
    "kernel = list()",
    "for idx in range(0, dim):",
    "kernel.append(IR_node.IR_layer.attr[\"kernel_shape\"].list.i[idx])",
    "stride = list()",
    "for e in IR_node.IR_layer.attr[\"strides\"].list.i[1:-1]:",
    "stride.append(e)",
    "dilate = list()",
    "for e in IR_node.IR_layer.attr[\"dilations\"].list.i[1:-1]:",
    "dilate.append(e)",
    "dilate = ', '.join('%s' % i for i in dilate)",
    "defuse_pad = False",
    "pad = list()",
    "if \"pads\" in IR_node.IR_layer.attr:",
    "output_shape = list()",
    "for e in IR_node.IR_layer.attr[\"_output_shapes\"].list.shape[0].dim:",
    "output_shape.append(e.size)",
    "# print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "defuse_pad, pad = MXNetEmitter.transfer_pad(IR_node.IR_layer.attr[\"pads\"].list.i)",
    "pad = ', '.join('%s' % i for i in pad)",
    "kernel = ', '.join('%s' % i for i in kernel)",
    "stride = ', '.join('%s' % i for i in stride)",
    "num_filter = IR_node.IR_layer.attr[\"kernel_shape\"].list.i[-2]",
    "no_bias = not IR_node.IR_layer.attr[\"use_bias\"].b",
    "if not no_bias and self.weight_loaded:",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_bias\"] = weight_dict['bias']",
    "# layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NCHW'",
    "elif dim == 3:",
    "layout = 'NCDHW'",
    "if self.weight_loaded:",
    "# if layout not in MXNetEmitter.channels_last:",
    "weights = MXNetEmitter.transpose(weights, dim)",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_weight\"] = weights",
    "code = \"\"",
    "if not defuse_pad:",
    "code = \"{:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), pad = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "kernel,",
    "stride,",
    "dilate,",
    "pad,",
    "num_filter,",
    "no_bias,",
    "layout,",
    "IR_node.replace_scope(IR_node.name))",
    "else:",
    "code = self.set_pad(IR_node, code, pad)",
    "code += \"\\n    {:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name) + \"_pad\", kernel, stride, dilate, num_filter, no_bias, layout, IR_node.replace_scope(IR_node.name))",
    "return code",
    "def emit_LeakyReLU(self, IR_node):",
    "# IR only support Elu, the same problem with func emit_Activation",
    "code = \"{:<15} = mx.sym.LeakyReLU(data = {}, )\".format()",
    "return code",
    "raise NotImplementedError",
    "reverse cannot support yet",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(\"trans\", self.parent_variable_name(IR_node))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "Load the model network and weights",
    "digraph = mx.viz.plot_network(sym, save_format='jpg') # For debugging",
    "digraph.render()",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "load the model network",
    "adjust the data format",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "for e in pad:",
    "IR_node.attr[\"pads\"].list.i.extend([e, e])",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "name, op",
    "input edge",
    "units",
    "use bias (no_bias default = False)",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "input edge",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "groups",
    "in_channel = in_channel // group",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "padding",
    "weights",
    "axis",
    "scale",
    "epsilon",
    "momentum",
    "weights",
    "gamma",
    "beta",
    "if MXNetParser.str2bool(source_node.get_attr(\"use_global_stats\", \"False\")):",
    "mean",
    "var",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "kernel_shape",
    "padding",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "dim",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "weights",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "IR only support elu and prelu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "return",
    "name, op",
    "gamma",
    "input edge",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "alpha",
    "beta",
    "knorm",
    "nsize",
    "keep_prob",
    "mode",
    "reverse cannot support yet",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "dim",
    "dtype",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "axis",
    "raise NotImplementedError(\"No matching IR api\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into TensorFlow graph",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Matmul Layer",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "skip_prefix = [",
    "\"^\",",
    "\"train_op\",",
    "\"save\",",
    "\"gradients\",",
    "\"init\",",
    "\"global_step\",",
    "\"distort_image\",",
    "\"Adagrad\",",
    "]",
    "\"Switch\"",
    "\"Dequantize\",",
    "\"RequantizationRange\",",
    "\"Requantize\",",
    "\"ExpandDims\",",
    "\"Cast\"",
    "load model files into TensorFlow graph",
    "model = original_gdef",
    "Save it to an output file",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "assert False",
    "print(output_node.layer)",
    "beta  (bias)",
    "moving mean (mean)",
    "input node",
    "output node",
    "epsilon",
    "beta",
    "gamma (scale)",
    "output_node = self.get_son(source_node.name, [0, 0, 0, 0], True)",
    "assert False",
    "print(IR_node)",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "assert variable.get_attr('_output_shapes')[0].dim[0].size == IR_node.attr['kernel_shape'].list.i[-1]",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "epsilon",
    "moving variance (var) /read",
    "gamma (scale)",
    "beta  (bias)",
    "moving mean (mean)",
    "print(tensor_content)",
    "print(IR_node)",
    "print(source_node.layer)",
    "assert False",
    "print(source_node.layer)",
    "assert False",
    "mean/read",
    "print(scopes)",
    "kwargs['shape'] = self.tensor_shape_to_list(input_node.get_attr('_output_shapes'))[0]",
    "kwargs['shape'] = self.tensor_shape_to_list(input_node.get_attr('_output_shapes'))[0]",
    "weights",
    "alpha",
    "beta",
    "weights",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "TODO: Handle square",
    "self._print_layer(source_node)",
    "print (source_node.name)",
    "print (self.src_graph.get_parent(source_node.name, [0]).real_name)",
    "assert False",
    "Convolution",
    "Kernel",
    "Attributes",
    "Bias",
    "Activation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "BlockFunction node",
    "redirect the composite's inputs to the true inputs",
    "BlockFunctions are short-circuited, and not added to accum[]",
    "Function node",
    "OutputVariable node",
    "def build(self):",
    "_traverse_graph(self, self.model.root_function)",
    "super(CntkGraph, self).build()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "network library",
    "not support multi-threads download",
    "key: layer_name    value: keras layer",
    "private functions",
    "print ('{} --> {}'.format(src, dst))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "weights",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "print (source_node.layer.function)",
    "import marshal",
    "raw_code = marshal.dumps(source_node.layer.function.__code__)",
    "print (raw_code)",
    "print (source_node.layer.get_config())",
    "name, op",
    "input edge",
    "arguments not implementent",
    "print (type(source_node.keras_layer.arguments))",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot weights",
    "assert IR_node.get_attr('group', 1) == 1",
    "############",
    "Operators #",
    "############",
    "for Keras",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "if hasattr(layer, '_inbound_nodes'):",
    "print (dir(node), type(node), type(layer))",
    "assert False",
    "for pred in node._inbound_nodes:",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ],
  "0.1.3": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "self.assertGreater(SNR, self.snr_thresh)",
    "self.assertGreater(PSNR, self.psnr_thresh)",
    "get original model prediction result",
    "original to IR",
    "get original model prediction result",
    "download model",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "download model",
    "get original model prediction result",
    "original to IR",
    "IR to code",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "IR to code",
    "import converted model",
    "'alexnet'       : [TensorflowEmit, KerasEmit],",
    "'resnet18'      : [TensorflowEmit, KerasEmit],",
    "'inception_resnet_v2' : [CntkEmit, TensorflowEmit, KerasEmit, PytorchEmit], # TODO",
    "'nasnet-a_large' : [TensorflowEmit, KerasEmit, PytorchEmit], # TODO",
    "get original model prediction result",
    "def test_cntk(self):",
    "self._test_function('cntk', self.CntkParse)",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "padding,",
    "Ignore it in Pytorch",
    "for Keras",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "TODO - remove style transfer 1D hack",
    "Input is 1D but it goes to the width dimension: (1,1,W)",
    "assume (Batch, Channels) - Batch dimension should be dropped",
    "assume (Batch, Sequence-Length, channels)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "for i, in_node in enumerate(layer.input):",
    "layer.input[i] = self.IR_graph.get_node(in_node).real_name",
    "self._connect_coreml_layers()",
    "Add classifier classes (if applicable)",
    "Set pre-processing paramsters",
    "image_input_names,",
    "Return the protobuf spec",
    "model = _MLModel(self.builder.spec)",
    "Get input and output names",
    "Get the weights.",
    "Dimensions and weights",
    "Dilations",
    "depth-wise convolution",
    "Dilations",
    "Get input and output names",
    "Pooling layer type",
    "if it's global, set the global flag",
    "Padding",
    "Get input and output names",
    "Get the weights from keras",
    "Get input and output names",
    "blob_order == 0 if the input blob needs not be rearranged",
    "blob_order == 1 if the input blob needs to be rearranged",
    "using keras_layer.input.shape have a \"?\" (Dimension[None] at the front),",
    "making a 3D tensor with unknown batch size 4D",
    "print(\"input_shape, target_shape\",input_shape,target_shape)",
    "Get input and output names",
    "Get input and output names",
    "print(IR_node.name)",
    "negate it",
    "apply threshold",
    "negate it back",
    "for Keras",
    "Get input and output names",
    "Set parameters",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "compute adjusted parameters",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "if parent.output_shape.height > 1 or parent.output_shape.width > 1:",
    "TODO: The gamma parameter has to be set (in node.data?) and this should work.",
    "Also, mean should be set to 0, and var to 1, just to be safe.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "for test",
    "test end",
    "print(\"========current_node={}\".format(current_node.layer))",
    "self.add_body(1, \"return n.{}\".format(",
    "','.join([self.IR_graph.get_node(name).real_variable_name for name in self.IR_graph.output_layers])))",
    "for test",
    "keys = []",
    "for key in self.weights_dict[IR_node.name].keys():",
    "keys.append(key)",
    "print(\"=======Layer: {}, keys: {}\".format(IR_node.name, keys))",
    "def emit_Tanh(self, IR_node):",
    "self._emit_activation(IR_node, 'ops.tanh')",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "self.graph = NodeRenamer()(graph)",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "Kit",
    "mapped_node.input.extend(['%s:%s' % (input.name, idx) for input, idx in node.parents])",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "Fall back to the protobuf implementation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'alexnet'        : [(657, 0.41121086), (744, 0.20789686), (847, 0.086725488), (821, 0.059082959), (595, 0.058017101)],",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "Load a real image and do default tf imageNet preprocessing",
    "[Batch, Height, Width, Channels] --> [Batch, Channels, Height, Width]",
    "We only deal with non-recurrent networks for now",
    "(H,W,C) --> (C,H,W)",
    "Load TensorFlow model",
    "Prepare inputs",
    "Run TF session",
    "Evaluate coreml model",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "Test predictions on an image",
    "@unittest.skip(\"Failing GPU backend: related to https://github.com/tf-coreml/tf-coreml/issues/26\")",
    "? style transfer image size and style number?",
    "Test predictions on an image",
    "evaluate the TF model",
    "evaluate CoreML",
    "Test the default CoreML evaluation",
    "compare_tf_coreml_outputs(tf_out_flatten, coreml_out_flatten)",
    "#Download model",
    "url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception_v3_2016_08_28_frozen.pb.tar.gz'",
    "tf_model_dir = _download_file(url = url)",
    "tf_model_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28_frozen.pb')",
    "#Convert to coreml",
    "mlmodel_path = os.path.join(TMP_MODEL_DIR, 'inception_v3_2016_08_28.mlmodel')",
    "mlmodel = tf_converter.convert(",
    "tf_model_path = tf_model_path,",
    "mlmodel_path = mlmodel_path,",
    "output_feature_names = ['InceptionV3/Predictions/Softmax:0'],",
    "input_name_shape_dict = {'input:0':[1,299,299,3]},",
    "image_input_names = ['input:0'],",
    "red_bias = -1,",
    "green_bias = -1,",
    "blue_bias = -1,",
    "image_scale = 2.0/255.0)",
    "#Test predictions on an image",
    "_test_coreml_model_image_input(",
    "tf_model_path = tf_model_path,",
    "coreml_model = mlmodel,",
    "input_tensor_name = 'input:0',",
    "output_tensor_name = 'InceptionV3/Predictions/Softmax:0',",
    "img_size = 299)",
    "Download model",
    "Convert to coreml",
    "Test predictions on an image",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "self.test_truth()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "caffe uses NCHW",
    "self.print_intermediate_result('', False)",
    "delete tmp model files",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "net = caffe.Net(arch_fn, weight_fn, caffe.TEST)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "need to be updated",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "load file",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Notes for training NASNet Cifar Model",
    "-------------------------------------",
    "batch_size: 32",
    "learning rate: 0.025",
    "cosine (single period) learning rate decay",
    "auxiliary head loss weighting: 0.4",
    "clip global norm of all gradients by 5",
    "600 epochs with a batch size of 32",
    "This is used for the drop path probabilities since it needs to increase",
    "the drop out probability over the course of training.",
    "Notes for training large NASNet model on ImageNet",
    "-------------------------------------",
    "batch size (per replica): 16",
    "learning rate: 0.015 * 100",
    "learning rate decay factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 100 replicas",
    "auxiliary head loss weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Notes for training the mobile NASNet ImageNet model",
    "-------------------------------------",
    "batch size (per replica): 32",
    "learning rate: 0.04 * 50",
    "learning rate scaling factor: 0.97",
    "num epochs per decay: 2.4",
    "sync sgd with 50 replicas",
    "auxiliary head weighting: 0.4",
    "label smoothing: 0.1",
    "clip global norm of all gradients by 10",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Decay for the moving averages.",
    "epsilon to prevent 0s in variance.",
    "Shape of feature map before the final layer.",
    "149 x 149 x 32",
    "Run the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Calculate the total number of cells in the network",
    "Add 2 for the reduction cells",
    "If ImageNet, then add an additional two for the stem cells",
    "Find where to place the reduction cells or stride normal cells",
    "Setup for building in the auxiliary head.",
    "Run the cells",
    "true_cell_num accounts for the stem cells",
    "Final softmax layer",
    "Copyright 2016 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "Use clip_by_value to simulate bandpass activation.",
    "149 x 149 x 32",
    "147 x 147 x 32",
    "147 x 147 x 64",
    "73 x 73 x 64",
    "73 x 73 x 80",
    "71 x 71 x 192",
    "35 x 35 x 192",
    "35 x 35 x 320",
    "TODO(alemi): Register intermediate endpoints",
    "17 x 17 x 1088 if output_stride == 8,",
    "33 x 33 x 1088 if output_stride == 16",
    "TODO(alemi): register intermediate endpoints",
    "TODO(gpapan): Properly support output_stride for the rest of the net.",
    "8 x 8 x 2080",
    "TODO(alemi): register intermediate endpoints",
    "8 x 8 x 1536",
    "TODO(sguada,arnoegw): Consider adding a parameter global_pool which",
    "can be set to False to disable pooling here (as in resnet_*()).",
    "Set weight_decay for weights in conv2d and fully_connected layers.",
    "Set activation_fn and parameters for batch_norm.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "=============================================================================",
    "Tensorflow mandates these.",
    "Conv and DepthSepConv namedtuple define layers of the MobileNet architecture",
    "Conv defines 3x3 convolution layers",
    "DepthSepConv defines 3x3 depthwise convolution followed by 1x1 convolution.",
    "stride is the stride of the convolution",
    "depth is the number of channels or filters in a layer",
    "_CONV_DEFS specifies the MobileNet body",
    "Used to find thinned depths for each layer.",
    "The current_stride variable keeps track of the output stride of the",
    "activations, i.e., the running product of convolution strides up to the",
    "current network layer. This allows us to invoke atrous convolution",
    "whenever applying the next convolution would result in the activations",
    "having output stride larger than the target output_stride.",
    "The atrous convolution rate parameter.",
    "If we have reached the target output_stride, then we need to employ",
    "atrous convolution with stride=1 and multiply the atrous rate by the",
    "current unit's stride for use in subsequent layers.",
    "By passing filters=None",
    "separable_conv2d produces only a depthwise convolution layer",
    "Global average pooling.",
    "Pooling with a fixed kernel size.",
    "1 x 1 x 1024",
    "Set weight_decay for weights in Conv and DepthSepConv layers.",
    "Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
    "",
    "Licensed under the Apache License, Version 2.0 (the \"License\");",
    "you may not use this file except in compliance with the License.",
    "You may obtain a copy of the License at",
    "",
    "http://www.apache.org/licenses/LICENSE-2.0",
    "",
    "Unless required by applicable law or agreed to in writing, software",
    "distributed under the License is distributed on an \"AS IS\" BASIS,",
    "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
    "See the License for the specific language governing permissions and",
    "limitations under the License.",
    "==============================================================================",
    "Skip path 1",
    "Skip path 2",
    "First pad with 0's on the right and bottom, then shift the filter to",
    "include those 0's that were added.",
    "Concat and apply BN",
    "Set the prev layer to the current layer if it is none",
    "Check to be sure prev layer stuff is setup correctly",
    "Apply conv operations",
    "Combine hidden states using 'add'.",
    "Add hiddenstate to the list of hiddenstates we can choose from",
    "Dont stride if this is not one of the original hiddenstates",
    "Check if a stride is needed, then use a strided 1x1 here",
    "Determine if a reduction should be applied to make the number of",
    "filters match.",
    "Return the concat of all the states",
    "Scale keep prob by layer number",
    "The added 2 is for the reduction cells",
    "Decrease the keep probability over time",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Convert network architecture only",
    "MXNet",
    "Caffe",
    "For CoreML",
    "Caffe",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if layout not in MXNetEmitter.channels_last:",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "def emit_ConvTranspose(self, IR_node):",
    "if self.weight_loaded:",
    "weight_dict = self.weights[IR_node.name]",
    "weights = weight_dict['weights']",
    "dim = len(IR_node.IR_layer.attr[\"kernel_shape\"].list.i) - 2",
    "kernel = list()",
    "for idx in range(0, dim):",
    "kernel.append(IR_node.IR_layer.attr[\"kernel_shape\"].list.i[idx])",
    "stride = list()",
    "for e in IR_node.IR_layer.attr[\"strides\"].list.i[1:-1]:",
    "stride.append(e)",
    "dilate = list()",
    "for e in IR_node.IR_layer.attr[\"dilations\"].list.i[1:-1]:",
    "dilate.append(e)",
    "dilate = ', '.join('%s' % i for i in dilate)",
    "defuse_pad = False",
    "pad = list()",
    "if \"pads\" in IR_node.IR_layer.attr:",
    "output_shape = list()",
    "for e in IR_node.IR_layer.attr[\"_output_shapes\"].list.shape[0].dim:",
    "output_shape.append(e.size)",
    "# print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "defuse_pad, pad = MXNetEmitter.transfer_pad(IR_node.IR_layer.attr[\"pads\"].list.i)",
    "pad = ', '.join('%s' % i for i in pad)",
    "kernel = ', '.join('%s' % i for i in kernel)",
    "stride = ', '.join('%s' % i for i in stride)",
    "num_filter = IR_node.IR_layer.attr[\"kernel_shape\"].list.i[-2]",
    "no_bias = not IR_node.IR_layer.attr[\"use_bias\"].b",
    "if not no_bias and self.weight_loaded:",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_bias\"] = weight_dict['bias']",
    "# layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NCHW'",
    "elif dim == 3:",
    "layout = 'NCDHW'",
    "if self.weight_loaded:",
    "# if layout not in MXNetEmitter.channels_last:",
    "weights = MXNetEmitter.transpose(weights, dim)",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_weight\"] = weights",
    "code = \"\"",
    "if not defuse_pad:",
    "code = \"{:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), pad = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "kernel,",
    "stride,",
    "dilate,",
    "pad,",
    "num_filter,",
    "no_bias,",
    "layout,",
    "IR_node.replace_scope(IR_node.name))",
    "else:",
    "code = self.set_pad(IR_node, code, pad)",
    "code += \"\\n    {:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name) + \"_pad\", kernel, stride, dilate, num_filter, no_bias, layout, IR_node.replace_scope(IR_node.name))",
    "return code",
    "def emit_LeakyReLU(self, IR_node):",
    "# IR only support Elu, the same problem with func emit_Activation",
    "code = \"{:<15} = mx.sym.LeakyReLU(data = {}, )\".format()",
    "return code",
    "raise NotImplementedError",
    "reverse cannot support yet",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(\"trans\", self.parent_variable_name(IR_node))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "Load the model network and weights",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "load the model network",
    "adjust the data format",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "for e in pad:",
    "IR_node.attr[\"pads\"].list.i.extend([e, e])",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "attr",
    "units",
    "use bias (no_bias default = False)",
    "output shape",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "input edge",
    "output shape",
    "attr",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "groups",
    "in_channel = in_channel // group",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "padding",
    "weights",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "axis",
    "scale",
    "epsilon",
    "momentum",
    "weights",
    "gamma",
    "beta",
    "if MXNetParser.str2bool(layer_attr.get(\"use_global_stats\", \"False\")):",
    "mean",
    "var",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "kernel_shape",
    "padding",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "name, op",
    "input edge",
    "dim",
    "output shape",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "weights",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "attr",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "IR only support elu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "judge whether meaningful",
    "name, op",
    "input edge",
    "attr",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "alpha",
    "beta",
    "knorm",
    "nsize",
    "output shape",
    "def rename_ROIPooling(self, source_node):",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "keep_prob",
    "mode",
    "output shape",
    "reverse cannot support yet",
    "name, op",
    "input edge",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "name, op",
    "input edge",
    "output shape",
    "name, op",
    "output shape",
    "input edge",
    "attr",
    "dim",
    "name, op",
    "input edge",
    "attr",
    "dtype",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "attr",
    "axis",
    "name, op",
    "input edge",
    "output shape",
    "raise NotImplementedError(\"No matching IR api\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into TensorFlow graph",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Matmul Layer",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Build network graph",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "BlockFunction node",
    "redirect the composite's inputs to the true inputs",
    "BlockFunctions are short-circuited, and not added to accum[]",
    "Function node",
    "OutputVariable node",
    "def build(self):",
    "_traverse_graph(self, self.model.root_function)",
    "super(CntkGraph, self).build()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "network library",
    "not support multi-threads download",
    "key: layer_name    value: keras layer",
    "private functions",
    "print ('{} --> {}'.format(src, dst))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "print (source_node.layer.function)",
    "import marshal",
    "raw_code = marshal.dumps(source_node.layer.function.__code__)",
    "print (raw_code)",
    "print (source_node.layer.get_config())",
    "name, op",
    "input edge",
    "arguments not implementent",
    "print (type(source_node.keras_layer.arguments))",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot weights",
    "assert IR_node.get_attr('group', 1) == 1",
    "############",
    "Operators #",
    "############",
    "for Keras",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "if hasattr(layer, '_inbound_nodes'):",
    "print (dir(node), type(node), type(layer))",
    "assert False",
    "for pred in node._inbound_nodes:",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ],
  "0.1.2": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "padding,",
    "Ignore it in Pytorch",
    "for Keras",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "if parent.output_shape.height > 1 or parent.output_shape.width > 1:",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "self.graph = NodeRenamer()(graph)",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "Kit",
    "mapped_node.input.extend(['%s:%s' % (input.name, idx) for input, idx in node.parents])",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "Fall back to the protobuf implementation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "pylint: disable=line-too-long",
    "pylint: enable=line-too-long",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "need to be updated",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "testop = tf.get_default_graph().get_operation_by_name(layer_name)",
    "self.print_intermediate_result('conv1_7x7_s2_1', True)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('block2_pool', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "MXNet",
    "only convert network structure",
    "Caffe",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "var = raw_input(\"Input layer not detected, please type data shape manually(i.e. X, X, X, X): \")",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if layout not in MXNetEmitter.channels_last:",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "def emit_ConvTranspose(self, IR_node):",
    "if self.weight_loaded:",
    "weight_dict = self.weights[IR_node.name]",
    "weights = weight_dict['weights']",
    "dim = len(IR_node.IR_layer.attr[\"kernel_shape\"].list.i) - 2",
    "kernel = list()",
    "for idx in range(0, dim):",
    "kernel.append(IR_node.IR_layer.attr[\"kernel_shape\"].list.i[idx])",
    "stride = list()",
    "for e in IR_node.IR_layer.attr[\"strides\"].list.i[1:-1]:",
    "stride.append(e)",
    "dilate = list()",
    "for e in IR_node.IR_layer.attr[\"dilations\"].list.i[1:-1]:",
    "dilate.append(e)",
    "dilate = ', '.join('%s' % i for i in dilate)",
    "defuse_pad = False",
    "pad = list()",
    "if \"pads\" in IR_node.IR_layer.attr:",
    "output_shape = list()",
    "for e in IR_node.IR_layer.attr[\"_output_shapes\"].list.shape[0].dim:",
    "output_shape.append(e.size)",
    "# print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "defuse_pad, pad = MXNetEmitter.transfer_pad(IR_node.IR_layer.attr[\"pads\"].list.i)",
    "pad = ', '.join('%s' % i for i in pad)",
    "kernel = ', '.join('%s' % i for i in kernel)",
    "stride = ', '.join('%s' % i for i in stride)",
    "num_filter = IR_node.IR_layer.attr[\"kernel_shape\"].list.i[-2]",
    "no_bias = not IR_node.IR_layer.attr[\"use_bias\"].b",
    "if not no_bias and self.weight_loaded:",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_bias\"] = weight_dict['bias']",
    "# layout = IR_node.IR_layer.attr[\"data_format\"].s",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NCHW'",
    "elif dim == 3:",
    "layout = 'NCDHW'",
    "if self.weight_loaded:",
    "# if layout not in MXNetEmitter.channels_last:",
    "weights = MXNetEmitter.transpose(weights, dim)",
    "self.output_weights[IR_node.replace_scope(IR_node.name) + \"_weight\"] = weights",
    "code = \"\"",
    "if not defuse_pad:",
    "code = \"{:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), pad = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "kernel,",
    "stride,",
    "dilate,",
    "pad,",
    "num_filter,",
    "no_bias,",
    "layout,",
    "IR_node.replace_scope(IR_node.name))",
    "else:",
    "code = self.set_pad(IR_node, code, pad)",
    "code += \"\\n    {:<15} = mx.sym.Deconvolution(data = {}, kernel = ({}), stride = ({}), dilate = ({}), num_filter = {}, no_bias = {}, layout = '{}', name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name) + \"_pad\", kernel, stride, dilate, num_filter, no_bias, layout, IR_node.replace_scope(IR_node.name))",
    "return code",
    "def emit_LeakyReLU(self, IR_node):",
    "# IR only support Elu, the same problem with func emit_Activation",
    "code = \"{:<15} = mx.sym.LeakyReLU(data = {}, )\".format()",
    "return code",
    "raise NotImplementedError",
    "reverse cannot support yet",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(\"trans\", self.parent_variable_name(IR_node))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "Load the model network and weights",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "load the model network",
    "adjust the data format",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "for e in pad:",
    "IR_node.attr[\"pads\"].list.i.extend([e, e])",
    "IR_node.attr[\"pads\"].list.i.extend([0, 0])",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "attr",
    "units",
    "use bias (no_bias default = False)",
    "output shape",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "input edge",
    "output shape",
    "attr",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "padding",
    "weights",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "axis",
    "scale",
    "epsilon",
    "momentum",
    "weights",
    "gamma",
    "beta",
    "if MXNetParser.str2bool(layer_attr.get(\"use_global_stats\", \"False\")):",
    "mean",
    "var",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "kernel_shape",
    "padding",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "name, op",
    "input edge",
    "dim",
    "output shape",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "output shape",
    "kernel_shape",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "groups",
    "weights",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "attr",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "IR only support elu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "judge whether meaningful",
    "name, op",
    "input edge",
    "attr",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "alpha",
    "beta",
    "knorm",
    "nsize",
    "output shape",
    "def rename_ROIPooling(self, source_node):",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "keep_prob",
    "mode",
    "output shape",
    "reverse cannot support yet",
    "name, op",
    "input edge",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "name, op",
    "input edge",
    "output shape",
    "name, op",
    "output shape",
    "input edge",
    "attr",
    "dim",
    "name, op",
    "input edge",
    "attr",
    "dtype",
    "output shape",
    "name, op",
    "input edge",
    "output shape",
    "attr",
    "axis",
    "name, op",
    "input edge",
    "output shape",
    "raise NotImplementedError(\"No matching IR api\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into Keras graph",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Matmul Layer",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "network library",
    "not support multi-threads download",
    "key: layer_name    value: keras layer",
    "private functions",
    "print (\"Warning: Graph Construct a self-loop node {}. Ignored.\".format(src))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "name, op",
    "input edge",
    "arguments not implementent",
    "print (type(source_node.keras_layer.arguments))",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot weights",
    "############",
    "Operators #",
    "############",
    "for Keras",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "k = parseFloat(k)*parseFloat(k_)",
    "limit x, y",
    "// a trick to make text svg transform in MS Edge",
    "d3.selectAll(\".labels\").classed(\"tempclass\", true);",
    "setTimeout(function () { d3.selectAll(\".labels\").classed(\"tempclass\", false); }, 40);",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ],
  "0.1.1": [
    "Get the long description from the README file",
    "Versions should comply with PEP440.  For a discussion on single-sourcing",
    "the version across setup.py and the project code, see",
    "https://packaging.python.org/en/latest/single_source_version.html",
    "The project's main homepage.",
    "Author details",
    "Choose your license",
    "See https://pypi.python.org/pypi?%3Aaction=list_classifiers",
    "How mature is this project? Common values are",
    "3 - Alpha",
    "4 - Beta",
    "5 - Production/Stable",
    "Indicate who your project is intended for",
    "Pick your license as you wish (should match \"license\" above)",
    "Specify the Python versions you support here. In particular, ensure",
    "that you indicate whether you support Python 2, Python 3 or both.",
    "What does your project relate to?",
    "You can just specify the packages manually here if your project is",
    "simple. Or you can use find_packages().",
    "Alternatively, if you want to distribute just a my_module.py, uncomment",
    "this:",
    "py_modules=[\"my_module\"],",
    "List run-time dependencies here.  These will be installed by pip when",
    "your project is installed. For an analysis of \"install_requires\" vs pip's",
    "requirements files see:",
    "https://packaging.python.org/en/latest/requirements.html",
    "To provide executable scripts, use entry points in preference to the",
    "\"scripts\" keyword. Entry points provide cross-platform support and allow",
    "pip to create the appropriate form of executable for the target platform.",
    "print (dir(data))",
    "print (i)",
    "print (\"    {} with shape {}\".format(j, load_weight[i][j].shape))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Base Functions",
    "https://github.com/pytorch/pytorch/blob/master/torch/nn/modules/conv.py",
    "padding,",
    "Ignore it in Pytorch",
    "for Keras",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: caffe.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:caffe.BlobShape)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProto)",
    "@@protoc_insertion_point(class_scope:caffe.BlobProtoVector)",
    "@@protoc_insertion_point(class_scope:caffe.Datum)",
    "@@protoc_insertion_point(class_scope:caffe.FillerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.NetParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SolverState)",
    "@@protoc_insertion_point(class_scope:caffe.NetState)",
    "@@protoc_insertion_point(class_scope:caffe.NetStateRule)",
    "@@protoc_insertion_point(class_scope:caffe.ParamSpec)",
    "@@protoc_insertion_point(class_scope:caffe.LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TransformationParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.AccuracyParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConcatParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BatchNormParameter)",
    "@@protoc_insertion_point(class_scope:caffe.BiasParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.CropParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DropoutParameter)",
    "@@protoc_insertion_point(class_scope:caffe.DummyDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EltwiseParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ELUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.EmbedParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ExpParameter)",
    "@@protoc_insertion_point(class_scope:caffe.FlattenParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.HingeLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ImageDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InnerProductParameter)",
    "@@protoc_insertion_point(class_scope:caffe.InputParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LogParameter)",
    "@@protoc_insertion_point(class_scope:caffe.LRNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.MVNParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ParameterParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PoolingParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PowerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PythonParameter)",
    "@@protoc_insertion_point(class_scope:caffe.RecurrentParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReductionParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReLUParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ReshapeParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ScaleParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SigmoidParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SliceParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TanHParameter)",
    "@@protoc_insertion_point(class_scope:caffe.TileParameter)",
    "@@protoc_insertion_point(class_scope:caffe.ThresholdParameter)",
    "@@protoc_insertion_point(class_scope:caffe.WindowDataParameter)",
    "@@protoc_insertion_point(class_scope:caffe.SPPParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V1LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.V0LayerParameter)",
    "@@protoc_insertion_point(class_scope:caffe.PReLUParameter)",
    "@@protoc_insertion_point(module_scope)",
    "TODO: We need to identify whether this is 4D image data, otherwise we shouldn't change the dimension order",
    "Stochastic pooling, for instance.",
    "TODO: Axis",
    "TODO: Unbiased",
    "check if need the Flatten layer",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Caffe Types",
    "Same value applies to all spatial dimensions",
    "Extract the value for the given spatial dimension",
    "consider rewrite this function to Network.py",
    "Dropout layers appear in a fair number of Caffe",
    "test-time networks. These are just ignored. We'll",
    "filter them out here.",
    "TODO: raise error",
    "TODO: raise error",
    "Automatically set a name if not provided.",
    "Figure out the layer inputs.",
    "print('op: %s   shape: %s' % (op, layer_output._keras_shape))",
    "print('op: %s   shape: %s' % (op, layer_output.get_shape().as_list()))",
    "Add to layer LUT.",
    "Old-style input specification",
    "New-style input specification",
    "We most likely have a data layer on our hands. The problem is,",
    "Caffe infers the dimensions of the data from the source (eg: LMDB).",
    "We want to avoid reading datasets here. Fail for now.",
    "This can be temporarily fixed by transforming the data layer to",
    "Caffe's \"input\" layer (as is usually used in the \"deploy\" version).",
    "TODO: Find a better solution for this.",
    "The .prototxt file defining the graph",
    "The .caffemodel file containing the learned parameters",
    "Set to true if the fallback protocol-buffer based backend was used",
    "A list containing (layer name, parameters) tuples",
    "Load the parameters",
    "When using the protobuf-backend, each parameter initially has four dimensions.",
    "In certain cases (like FC layers), we want to eliminate the singleton dimensions.",
    "This implementation takes care of the common cases. However, it does leave the",
    "potential for future issues.",
    "The Caffe-backend does not suffer from this problem.",
    "A dictionary mapping NodeKind to the transposed order.",
    "The node kinds eligible for reshaping",
    "If true, the reshaped data will replace the old one.",
    "Otherwise, it's set to the reshaped_data attribute.",
    "Check for 2+ dimensional data",
    "The FC layer connected to the spatial layer needs to be",
    "re-wired to match the new spatial ordering.",
    "node.reshaped_data = weights.transpose(transpose_order)",
    "Set the weights",
    "We're only fusing nodes with single parents",
    "We can only fuse a node if its parent's",
    "value isn't used by any other node.",
    "Rewrite the fused node's children to its parent.",
    "Disconnect the fused node from the graph.",
    "Let the sub-class merge the fused node in any arbitrary way.",
    "Fuse ReLUs when the parent node is one of the given types.",
    "If None, all node types are eligible.",
    "Prescale the stats",
    "Replace with the updated values",
    "Include the scale and bias terms",
    "return Graph(name, [self.map_node(node) for node in self.graph.nodes])",
    "Kit",
    "mapped_node.input.extend(['%s:%s' % (input.name, idx) for input, idx in node.parents])",
    "FIXME:",
    "output = node.output",
    "Decompose DAG into chains",
    "Generate Python code line by line",
    "Fall back to the protobuf implementation",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "work for tf 1.4 in windows & linux",
    "work for tf 1.3 & 1.4 in linux",
    "from tensorflow.contrib.keras.python.keras.preprocessing import image",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result()",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.input, self.model, self.testop = KitModel(os.path.abspath('.') + '/kit_imagenet.npy')",
    "testop = self.testop",
    "self.print_intermediate_result('conv1_7x7_s2_1', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "'mobilenet_v1': mobilenet_v1.mobilenet_v1_arg_scope,",
    "'mobilenet_v1' : mobilenet_v1.mobilenet_v1,",
    "Copyright (c) Microsoft. All rights reserved.",
    "Licensed under the MIT license. See LICENSE.md file in the project root",
    "for full license information.",
    "==============================================================================",
    "self.model, self.testop = self.MainModel.KitModel(self.args.w)",
    "self.print_intermediate_result(None, False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self.print_intermediate_result('block2_pool', False)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "save network structure as JSON",
    "layer_name = 'block2_pool'",
    "intermediate_layer_model = keras.Model(inputs=model.input,",
    "outputs=model.get_layer(layer_name).output)",
    "intermediate_output = intermediate_layer_model.predict(img)",
    "print (intermediate_output)",
    "print (intermediate_output.shape)",
    "print (\"%.30f\" % np.sum(intermediate_output))",
    "MXNet",
    "only convert network structure",
    "Caffe",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check non-sense always input module.Module",
    "if not (type(model) == mx.module.Module",
    "or type(model) == mx.module.SequentialModule",
    "or type(model) == mx.model)",
    "raise TypeError(\"MXNet layer of type %s is not supported.\" % type(model))",
    "if layer[\"op\"] == \"null\":",
    "continue",
    "raise NotImplementedError(\"Cannot support multi-input\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "mxnet-cpu only support channel first, default convert the model and weight as channel first",
    "download and show the image",
    "convert into format (batch, RGB, width, height)",
    "to show the image, change the argument show into True",
    "compute the predict probabilities",
    "print the top-5",
    "# call function predict",
    "with open('synset.txt', 'r') as f:",
    "labels = [l.rstrip() for l in f]",
    "predict(model, labels, 'http://writm.com/wp-content/uploads/2016/08/Cat-hd-wallpapers.jpg')",
    "var = raw_input(\"Input layer not detected, please type data shape manually(i.e. X, X, X, X): \")",
    "same_pad = int(math.ceil(float(data_shape) / float(stride)))",
    "valid_pad = int(math.ceil(float(data_shape - kernel + 1) / float(stride)))",
    "# if (same_pad - valid_pad) % 2 == 0:",
    "#     return True, (same_pad - valid_pad)",
    "# else:",
    "#     return False, (same_pad - valid_pad)",
    "return (same_pad - valid_pad)",
    "# raise NotImplementedError",
    "raise NotImplementedError",
    "print(data_shape, kernel, stride)",
    "print(\"Warning: MXNet Convolution Layer pad does not match IR Convolution Layer pad\")",
    "if layout == '':",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NHWC'",
    "elif dim == 3:",
    "layout = 'NDHWC'",
    "if layout not in MXNetEmitter.channels_last:",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 3, 1, 2))\\n\".format(IR_node.replace_scope(IR_node.name) + \"_input\", IR_node.replace_scope(IR_node.in_edges[0]))",
    "code += \"    {:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name))",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 3, 1, 2))\\n\".format(IR_node.replace_scope(IR_node.name) + \"_input\", IR_node.replace_scope(IR_node.in_edges[0]))",
    "code += \"    {:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name))",
    "Add LeakyReLU Elu(slope not support)",
    "axis = IR_node.IR_layer.attr[\"axis\"].i",
    "not supported yet",
    "print(\"Warning: MXNet Pooling Layer pad does not match IR Pooling Layer pad\")",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 3, 1, 2))\\n\".format(IR_node.replace_scope(IR_node.name) + \"_input\", IR_node.replace_scope(IR_node.in_edges[0]))",
    "code += \"    {:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name))",
    "code = \"{:<15} = mx.sym.transpose(data = {}, axes = (0, 3, 1, 2))\\n\".format(IR_node.replace_scope(IR_node.name) + \"_input\", IR_node.replace_scope(IR_node.in_edges[0]))",
    "code += \"    {:<15} = mx.sym.transpose(data = {}, axes = (0, 2, 3, 1))\\n\".format(IR_node.replace_scope(IR_node.name), IR_node.replace_scope(IR_node.name))",
    "print(\"Warning: MXNet Deconvolution Layer pad does not match IR Deconvolution Layer pad\")",
    "if layout == '':",
    "if dim == 1:",
    "layout = 'NCW'",
    "elif dim == 2:",
    "layout = 'NHWC'",
    "elif dim == 3:",
    "layout = 'NDHWC'",
    "if layout not in MXNetEmitter.channels_last:",
    "def emit_LeakyReLU(self, IR_node):",
    "# IR only support Elu, the same problem with func emit_Activation",
    "code = \"{:<15} = mx.sym.LeakyReLU(data = {}, )\".format()",
    "return code",
    "raise NotImplementedError",
    "reverse cannot support yet",
    "if \"data_format\" in IR_node.IR_layer.attr:",
    "data_format = IR_node.IR_layer.attr[\"data_format\"].s",
    "else:",
    "data_format = \"NHWC\"",
    "print(\"set the conv format before flatten as default value NHWC\")",
    "if data_format in MXNetEmitter.channels_last:",
    "else:",
    "code += \"{:<15} = mx.sym.flatten(data = {}, name = '{}')\".format(",
    "IR_node.replace_scope(IR_node.name),",
    "IR_node.replace_scope(IR_node.in_edges[0]),",
    "IR_node.replace_scope(IR_node.name))",
    "if not pad_width[2] == 0 or not pad_width[3] == 0:",
    "print(\"Warning: please check padding layer manually\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Not support yet",
    "\"softrelu\"  : \"SoftReLU\"",
    "raise NotImplementedError",
    "Load the model network and weights",
    "model.bind(data_shapes = data_shapes)",
    "model.init_params()",
    "mod.load(model_path, epoch_num)",
    "return mod.get_params()",
    "raise NotImplementedError",
    "load the model network",
    "adjust the data format",
    "raise NotImplementedError",
    "load model files into MXNet graph",
    "data_shape arguments added to calculate infer_shape(required)",
    "if isinstance(input_arg, basestring):",
    "Build network graph",
    "raise NotImplementedError",
    "for i, j in self.weights.items():",
    "print (\"parameter [{}] have weights [{}]\".format(i, len(j)))",
    "transpose to channel last",
    "name, op",
    "input edge",
    "output shape",
    "input edge",
    "attr",
    "print(\"Warning: MXNet symbol pad does not support channel last\")",
    "output shape",
    "self.set_output_shape(source_node, IR_node)",
    "self.mxnet_graph.layer_name_map[source_node.name] = IR_node.name",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "attr",
    "units",
    "use bias (no_bias default = False)",
    "output shape",
    "weights",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [NM]\".format(source_node.name, self.data_format))",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "attr",
    "filter",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "padding",
    "IR only support pad = \"SAME\" or \"VALID\"",
    "Using Padding Layer API",
    "pad = self.check_pad_mode(source_node, IR_node)",
    "if pad == \"SAME\":",
    "IR_node.attr[\"padding\"].s = b\"SAME\"",
    "elif pad == \"VALID\":",
    "IR_node.attr[\"padding\"].s = b\"VALID\"",
    "else:",
    "self._defuse_padding(source_node)",
    "del IR_node.input[:]",
    "IR_node.input.append(source_node.name + \"_pad\")",
    "output shape",
    "weights",
    "raise NotImplementedError",
    "if source_node.layer.act_type == \"relu\":",
    "MXNetParser._copy_and_reop(source_node, IR_node, \"Relu\")",
    "elif source_node.layer.act_type == \"sigmoid\":",
    "MXNetParser._copy_and_reop(source_node, IR_node, \"Sigmoid\")",
    "elif source_node.layer.act_type == \"tanh\":",
    "MXNetParser._copy_and_reop(source_node, IR_node, \"Tanh\")",
    "elif source_node.layer.act_type == \"softrelu\":",
    "MXNetParser._copy_and_reop(source_node, IR_node, \"SoftReLU\")",
    "output shape",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "axis",
    "if self.data_format not in MXNetParser.channels_last:",
    "IR_node.attr[\"axis\"].i = int(layer_attr.get(\"axis\", \"1\"))",
    "else:",
    "scale",
    "epsilon",
    "momentum",
    "output shape",
    "weights",
    "gamma",
    "beta",
    "if MXNetParser.str2bool(layer_attr.get(\"use_global_stats\", \"False\")):",
    "mean",
    "var",
    "raise NotImplementedError(\"bool type for scale and offset\")",
    "name, op",
    "input edge",
    "pooling type (sum not allowed yet)",
    "strides",
    "window_shape",
    "padding",
    "IR only support pad = \"SAME\" or \"Valid\"",
    "pad = self.check_pad_mode(source_node, IR_node)",
    "if pad == b\"SAME\":",
    "IR_node.attr[\"padding\"].s = b\"SAME\"",
    "elif pad == b\"VALID\":",
    "IR_node.attr[\"padding\"].s = b\"VALID\"",
    "else:",
    "IR_node.attr[\"padding\"].s = b\"VALID\"",
    "self._defuse_padding(source_node)",
    "del IR_node.input[:]",
    "IR_node.input.append(source_node.name + \"_pad\")",
    "output shape",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "output shape",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "dim",
    "output shape",
    "raise NotImplementedError",
    "def rename_log_softmax(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "def rename_Correlation(self, source_node):",
    "raise NotImplementedError(\"not support yet\")",
    "name, op",
    "input edge",
    "padding",
    "pad = self.check_pad_mode(source_node, IR_node)",
    "if pad == \"SAME\":",
    "IR_node.attr[\"padding\"].s = \"SAME\"",
    "elif pad == \"VALID\":",
    "IR_node.attr[\"padding\"].s = \"VALID\"",
    "else:",
    "self._defuse_padding(source_node)",
    "del IR_node.input[:]",
    "IR_node.input.append(source_node.name + \"_pad\")",
    "output shape",
    "filter",
    "print(\"Warning: Layer [{}] has changed model data format from [{}] to [{}]\".format(source_node.name, self.data_format, layout))",
    "use_bias (no_bias default = False)",
    "strides",
    "dilations",
    "data_format",
    "weights",
    "raise NotImplementedError",
    "def rename_RNN(self, source_node):",
    "raise NotImplementedError(\"RNN not support yet\")",
    "name, op",
    "input edge",
    "attr",
    "input_dim",
    "output_dim",
    "dtype",
    "output shape",
    "raise NotImplementedError",
    "IR only support elu from {'elu', 'leaky', 'prelu', 'rrelu'}",
    "judge whether meaningful",
    "name, op",
    "input edge",
    "attr",
    "alpha [exp(x) - alpha], but mxnet attr slope [slope*(exp(x) - 1)] when x < 0",
    "IR_node.attr[\"alpha\"].f = float()",
    "output shape",
    "raise NotImplementedError(\"slope cannot convert to alpha\")",
    "def rename_InstanceNorm(self, source_node):",
    "raise NotImplementedError",
    "def rename_L2Normalization(self, source_node):",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "alpha",
    "beta",
    "knorm",
    "nsize",
    "output shape",
    "def rename_ROIPooling(self, source_node):",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "keep_prob",
    "mode",
    "output shape",
    "raise NotImplementedError",
    "reverse cannot support yet",
    "name, op",
    "input edge",
    "old API target_shape not support yet",
    "output shape",
    "raise NotImplementedError(\"adjust output shape\")",
    "name, op",
    "input edge",
    "output shape",
    "IR_node.attr[\"data_format\"].s = self.data_format",
    "raise NotImplementedError",
    "name, op",
    "output shape",
    "input edge",
    "attr",
    "dim",
    "name, op",
    "input edge",
    "attr",
    "dtype",
    "output shape",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "attr",
    "axis",
    "output shape",
    "raise NotImplementedError",
    "name, op",
    "input edge",
    "output shape",
    "raise NotImplementedError(\"No matching IR api\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "keep dims",
    "axes",
    "name, op",
    "epsilon",
    "moving variance (var)",
    "gamma (scale)",
    "mean",
    "bias",
    "input node",
    "output node",
    "load model files into Keras graph",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "strides",
    "window_shape",
    "pool type",
    "padding",
    "shape",
    "strides",
    "input[1] : W",
    "filter",
    "padding",
    "output[0] : B",
    "converted [dropout]",
    "convert [tf.contrib.layers.batch_norm]",
    "normal Add",
    "for target shape",
    "units",
    "Weights",
    "FullyConnected Layer",
    "name, op",
    "get Bias",
    "Deal Dropout",
    "keep prob",
    "Remove nodes",
    "Mul",
    "Floor",
    "paddings",
    "gamma (scale)",
    "bias",
    "Mean",
    "Var",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "self._emit_unary_operation(IR_node, \"contrib.layers.flatten\")",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "For padding",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "Not tested",
    "print (input_shape)",
    "print (kernel_shape)",
    "print (strides)",
    "kernel_shape[idx] = (kernel_shape[idx] - 1) * dilation_rate + 1",
    "print ([0] + up_list + [0] + down_list if data_format.startswith('NC') else up_list + [0] + down_list + [0])",
    "print ('-----------------------------------------------------')",
    "key: layer_name    value: keras layer",
    "private functions",
    "print (\"Warning: Graph Construct a self-loop node {}. Ignored.\".format(src))",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "share functions",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "name --> (weight_name --> ndarray)",
    "Generated by the protocol buffer compiler.  DO NOT EDIT!",
    "source: graph.proto",
    "@@protoc_insertion_point(imports)",
    "@@protoc_insertion_point(class_scope:GraphDef)",
    "@@protoc_insertion_point(class_scope:NodeDef.AttrEntry)",
    "@@protoc_insertion_point(class_scope:NodeDef)",
    "@@protoc_insertion_point(class_scope:AttrValue.ListValue)",
    "@@protoc_insertion_point(class_scope:AttrValue)",
    "@@protoc_insertion_point(class_scope:TensorShape.Dim)",
    "@@protoc_insertion_point(class_scope:TensorShape)",
    "@@protoc_insertion_point(class_scope:LiteralTensor)",
    "@@protoc_insertion_point(module_scope)",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "First try to read it as a binary file.",
    "Next try to read it as a text file.",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "Load the model network",
    "Load the model weights",
    "load model files into Keras graph",
    "_keras.utils.plot_model(model, \"model.png\", show_shapes = True)",
    "Build network graph",
    "TODO: Fused conv and pool with padding is different from defused operators",
    "TODO: More activation functions",
    "for ELU",
    "input edge",
    "name, op",
    "weights",
    "pads",
    "filter",
    "[kd, kh, kw, channel_size, filter number]",
    "use_bias",
    "strides",
    "[1, sd, sh, sw, 1]",
    "dilations",
    "[1, dd, dh, dw, 1]",
    "activation",
    "name, op",
    "input edge",
    "padding",
    "strides",
    "[1, sd, sh, sw, 1]",
    "window_shape",
    "[1, pd, ph, pw, 1]",
    "name, op",
    "input edge",
    "For concat axis",
    "name, op",
    "input edge",
    "padding",
    "only for training",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "Merge Layers",
    "only for training",
    "name, op",
    "input edge",
    "shape",
    "only for training",
    "name, op",
    "input edge",
    "Core Layers",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "weights",
    "activation",
    "name, op",
    "input edge",
    "name, op",
    "input edge",
    "input_dim",
    "output_dim",
    "mask_zero",
    "weights",
    "name, op",
    "input edge",
    "units",
    "use_bias",
    "for Keras, drop_out and recurrent_dropout",
    "activation",
    "name, op",
    "input edge",
    "units",
    "activation",
    "Kit TODO : need to search the tf",
    "name, op",
    "input edge",
    "for target shape",
    "name, op",
    "input edge",
    "arguments not implementent",
    "print (type(source_node.keras_layer.arguments))",
    "name, op",
    "input edge",
    "axis",
    "Parameter arrangement in Keras: gamma, beta, mean, variance",
    "scale",
    "beta",
    "mean",
    "var",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "rot weights",
    "############",
    "Operators #",
    "############",
    "for Keras",
    "----------------------------------------------------------------------------------------------",
    "Copyright (c) Microsoft Corporation. All rights reserved.",
    "Licensed under the MIT License. See License.txt in the project root for license information.",
    "----------------------------------------------------------------------------------------------",
    "sanity check.",
    "Kit: TODO",
    "Duplicate models for weight sharing",
    "Expand the sub-models",
    "console.info(JSON.parse(e.target.result))",
    "default, draw the model.json file",
    "window.onload = () => {",
    "d3.json(filePath, (error, json) => {",
    "if (error) throw error;",
    "// console.info(json)",
    "draw(json)",
    "})",
    "}",
    "generate dag",
    "IR model or keras model",
    "path generator",
    "let arrowL = `M ${points[len - 1].x} ${points[len - 1].y} l -7 -7`",
    "let arrowR = `M ${points[len - 1].x} ${points[len - 1].y} l  7 -7`",
    "select a layer",
    "draw",
    "let scale = Math.min(window.innerWidth*0.85 / width, (window.innerHeight-85)/height)",
    "var filter = def.append(\"filter\")",
    ".attr(\"id\", \"dropshadow\")",
    "filter.append(\"feGaussianBlur\")",
    ".attr(\"in\", \"SourceAlpha\")",
    ".attr(\"stdDeviation\", 4)",
    ".attr(\"result\", \"blur\");",
    "// filter.append(\"feOffset\")",
    "//     .attr(\"in\", \"blur\")",
    "//     .attr(\"dx\", 2)",
    "//     .attr(\"dy\", 2)",
    "//     .attr(\"result\", \"offsetBlur\");",
    "var feMerge = filter.append(\"feMerge\");",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"offsetBlur\")",
    "feMerge.append(\"feMergeNode\")",
    ".attr(\"in\", \"SourceGraphic\");",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "svg.on('keydown', ()=>{console.info('ddd')})",
    ".on('mouseover', ()=>{console.info('mouse over')})",
    "limit x, y",
    "a trick to make text svg transform in MS Edge",
    "when shift is down",
    "ulti function",
    ".attr('rx', nodeH / 5)",
    ".attr('ry', nodeH / 5)",
    "space = ''"
  ]
}