{
  "Release-3.2.0": [
    "Long type node id",
    "TODO: support String, Int, and Any type node id",
    "@maxIndex: this variable contains the max index of node/word",
    "some params",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "get nodeId",
    "get  data the nodeId mapped 1.neighbors 2.tags 3.attrs",
    "write out edges",
    "write out tags",
    "write out attrs",
    "Get node neighbor number",
    "start sampling by alias table for count times",
    "Long type node id",
    "Get node neighbor number",
    "start sampling by alias table for count times",
    "int index = Math.abs(r.nextInt()) % nodeNeighbors.length;",
    "float ac = Math.abs(r.nextFloat());",
    "Get matrix meta",
    "Split",
    "Generate Part psf get param",
    "Get nodes and features",
    "return null;",
    "compress the neighbor IDs",
    "write out edges",
    "write out tags",
    "Get node neighbors",
    "Get nodes and features",
    "Get nodes and features",
    "Get nodes and features",
    "Get matrix meta",
    "Split",
    "Generate Part psf get param",
    "Get nodes and features",
    "Long type node id",
    "Get data",
    "Get matrix meta",
    "Split",
    "Generate Part psf get param",
    "Get matrix meta",
    "Split",
    "Generate Part psf get param",
    "Just return original features",
    "Use by line with weight",
    "get nodeId",
    "get  data the nodeId mapped 1.neighbors 2.tags 3.attrs",
    "write out edges",
    "write out tags",
    "write out attrs",
    "clear();",
    "evict entry with the smallest degree",
    "// calculate bias",
    "if (param.getPartKey().getStartCol() <= 0 && param.getPartKey().getEndCol() > 0) {",
    "double zVal = VectorUtils.getDouble(z, 0);",
    "double nVal = VectorUtils.getDouble(n, 0);",
    "VectorUtils.setFloat(w, 0, (float) (-1.0 * alpha * zVal / (beta + Math.sqrt(nVal))));",
    "}",
    "Do nothing.",
    "split updates",
    "shuffle update splits",
    "generate part update splits",
    "set split context: partition key, use int key for long key vector or net",
    "how to do intersection for two dense vector with a given indices ??",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "if not -1, sufficient space will be allocated at once",
    "InstanceRow ins = instanceRows[insId];",
    "int[] indices = ins.indices();",
    "int[] bins = ins.bins();",
    "int nnz = indices.length;",
    "for (int j = 0; j < nnz; j++) {",
    "int fid = indices[j];",
    "if (isFeatUsed[fid - featLo]) {",
    "histograms[fid - featLo].accumulate(bins[j], gradPairs[insId]);",
    "}",
    "}",
    "1. allocate histogram",
    "2. loop non-zero instances, accumulate to histogram",
    "if (nnz <= nodeEnd - nodeStart + 1) { // loop all nnz of current feature",
    "3. add remaining grad and hess to default bin",
    "return param.calcWeights(grad, hess);",
    "numClass is usually small, so we do not use arraycopy here",
    "numClass is usually small, so we do not use arraycopy here",
    "TODO: use more schema on default bin",
    "1. set default bin to left child",
    "2. for other bins, find its location",
    "3. create split set",
    "this.nodeStats = new GBTNodeStat[numClass == 2 ? 1 : numClass];",
    "predict sparse instance with indices and values",
    "predict libsvm data",
    "Preconditions.checkArgument(preds.length == labels.length,",
    "\"LogLossMetric should be used for binary-label classification\");",
    "double loss = 0.0;",
    "for (int i = 0; i < preds.length; i++) {",
    "loss += evalOne(preds[i], labels[i]);",
    "}",
    "return loss / labels.length;",
    "double error = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "error += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "error += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return error / labels.length;",
    "Preconditions.checkArgument(preds.length != labels.length",
    "&& preds.length % labels.length == 0,",
    "\"CrossEntropyMetric should be used for multi-label classification\");",
    "double loss = 0.0;",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "loss += evalOne(pred, labels[i]);",
    "}",
    "return loss / labels.length;",
    "double correct = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "correct += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "correct += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return (float) (correct / labels.length);",
    "double errSum = 0.0f;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "errSum += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "errSum += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return Math.sqrt(errSum / labels.length);",
    "System.out.println(\"----------\");",
    "System.out.println(\"read buffer = \" + Integer.toBinaryString(readBufferT & 0b11111111)",
    "+ \", mask = \" + Integer.toBinaryString(readMaskT));",
    "readMaskT <<= 1;",
    "boolean[] bits = new boolean[]{true, true, false, false, true, false, false, false, true, true, false, true};",
    "int n = bits.length;",
    "BufferedBitSet writeBitSet = new BufferedBitSet(n);",
    "BufferedBitSet readBitSet = new BufferedBitSet(writeBitSet.getBytes(), n);",
    "if (bitSet.get(i) != bits[i]) {",
    "throw new RuntimeException(\"\" + i);",
    "}",
    "private final ByteBuffer bytes;",
    "public BufferedBitSetReader(ByteBuffer bytes, int numBits) {",
    "int capacity = bytes.capacity() * 8;",
    "readIndexT = bytes.capacity() - 1;",
    "return bytes.get(index);",
    "TODO: use arraycopy to make it faster",
    "assert from >= this.from && to <= this.to;",
    "LOG.debug(String.format(\"Create subset: [%d-%d]\", newFrom, newTo));",
    "LOG.debug(String.format(\"Get overlap: [%d-%d]\", newFrom, newTo));",
    "return bits.clone();",
    "private final SerializableBuffer bytes;",
    "private final ByteBuffer bytes;",
    "this.bytes = ByteBuffer.allocate(numBytes);",
    "public BufferedBitSetWriter(ByteBuffer bytes) {",
    "this.bytes = bytes;",
    "}",
    "bytes.put(writeIndex++, (byte) writeBuffer);",
    "public ByteBuffer getBytes() {",
    "return bytes;",
    "}",
    "ML TreeConf",
    "GBDT TreeConf",
    "edges=[x,...] firstFlow=1 => go to right if < x and go to left if > x",
    "edges=[x,...] firstFlow=0 => go to left if < x and go to right if > x",
    "different types of tree node splits, enumerated by their complexity",
    "in order to reduce model size, we give priority to split point",
    "comparison between two split points, we give priority to lower feature index",
    "TODO: comparison between two split sets",
    "public boolean leafwise;  // true if leaf-wise training, false if level-wise training",
    "TODO: regularization",
    "TODO: regularization",
    "public float insSampleRatio;  // subsample ratio for instances",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighbor;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighborParam;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighborResult;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.initneighbor.InitNeighbor;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.initneighbor.InitNeighborParam;",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "@Test",
    "public void testInitAndGet() throws ExecutionException, InterruptedException {",
    "Worker worker = LocalClusterContext.get().getWorker(worker0Attempt0Id).getWorker();",
    "MatrixClient client1 = worker.getPSAgent().getMatrixClient(\"w2\", 0);",
    "int matrixW1Id = client1.getMatrixId();",
    "// Generate graph data",
    "Map<Integer, int []> adjMap = generateAdjTable(nodeNum, maxNeighborNum);",
    "",
    "// Init graph adj table",
    "InitNeighbor func = new InitNeighbor(new InitNeighborParam(matrixW1Id, adjMap));",
    "client1.update(func);",
    "",
    "int [] nodeIds = new int[adjMap.size()];",
    "int i = 0;",
    "for(int nodeId : adjMap.keySet()) {",
    "nodeIds[i++] = nodeId;",
    "}",
    "",
    "// Get graph adj table from PS",
    "GetNeighbor getFunc = new GetNeighbor(new GetNeighborParam(matrixW1Id, nodeIds, maxNeighborNum));",
    "Map<Integer, int[]> getResults = ((GetNeighborResult) (client1.get(getFunc)))",
    ".getNodeIdToNeighborIndices();",
    "",
    "// Check the result",
    "for(Entry<Integer, int[]> entry : getResults.entrySet()) {",
    "Assert.assertArrayEquals(entry.getValue(), adjMap.get(entry.getKey()));",
    "}",
    "}",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "QSLRRunner runner = new QSLRRunner();",
    "runner.train(conf);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Dataset",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Softmax algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DeepFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Model type",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "conf.set(MLConf.ML_EMBEDDING_MATRIX_OUTPUT_FORMAT(),\"TextColumnFormat\");",
    "System.out.println(\"-------------\");",
    "System.out.println(predictInput);",
    "System.out.println(LOCAL_FS + TMP_PATH + \"/predict/kmeans\");",
    "System.out.println(\"-------------\");",
    "Set angel resource, #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "conf.setBoolean(MLConf.KMEANS_SILHOUETTE_FLAG(),true);",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set WideAndDeep algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Set LDA parameters #V, #K",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set LDA algorithm parameters",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set SVM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "partitioner.init(mMatrix, conf);",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense long matrix",
    "add sparse long matrix",
    "add sparse long-key double matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add sparse double matrix",
    "add sparse float matrix",
    "add sparse float matrix",
    "add sparse long matrix",
    "add sparse long-key double matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense long matrix",
    "add sparse long matrix",
    "add sparse long-key double matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense long matrix",
    "add sparse long matrix",
    "add sparse long-key float matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense long matrix",
    "add sparse long matrix",
    "add sparse long-key double matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add sparse double matrix",
    "add sparse float matrix",
    "add sparse float matrix",
    "add sparse long matrix",
    "add sparse long-key double matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add sparse double matrix",
    "add sparse float matrix",
    "add sparse float matrix",
    "add sparse long matrix",
    "add sparse long-key float matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntFloatVector row = (IntFloatVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntFloatVector row = (IntFloatVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntLongVector row = (IntLongVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add sparse double matrix",
    "add sparse float matrix",
    "add sparse float matrix",
    "add sparse long matrix",
    "add sparse long-key double matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense long matrix",
    "add sparse long matrix",
    "add sparse long-key float matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntFloatVector row = (IntFloatVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntFloatVector row = (IntFloatVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntLongVector row = (IntLongVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add sparse double matrix",
    "add sparse float matrix",
    "add sparse float matrix",
    "add sparse long matrix",
    "add sparse long-key double matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add sparse double matrix",
    "add sparse float matrix",
    "add sparse float matrix",
    "add sparse long matrix",
    "add sparse long-key double matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense long matrix",
    "add sparse long matrix",
    "add sparse long-key double matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add dense long matrix",
    "add sparse long matrix",
    "add sparse long-key double matrix",
    "add sparse long-key float matrix",
    "add sparse long-key int matrix",
    "add sparse long-key long matrix",
    "Start PS",
    "Start to run application",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "assertTrue(psAgentContext.getOpLogCache() != null);",
    "ConsistencyController consistControl = psAgent.getConsistencyController();",
    "assertTrue(consistControl != null);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "https://blog.csdn.net/cocoonyang/article/details/63068108",
    "v1[i] = v1[i] + da * v2[i];",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "v1[i] = v1[i] + da * v2[i];",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "all the files in input set",
    "Shuffle the file",
    "Get the blocks for all files",
    "Adjust the maxSize to make the split more balanced",
    "Handle the splittable files",
    "Handle the unsplittable files",
    "Split the blocks",
    "If the remaining size of the current block is smaller than the required size,",
    "the remaining blocks are divided into the current split",
    "Update current split length and move to next block",
    "Clear the current block offset",
    "Current split length is > maxSize, split the block and generate a new split",
    "Clear blocks list for next split",
    "Clear the current split length",
    "If splitBlocks is not empty, just genetate a split for it",
    "get block locations from file system",
    "create an input split",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "Check is there save request",
    "LOG.info(\"PS \" + psAttemptId + \" need save \" + subSaveContext);",
    "Check is there load request",
    "LOG.info(\"PS \" + psAttemptId + \" need load \" + subLoadContext);",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "LOG.info(\"error happened in psAttempt \" + psAttemptId + \" error msg=\" + request.getMsg());",
    "remove this parameter server attempt from monitor set",
    "LOG.info(\"Epoch=\" + epoch + \" Metrics=\" + metrics);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Path tmpPath = new Path(new Path(context.getConf().get(AngelConf.ANGEL_JOB_TMP_OUTPUT_PATH)),",
    "String.valueOf(requestId));",
    "Path tmpPath = HdfsUtil.toTmpPath(new Path(saveContext.getSavePath()));",
    "saveContext.setTmpSavePath(tmpPath.toString());",
    "Filter old epoch trigger first",
    "Split the user request to sub-requests to pss",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Split the user request to sub-requests to pss",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Old parameter name",
    "Parallel GC parameters",
    "G1 params",
    "Parallel Scavenge + Parallel Old",
    "G1",
    ".append(\" -XX:G1NewSizePercent=\").append(minNewRatio)",
    ".append(\" -XX:G1MaxNewSizePercent=\").append(maxNewRatio)",
    "CMS",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "G1 params",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "restartPS(psLoc);",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and EXECUTE_SUCCESSED, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run or run over",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "todo",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnException or YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Add one sync matrix",
    "addSyncMatrix();",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "matrixContext.set(MatrixConf.MATRIX_LOAD_PATH, \"\");",
    "for(Entry<ParameterServerId, Map<Integer, MatrixMeta>> psEntry : matrixPartitionsOnPS.entrySet()) {",
    "LOG.info(\"ps id = \" + psEntry.getKey());",
    "Map<Integer, MatrixMeta> matrixIdToMetaMap = psEntry.getValue();",
    "for(Entry<Integer, MatrixMeta> metaEntry : matrixIdToMetaMap.entrySet()) {",
    "LOG.info(\"matrix id = \" + metaEntry.getKey());",
    "LOG.info(\"matrix partitons number = \" + metaEntry.getValue().getPartitionMetas().size());",
    "}",
    "}",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "private volatile MatrixOpLogCache opLogCache;",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "clockCache = new ClockCache();",
    "opLogCache = new MatrixOpLogCache();",
    "int staleness = conf.getInt(AngelConf.ANGEL_STALENESS, AngelConf.DEFAULT_ANGEL_STALENESS);",
    "consistencyController = new ConsistencyController(staleness);",
    "consistencyController.init();",
    "Start all services",
    "clockCache.start();",
    "opLogCache.start();",
    "Stop all modules",
    "Stop all modules",
    "public MatrixOpLogCache getOpLogCache() {",
    "return opLogCache;",
    "}",
    "clock first",
    "if (cache.getClock(matrixId, pkeys.get(0)) < clock) {",
    "}",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Plus a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Update a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get values from pss use row/column indices",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ PSF get/update, use can implement their own psf",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get a row or a batch of rows",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Just return",
    "Just return",
    "Just return",
    "Just return",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "return PSAgentContext.get().getMatrixOpLogCache().flush(taskContext, matrixId);",
    "return PSAgentContext.get().getConsistencyController().clock(taskContext, matrixId, flushFirst);",
    "this.partClockCache = partClockCache;",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "Future<VoidResult> flushFuture = adapter",
    ".flush(message.getMatrixId(), message.getContext(), matrixOpLog,",
    "message.getType() == OpLogMessageType.CLOCK);",
    "VoidResult result = flushFuture.get();",
    "((FutureResult<VoidResult>) messageToFutureMap.remove(message)).set(result);",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "Doing average or not",
    "Filter un-important update",
    "Split this row according the matrix partitions",
    "Set split context",
    "Remove the row from matrix",
    "buf.writeDouble(0.0);",
    "TODO:",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Init response handler",
    "Init network parameters",
    "Use Epoll for linux",
    "Request header",
    "Request body",
    "Request",
    "Send the request",
    "Request header",
    "Request body",
    "Request",
    "Send the request",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "getPSState(entry.getKey());",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "Check need retry or not",
    "Clear the cache for this request",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "LOG.info(\"Send request \" + request.getHeader());",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "request.getContext().setChannelPool(pool);",
    "Allocate the bytebuf and serialize the request",
    "Parse response",
    "LOG.info(\"ResponseHeader=\" + header);",
    "Get Request",
    "TODO: for LDA, will be remove future",
    "Update Server state",
    "LOG.info(\"Handle request \" + request.getHeader() + \", response \" + response.getHeader());",
    "Get user request and result cache",
    "LOG.info(\"userRequest=\" + userRequest + \", responseCache=\" + responseCache + \", futureResult=\" + futureResult);",
    "Some error happens, just return",
    "LOG.info(\"responseCache \" + responseCache.getExpectedResponseNum());",
    "Get response handler",
    "Add the response to the cache",
    "Check can merge or not",
    "Merge",
    "Clear response cache",
    "Remove the response cache",
    "Handle success",
    "Server is busy now, retry",
    "Server is not ready, retry",
    "Handle failed, just return error",
    "Parse response msg failed",
    "Merge the sub-response",
    "Set matrix/row information",
    "Set result",
    "Merge",
    "Set final result",
    "Check update result",
    "Set the final result",
    "Merge",
    "Set matrix/row meta",
    "Set final result",
    "Just",
    "Check update result",
    "Set the final result",
    "Get matrix meta",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Int key Double value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Int key Float value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Int key Long value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Int key Int value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Long key Double value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Long key Float value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Long key Int value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Long key Long value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "Merge the sub-response",
    "Set the result",
    "Adaptor to Get PSF merge",
    "Merge the sub-results",
    "Split the user request to partition requests",
    "filter empty partition requests",
    "Create partition results cache",
    "Send all the partition requests",
    "Request header",
    "Request body",
    "Request",
    "Send the request",
    "Only support column-partitioned matrix now!!",
    "Split the user request to partition requests",
    "filter empty partition requests",
    "Create partition results cache",
    "Request header",
    "Request body",
    "Request",
    "Send the request",
    "Split param use matrix partitons",
    "Request header",
    "Request body",
    "Request",
    "Send the request",
    "Get partitions for this row",
    "Request header",
    "Request body",
    "Request",
    "Send the request",
    "Get partitions for this row",
    "Request header",
    "Request body",
    "Request",
    "Send the request",
    "Split the param use matrix partitions",
    "Send request to PSS",
    "Request header",
    "Request body",
    "Request",
    "Send the request",
    "Request header",
    "Request body",
    "Request",
    "Send the request",
    "Get matrix meta",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Int key Double value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Int key Float value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Int key Long value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Int key Int value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Long key Double value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Long key Float value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Long key Int value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "//////////////////////////////////////////////////////////////////////////////",
    "Combine Long key Long value vector",
    "//////////////////////////////////////////////////////////////////////////////",
    "Need not call super.serialize",
    "Valid sub data part number",
    "Just use for stream model",
    "Need not call super.serialize",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Keys split",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Keys and values split: int/long/string/object key, float value",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Keys and values split: int/long/string/object key, double value",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Keys and values split: int/long/string/object key, long value",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Keys and values split: int/long/string/object key, object value",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Keys and values split: vector",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////",
    "keys split: range split only support int/long key",
    "///////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////",
    "keys/values pair split: int key, float/double/int/long/any values",
    "///////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////",
    "keys/values pair split: long key, float/double/int/long/any values",
    "///////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////",
    "values pair split: float/double/int/long/any values",
    "///////////////////////////////////////////////////////////////////////////////////////",
    "Get keys and values",
    "Get values",
    "Key and value array pair",
    "Get keys and values",
    "Get values",
    "Key and value array pair",
    "Get keys and values",
    "Get values",
    "Key and value array pair",
    "Get keys and values",
    "Get values",
    "Key and value array pair",
    "Get keys and values",
    "Key and value array pair",
    "Get keys and values",
    "Key and value array pair",
    "Get keys and values",
    "Key and value array pair",
    "Get keys and values",
    "Key and value array pair",
    "IElement class name",
    "IElement class name",
    "IElement class name",
    "IElement class name",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "Use comp key value part",
    "Split each vector",
    "Combine sub data part",
    "Use iterator",
    "Get values",
    "Key and value array pair",
    "Use iterator",
    "Get values",
    "Key and value array pair",
    "Use iterator",
    "Get values",
    "Key and value array pair",
    "Use iterator",
    "Get values",
    "Key and value array pair",
    "Use iterator",
    "Get values",
    "Key and value array pair",
    "Use iterator",
    "Get values",
    "Key and value array pair",
    "Use iterator",
    "Get values",
    "Key and value array pair",
    "Use iterator",
    "Get values",
    "Key and value array pair",
    "Use iterator",
    "Key and value array pair",
    "Use iterator",
    "Key and value array pair",
    "Use iterator",
    "Key and value array pair",
    "Use iterator",
    "Key and value array pair",
    "Use iterator",
    "Key and value array pair",
    "Use iterator",
    "Key and value array pair",
    "Use iterator",
    "Key and value array pair",
    "Use iterator",
    "Key and value array pair",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "It is recommended not to call this method on the client",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "Read matrix meta from meta file",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "matrix.startServering();",
    "return;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Read matrix meta from meta file",
    "Sort partitions",
    "TODO:",
    "int size = rows.length;",
    "int size = rows.length;",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "return Objects.toStringHelper(this).add(\"serial\", serial).add(\"listSize\", datas.size())",
    ".toString();",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load ml conf file for graph based algorithm",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "If out path exist , just remove it first",
    "Create parent directory if not exist",
    "Rename",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "Release the input buffer",
    "If is stream response, just return bytebuf",
    "Reset the response and allocate buffer again",
    "Release response data",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "for (int i = 0; i < indices.length; i++) {",
    "System.out.println(\"\" + i + \", index = \" + indices[i] + \", value = \" + values[i]);",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "throw new AngelException(e);",
    "JobStateProto jobState = report.getJobState();",
    "Check need load matrices",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "load user job resource files",
    "setLocalAddr();",
    "2.get job id",
    "5.write configuration to a xml file",
    "8.get app master client",
    "Write job file to JobTracker's fs",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "private volatile PS2PSPusherImpl ps2PSPusher;",
    "TODO",
    "Add tokens to new user so that it may execute its task correctly.",
    "to exit",
    "calculate data size of all partitions of ps",
    "totalRPC",
    "request size",
    "data size",
    "Recover PS from snapshot or load path",
    "1. First check old snapshot",
    "2. Check new checkpoints",
    "3. Check load path setting and old save result",
    "Just init it again",
    "TODO",
    "if(ps2PSPusher != null) {",
    "ps2PSPusher.start();",
    "}",
    "public PS2PSPusherImpl getPs2PSPusher() {",
    "return ps2PSPusher;",
    "}",
    "Deserialize head",
    "Get method type",
    "Check method",
    "Check if data request",
    "Use async handler or not",
    "Get and init the queue",
    "LOG.info(\"Request header = \" + requestHeader);",
    "Idle, handle the request",
    "Parse head success",
    "Handle request",
    "Handle error, generate response",
    "Release the input buffer",
    "Create response",
    "LOG.info(\"Response header = \" + responseHeader);",
    "Serialize the response",
    "2. Serialize the response",
    "Send the serialized response",
    "int maxRPCCounter = Math.max(estSize, (int) (workerNum * factor));",
    "for (Map.Entry<Integer, ClientRunningContext> clientEntry : clientRPCCounters.entrySet()) {",
    "LOG.info(\"client \" + clientEntry.getKey() + \" running context:\");",
    "clientEntry.getValue().printToken();",
    "}",
    "return ServerState.GENERAL;",
    "Use Epoll for linux",
    "Read router type",
    "Key type",
    "Row id",
    "Key number",
    "Calculate final output buffer len",
    "Response header",
    "Data flag",
    "Value type",
    "Row id",
    "Size",
    "Data",
    "Allocate result buffer",
    "Header",
    "Serialize Value part head",
    "response.setOutputBuffer(resultBuf);",
    "Read router type",
    "Key type",
    "Row id",
    "Key number",
    "Calculate final output buffer len",
    "Response header",
    "Data flag",
    "Value type",
    "Row id",
    "Size",
    "Data",
    "Allocate final result byte buffer",
    "Write response header",
    "Data",
    "Value part flag",
    "Value type",
    "Row id",
    "Values number",
    "Result data",
    "Filter comp key value",
    "LOG.info(\"Get PSF func = \" + func.getClass().getName());",
    "Data is not de-serialized first",
    "public void setChannelPool(GenericObjectPool<Channel> channelPool) {",
    "this.channelPool = channelPool;",
    "}",
    "private final ParameterServer psServer;",
    "Create and start workers",
    "Set workers",
    "Create and start workers",
    "Set workers",
    "If matrix checkpoint path not exist, just return null",
    "Return the path with maximum checkpoint id",
    "Rename temp to item path",
    "Checkpoint base path = Base dir/matrix name",
    "Path for this checkpoint",
    "Generate tmp path",
    "Delete old checkpoints",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// network io method, for model transform",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Serailize the head",
    "Serialize the storage",
    "Deserailze the head",
    "Deseralize the storage",
    "Serailize the head",
    "Serialize the storage",
    "Deserailze the head",
    "Deseralize the storage",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Notice: Basic type ServerRow only support Vector as inner storage now, so you can use methods",
    "to get inner vector for basic type ServerRow.",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Index is int",
    "Index is long",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Attention: Only update exist element",
    "Attention: Only update exist element",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Attention: Only update exist element",
    "TODO: just check the value is 0 or not now",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "Use sparse storage method, as some elements in the array maybe null",
    "Array length",
    "Valid element number",
    "Element data",
    "Array len",
    "Valid element number",
    "Use sparse storage method, as some elements in the array maybe null",
    "Array length",
    "Valid element number",
    "Element data",
    "Element data",
    "Array len",
    "Valid element number",
    "Attention: Only update exist element",
    "Row type",
    "Storage method",
    "Key type",
    "Value type",
    "Vector dim",
    "Vector length",
    "Vector data",
    "Row type",
    "Storage method",
    "Key type",
    "Value type",
    "Vector dim",
    "Vector length",
    "Init the vector",
    "Vector data",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "private final List<PartitionKey> partitionKeys;",
    "Get server partition class",
    "If partition class is not set, just use the default partition class",
    "Get server partition storage class type",
    "Get value class",
    "Partition number use set",
    "Use total partition number if set",
    "Use partition number per server",
    "if col == -1, we use the start/end index to calculate range,",
    "we use double to store the range value since two long minus might exceed the",
    "range of long.",
    "partitioner.init(matrix1, conf);",
    "Serialize the head",
    "Serialize the storage",
    "Deserialize the head",
    "Deseralize the storage",
    "Serialize the head",
    "Serialize the storage",
    "Deserialize the head",
    "Deseralize the storage",
    "Row base partition",
    "If storage class is not set, use default DenseServerRowsStorage",
    "Serialize values",
    "Deserialize values",
    "Filter head",
    "Array size",
    "Actual write size",
    "Rows data",
    "Row id",
    "Row type",
    "Row data",
    "Array size",
    "Actual write row number",
    "Rows data",
    "Row id",
    "Create empty server row",
    "Row data",
    "Rows data",
    "Rows data",
    "TODO",
    "Serialize row offsets",
    "Serialize column offsets",
    "Deserialize row offset",
    "Deserialize row offset",
    "If storage is set, just get a instance",
    "If storage is not set, use default",
    "If storage is set, just get a instance",
    "If storage is not set, use default",
    "Map size",
    "Actual write size",
    "Rows data",
    "Row id",
    "Row type",
    "Row data",
    "Array size",
    "Actual write row number",
    "Rows data",
    "Row id",
    "Create empty server row",
    "Row data",
    "Rows data",
    "Rows data",
    "=======================================================",
    "Boolean",
    "=======================================================",
    "Byte",
    "=======================================================",
    "Int",
    "=======================================================",
    "Int",
    "=======================================================",
    "Long",
    "=======================================================",
    "Float",
    "=======================================================",
    "String",
    "=======================================================",
    "Double",
    "=======================================================",
    "Byte array",
    "=======================================================",
    "Int array",
    "=======================================================",
    "Long array",
    "=======================================================",
    "Float array",
    "=======================================================",
    "Double array",
    "=======================================================",
    "String array",
    "=======================================================",
    "2-D Int array",
    "=======================================================",
    "2-D Long array",
    "=======================================================",
    "2-D Float array",
    "=======================================================",
    "2-D Double array",
    "=======================================================",
    "Vector",
    "Meta data",
    "TODO: other vector type",
    "TODO: other vector type",
    "TODO: other vector type",
    "IntDoubleVector",
    "IntFloatVector",
    "IntFloatVector array",
    "serializeInt(out, vector.getType().getNumber()); // no need to record type",
    "RowType type = RowType.valueOf(deserializeInt(in));",
    "LongFloatVector",
    "LongFloatVector array",
    "serializeInt(out, vector.getType().getNumber()); // no need to record type",
    "RowType type = RowType.valueOf(deserializeInt(in));",
    "LongFloatVector",
    "LongFloatVector array",
    "serializeInt(out, vector.getType().getNumber()); // no need to record type",
    "RowType type = RowType.valueOf(deserializeInt(in));",
    "////////////////////////////////////////////////////////////////////////////",
    "=======================================================",
    "Boolean",
    "=======================================================",
    "Byte",
    "=======================================================",
    "Int",
    "=======================================================",
    "Int",
    "=======================================================",
    "Long",
    "=======================================================",
    "Float",
    "=======================================================",
    "String",
    "=======================================================",
    "Double",
    "=======================================================",
    "Byte array",
    "=======================================================",
    "Int array",
    "=======================================================",
    "Long array",
    "=======================================================",
    "Float array",
    "=======================================================",
    "Double array",
    "=======================================================",
    "String array",
    "=======================================================",
    "2-D Int array",
    "=======================================================",
    "2-D Long array",
    "=======================================================",
    "2-D Float array",
    "=======================================================",
    "2-D Double array",
    "=======================================================",
    "Vector",
    "Meta data",
    "TODO: other vector type",
    "TODO: other vector type",
    "TODO: other vector type",
    "IntDoubleVector",
    "IntFloatVector",
    "IntFloatVector array",
    "serializeInt(out, vector.getType().getNumber()); // no need to record type",
    "RowType type = RowType.valueOf(deserializeInt(in));",
    "LongFloatVector",
    "LongFloatVector array",
    "serializeInt(out, vector.getType().getNumber()); // no need to record type",
    "RowType type = RowType.valueOf(deserializeInt(in));",
    "LongFloatVector",
    "LongFloatVector array",
    "serializeInt(out, vector.getType().getNumber()); // no need to record type",
    "RowType type = RowType.valueOf(deserializeInt(in));",
    "First check the state of the channels in the pool, if a channel is unused, just return",
    "If all channels are in use, create a new channel or wait",
    "Create a new channel",
    "checker.start();",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "Keys and values",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "Keys",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "Keys",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "Keys",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "Keys",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "Keys",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "Key size",
    "Key class name",
    "Keys",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "Values",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "Keys",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "Keys",
    "[0, currentBatchIndex - 1] batchs",
    "Last batch",
    "add the PSAgentContext,need fix",
    "If col == -1 and start/end not set",
    "start/end set",
    "for dense type, we need to set the colNum to set dim for vectors",
    "colNum set, start/end not set",
    "Hash partition does not support dense type row",
    "Row number must > 0",
    "both set, check its valid",
    "Sort the partitions by start column index",
    "public static final int T_INT_ARBITRARY_VALUE = 28;",
    "public static final int T_INVALID_VALUE = 29;",
    "TODO:add more vector type",
    "TODO : subDim set",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Split updates",
    "Shuffle update splits",
    "Generate part update parameters",
    "Set split context: partition key, use int key for long key vector or not ect",
    "write the max abs",
    "---------------------------------------------------",
    "---------------------------------------------------",
    "---------------------------------------------------------------",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "KeepStorage is guaranteed",
    "we gauss dense storage is more efficient",
    "v1Size < v2Size * Constant.sparseThreshold",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss dense storage is more efficient",
    "prevent rehash",
    "KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "dense preferred",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sorted preferred",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "dger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "sger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "get configuration from envs",
    "get master location",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "add dense double matrix",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "public volatile static int colNum = 1000000;",
    "public volatile static int nnz = 10000;",
    "public volatile static int blockColNum = 20000;",
    "test the colNum is 1000000, 1 million",
    "rowNum = conf.getInt(\"row\", 1);",
    "colNum = conf.getInt(\"col\", 1000000);",
    "nnz = conf.getInt(\"nnz\", 10000);",
    "blockRowNum = conf.getInt(\"blockRow\", 1);",
    "blockColNum = conf.getInt(\"blockCol\", 20000);",
    "rowNum = conf.getInt(\"row\", 1);",
    "colNum = conf.getInt(\"col\", 10);",
    "nnz = conf.getInt(\"nnz\", 2);",
    "blockRowNum = conf.getInt(\"blockRow\", 1);",
    "blockColNum = conf.getInt(\"blockCol\", 10);",
    "add sparse longkey float matrix of 1 million",
    "MatrixContext dMat = new MatrixContext();",
    "dMat.setName(SPARSE_LONGKEY_FLOAT_MAT);",
    "dMat.setRowNum(rowNum);",
    "dMat.setColNum(colNum);",
    "dMat.setMaxRowNumInBlock(blockRowNum);",
    "dMat.setMaxColNumInBlock(blockColNum);",
    "dMat.setRowType(RowType.T_FLOAT_SPARSE_LONGKEY);",
    "dMat.set(MatrixConf.MATRIX_SAVE_PATH, conf.get(\"angel.save.model.path\"));",
    "angelClient.addMatrix(dMat);",
    "test the colNum is Long.MAX_VALUE",
    "add sparse longkey float matrix of Long.MAX_VALUE",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "true, false",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Kubernetes Configs.",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "Start PS",
    "Start to run application",
    "Init node neighbors",
    "client.asyncUpdate(new InitNeighborOver(new InitNeighborOverParam(matrixId))).get();",
    "Sample the neighbors",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setValidIndexNum(100);",
    "siMat.setColNum(10000000000L);",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "Start PS",
    "Start to run application",
    "Init node neighbors and feats",
    "Sample the neighbors",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "Start PS",
    "Start to run application",
    "Init node neighbors",
    "Sample the neighbors",
    "flags len for init value: 7*4",
    "Just return original features",
    "clear();",
    "Long type node id",
    "If node not exist, just skip",
    "TODO: support String, Int, and Any type node id",
    "Get matrix meta",
    "Long type node id",
    "If node not exist, just skip",
    "TODO: support String, Int, and Any type node id",
    "Long type node id",
    "If node not exist, just skip",
    "TODO: support String, Int, and Any type node id",
    "Long type node id",
    "If node not exist, just skip",
    "TODO: support String, Int, and Any type node id",
    "Get matrix meta",
    "Split",
    "Generate Part psf get param",
    "Long type node id",
    "If node not exist, just skip",
    "TODO: support String, Int, and Any type node id",
    "Long type node id",
    "If node not exist, just skip",
    "TODO: support String, Int, and Any type node id",
    "Long type node id",
    "If node not exist, just skip",
    "TODO: support String, Int, and Any type node id",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to",
    "the result array, the copy position is random",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to",
    "the result array, the copy position is random",
    "sample types",
    "Get node neighbor number",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to",
    "the result array, the copy position is random",
    "sample node types",
    "sample edge types",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to",
    "the result array, the copy position is random",
    "sample types",
    "Get matrix meta",
    "sample (count / partNum + 1) in every partition randomly",
    "Generate rpc params",
    "Sample part result",
    "Neighbors",
    "Neighbors type",
    "Edge type",
    "Sample part result",
    "Neighbors",
    "Get matrix meta",
    "Split nodeIds",
    "Generate node ids",
    "Get matrix meta",
    "Split nodeIds",
    "Generate rpc params",
    "Get matrix meta",
    "Split nodeIds",
    "Generate node ids",
    "Sample part result",
    "Neighbors",
    "EdgeFeatures",
    "Get matrix meta",
    "Split nodeIds",
    "Generate rpc params",
    "Get node ids and features",
    "Get nodes and features",
    "Get nodes and features",
    "sample continuously beginning from a random index",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "int matrixId, PartitionKey partKey, long[] keyIds, int startIdx, int endIdx",
    "clear();",
    "int completeCount = 0;",
    "ArrayList<WalkPath> paths = new ArrayList<>(pathTail.size());",
    "",
    "row.startWrite();",
    "try {",
    "ObjectIterator<Map.Entry<Long, Long>> iter = pathTail.entrySet().iterator();",
    "while (iter.hasNext()) {",
    "Map.Entry<Long, Long> entry = iter.next();",
    "long key = entry.getKey();",
    "long tail = entry.getValue();",
    "",
    "WalkPath wPath = (WalkPath) row.get(key);",
    "wPath.add2Path(tail);",
    "",
    "if (wPath.isComplete()) {",
    "completeCount += 1;",
    "} else {",
    "paths.add(wPath);",
    "}",
    "}",
    "} finally {",
    "row.endWrite();",
    "}",
    "",
    "if (completeCount != 0) {",
    "PathQueue.progress(partKey.getPartitionId(), completeCount);",
    "}",
    "",
    "if (!paths.isEmpty()) {",
    "PathQueue.pushBatch(partKey.getPartitionId(), paths);",
    "}",
    "System.out.println(Thread.currentThread().getId() + \"\\t serialize -> \" + ());",
    "clear();",
    "System.out.println(Thread.currentThread().getId() + \"\\t deserialize -> \" + size);",
    "Get node neighbor number",
    "If the neighbor number is 0, just return a int[0]",
    "If count <= 0 or the neighbor number is less or equal then count, just copy all neighbors to the result array",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "Store the total neighbor number of all nodes in rowOffsets",
    "Put the node ids, node neighbor number, node neighbors to the cache",
    "No data in this partition",
    "Get total neighbor number",
    "Final matrix column indices: neighbors node ids",
    "Write positions in cloumnIndices for nodes",
    "Copy all cached sub column indices to final column indices",
    "Read position for a sub column indices",
    "Copy column indices for a node to final column indices",
    "Update write position for this node in final column indices",
    "Update the read position in sub column indices",
    "Clear all temp data",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "sample happens here to avoid memory copy on servers",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Set training data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model type",
    "String modelType = String.valueOf(RowType.T_FLOAT_DENSE);",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.set(MLConf.ML_MODEL_TYPE(), modelType);",
    "conf.setDouble(MLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "predictTest();",
    "Data format, libsvm or dummy",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set data format",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set log path",
    "Set trainning data path",
    "Set save model path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set training data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log save path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set testing data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "loss delta",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "TODO: optimize int key indices",
    "System.out.println(\"deserialize cols.length=\" + nCols);",
    "System.out.print(\"deserialize \");",
    "System.out.print(cols[c] + \" \");",
    "System.out.println();",
    "TODO Auto-generated method stub",
    "LOG.info(\"original float length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"original double length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"parsed float length: \" + length + Arrays.toString(arr));",
    "LOG.info(\"parsed double length: \" + length + Arrays.toString(arr));",
    "ground truth: positive, precision: positive",
    "start row index for words",
    "start row index for docs",
    "doc ids",
    "topic assignments",
    "word to docs reverse index",
    "count word",
    "build word start index",
    "build word to doc reverse idx",
    "build dks",
    "dks = new TraverseHashMap[n_docs];",
    "for (int d = 0; d < n_docs; d++) {",
    "if (K < Short.MAX_VALUE) {",
    "if (docs.get(d).len < Byte.MAX_VALUE)",
    "dks[d] = new S2BTraverseMap(docs.get(d).len);",
    "if (docs.get(d).len < Short.MAX_VALUE)",
    "dks[d] = new S2STraverseMap(Math.min(K, docs.get(d).len));",
    "else",
    "dks[d] = new S2ITraverseMap(Math.min(K, docs.get(d).len));",
    "} else {",
    "dks[d] = new I2ITranverseMap(Math.min(K, docs.get(d).len));",
    "}",
    "}",
    "build dks",
    "allocate update maps",
    "Skip if no token for this word",
    "Check whether error when fetching word-topic",
    "Build FTree for current word",
    "current doc",
    "old topic assignment",
    "Check if error happens. if this happen, it's probably that failures happen to servers.",
    "We need to adjust the memory settings or network fetching parameters.",
    "Update statistics if needed",
    "Calculate psum and sample new topic",
    "Update statistics if needed",
    "Assign new topic",
    "Skip if no token for this word",
    "if (u >= p[end]) {",
    "System.out.println(\"u=\" + u + \" p[end]=\" + p[end] + \" start=\" + start + \" end=\" + end);",
    "return end;",
    "}",
    "",
    "if (u < p[start]) {",
    "System.out.println(\"u=\" + u + \" p[start]=\" + p[start] + \" start=\" + start + \" end=\" + end);",
    "return start;",
    "}",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "dense",
    "sparse",
    "calculate columns",
    "reset(row);",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "node's end index in instancePos, instances in [start, end] belong to a tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "this.forest[this.currentTree].fset = sampleFeatureVector.getStorage().getValues();",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "1. decide nodes that should be calculated",
    "2. decide calculated and subtracted tree nodes",
    "3. calculate threads",
    "wait until all threads finish",
    "4. subtract threads",
    "wait until all threads finish",
    "5. send histograms to PS",
    "6. update histogram cache",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "this.phase = GBDTPhase.AFTER_SPLIT;",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "update local replica",
    "create AfterSplit task",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current depth",
    "finish current tree",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "1. update predictions of training data",
    "2. update predictions of validation data",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "if not -1, sufficient space will be allocated at once",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fSet, fid);",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "assert fvalue >= sketch[start] && fvalue <= sketch[end];",
    "if (left > end) return end - start;",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "max and min of each feature",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = (int) row.getStartCol();",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "v3.1.0": [
    "@maxIndex: this variable contains the max index of node/word",
    "some params",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "compress the neighbor IDs",
    "write out edges",
    "write out tags",
    "Get node neighbors",
    "Use by line with weight",
    "evict entry with the smallest degree",
    "// calculate bias",
    "if (param.getPartKey().getStartCol() <= 0 && param.getPartKey().getEndCol() > 0) {",
    "double zVal = VectorUtils.getDouble(z, 0);",
    "double nVal = VectorUtils.getDouble(n, 0);",
    "VectorUtils.setFloat(w, 0, (float) (-1.0 * alpha * zVal / (beta + Math.sqrt(nVal))));",
    "}",
    "Do nothing.",
    "split updates",
    "shuffle update splits",
    "generate part update splits",
    "set split context: partition key, use int key for long key vector or net",
    "how to do intersection for two dense vector with a given indices ??",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "if not -1, sufficient space will be allocated at once",
    "InstanceRow ins = instanceRows[insId];",
    "int[] indices = ins.indices();",
    "int[] bins = ins.bins();",
    "int nnz = indices.length;",
    "for (int j = 0; j < nnz; j++) {",
    "int fid = indices[j];",
    "if (isFeatUsed[fid - featLo]) {",
    "histograms[fid - featLo].accumulate(bins[j], gradPairs[insId]);",
    "}",
    "}",
    "1. allocate histogram",
    "2. loop non-zero instances, accumulate to histogram",
    "if (nnz <= nodeEnd - nodeStart + 1) { // loop all nnz of current feature",
    "3. add remaining grad and hess to default bin",
    "return param.calcWeights(grad, hess);",
    "numClass is usually small, so we do not use arraycopy here",
    "numClass is usually small, so we do not use arraycopy here",
    "TODO: use more schema on default bin",
    "1. set default bin to left child",
    "2. for other bins, find its location",
    "3. create split set",
    "this.nodeStats = new GBTNodeStat[numClass == 2 ? 1 : numClass];",
    "predict sparse instance with indices and values",
    "predict libsvm data",
    "Preconditions.checkArgument(preds.length == labels.length,",
    "\"LogLossMetric should be used for binary-label classification\");",
    "double loss = 0.0;",
    "for (int i = 0; i < preds.length; i++) {",
    "loss += evalOne(preds[i], labels[i]);",
    "}",
    "return loss / labels.length;",
    "double error = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "error += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "error += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return error / labels.length;",
    "Preconditions.checkArgument(preds.length != labels.length",
    "&& preds.length % labels.length == 0,",
    "\"CrossEntropyMetric should be used for multi-label classification\");",
    "double loss = 0.0;",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "loss += evalOne(pred, labels[i]);",
    "}",
    "return loss / labels.length;",
    "double correct = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "correct += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "correct += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return (float) (correct / labels.length);",
    "double errSum = 0.0f;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "errSum += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "errSum += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return Math.sqrt(errSum / labels.length);",
    "System.out.println(\"----------\");",
    "System.out.println(\"read buffer = \" + Integer.toBinaryString(readBufferT & 0b11111111)",
    "+ \", mask = \" + Integer.toBinaryString(readMaskT));",
    "readMaskT <<= 1;",
    "boolean[] bits = new boolean[]{true, true, false, false, true, false, false, false, true, true, false, true};",
    "int n = bits.length;",
    "BufferedBitSet writeBitSet = new BufferedBitSet(n);",
    "BufferedBitSet readBitSet = new BufferedBitSet(writeBitSet.getBytes(), n);",
    "if (bitSet.get(i) != bits[i]) {",
    "throw new RuntimeException(\"\" + i);",
    "}",
    "private final ByteBuffer bytes;",
    "public BufferedBitSetReader(ByteBuffer bytes, int numBits) {",
    "int capacity = bytes.capacity() * 8;",
    "readIndexT = bytes.capacity() - 1;",
    "return bytes.get(index);",
    "TODO: use arraycopy to make it faster",
    "assert from >= this.from && to <= this.to;",
    "LOG.debug(String.format(\"Create subset: [%d-%d]\", newFrom, newTo));",
    "LOG.debug(String.format(\"Get overlap: [%d-%d]\", newFrom, newTo));",
    "return bits.clone();",
    "private final SerializableBuffer bytes;",
    "private final ByteBuffer bytes;",
    "this.bytes = ByteBuffer.allocate(numBytes);",
    "public BufferedBitSetWriter(ByteBuffer bytes) {",
    "this.bytes = bytes;",
    "}",
    "bytes.put(writeIndex++, (byte) writeBuffer);",
    "public ByteBuffer getBytes() {",
    "return bytes;",
    "}",
    "ML TreeConf",
    "GBDT TreeConf",
    "edges=[x,...] firstFlow=1 => go to right if < x and go to left if > x",
    "edges=[x,...] firstFlow=0 => go to left if < x and go to right if > x",
    "different types of tree node splits, enumerated by their complexity",
    "in order to reduce model size, we give priority to split point",
    "comparison between two split points, we give priority to lower feature index",
    "TODO: comparison between two split sets",
    "public boolean leafwise;  // true if leaf-wise training, false if level-wise training",
    "TODO: regularization",
    "TODO: regularization",
    "public float insSampleRatio;  // subsample ratio for instances",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighbor;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighborParam;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighborResult;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.initneighbor.InitNeighbor;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.initneighbor.InitNeighborParam;",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "@Test",
    "public void testInitAndGet() throws ExecutionException, InterruptedException {",
    "Worker worker = LocalClusterContext.get().getWorker(worker0Attempt0Id).getWorker();",
    "MatrixClient client1 = worker.getPSAgent().getMatrixClient(\"w2\", 0);",
    "int matrixW1Id = client1.getMatrixId();",
    "// Generate graph data",
    "Map<Integer, int []> adjMap = generateAdjTable(nodeNum, maxNeighborNum);",
    "",
    "// Init graph adj table",
    "InitNeighbor func = new InitNeighbor(new InitNeighborParam(matrixW1Id, adjMap));",
    "client1.update(func);",
    "",
    "int [] nodeIds = new int[adjMap.size()];",
    "int i = 0;",
    "for(int nodeId : adjMap.keySet()) {",
    "nodeIds[i++] = nodeId;",
    "}",
    "",
    "// Get graph adj table from PS",
    "GetNeighbor getFunc = new GetNeighbor(new GetNeighborParam(matrixW1Id, nodeIds, maxNeighborNum));",
    "Map<Integer, int[]> getResults = ((GetNeighborResult) (client1.get(getFunc)))",
    ".getNodeIdToNeighborIndices();",
    "",
    "// Check the result",
    "for(Entry<Integer, int[]> entry : getResults.entrySet()) {",
    "Assert.assertArrayEquals(entry.getValue(), adjMap.get(entry.getKey()));",
    "}",
    "}",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "QSLRRunner runner = new QSLRRunner();",
    "runner.train(conf);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Dataset",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Softmax algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DeepFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Model type",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set WideAndDeep algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Set LDA parameters #V, #K",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set LDA algorithm parameters",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set SVM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "testSparseDoubleUDF();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "testSparseDoubleUDF();",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add comp dense double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "LOG.info(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntFloatVector row = (IntFloatVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntLongVector row = (IntLongVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setPartitionClass(CSRPartition.class);",
    "siMat.setPartitionStorageClass(IntCSRStorage.class);",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "MatrixContext siMat = new MatrixContext();",
    "siMat.setName(SPARSE_INT_MAT);",
    "siMat.setRowType(RowType.T_ANY_INTKEY_SPARSE);",
    "siMat.setRowNum(1);",
    "siMat.setValidIndexNum(100);",
    "siMat.setColNum(10000000000L);",
    "siMat.setValueType(Node.class);",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "angelClient.addMatrix(siMat);",
    "add sparse long-key double matrix",
    "Start PS",
    "Start to run application",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "https://blog.csdn.net/cocoonyang/article/details/63068108",
    "v1[i] = v1[i] + da * v2[i];",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "v1[i] = v1[i] + da * v2[i];",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "all the files in input set",
    "Shuffle the file",
    "Get the blocks for all files",
    "Adjust the maxSize to make the split more balanced",
    "Handle the splittable files",
    "Handle the unsplittable files",
    "Split the blocks",
    "If the remaining size of the current block is smaller than the required size,",
    "the remaining blocks are divided into the current split",
    "Update current split length and move to next block",
    "Clear the current block offset",
    "Current split length is > maxSize, split the block and generate a new split",
    "Clear blocks list for next split",
    "Clear the current split length",
    "If splitBlocks is not empty, just genetate a split for it",
    "get block locations from file system",
    "create an input split",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "k8sClusterManager = new KubernetesClusterManager(appContext);",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "Check is there save request",
    "LOG.info(\"PS \" + psAttemptId + \" need save \" + subSaveContext);",
    "Check is there load request",
    "LOG.info(\"PS \" + psAttemptId + \" need load \" + subLoadContext);",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "LOG.info(\"error happened in psAttempt \" + psAttemptId + \" error msg=\" + request.getMsg());",
    "remove this parameter server attempt from monitor set",
    "LOG.info(\"Epoch=\" + epoch + \" Metrics=\" + metrics);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Path tmpPath = new Path(new Path(context.getConf().get(AngelConf.ANGEL_JOB_TMP_OUTPUT_PATH)),",
    "String.valueOf(requestId));",
    "Path tmpPath = HdfsUtil.toTmpPath(new Path(saveContext.getSavePath()));",
    "saveContext.setTmpSavePath(tmpPath.toString());",
    "Filter old epoch trigger first",
    "Split the user request to sub-requests to pss",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Split the user request to sub-requests to pss",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Old parameter name",
    "Parallel GC parameters",
    "G1 params",
    "Parallel Scavenge + Parallel Old",
    "G1",
    ".append(\" -XX:G1NewSizePercent=\").append(minNewRatio)",
    ".append(\" -XX:G1MaxNewSizePercent=\").append(maxNewRatio)",
    "CMS",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "G1 params",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "restartPS(psLoc);",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and EXECUTE_SUCCESSED, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run or run over",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "todo",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnException or YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Add one sync matrix",
    "addSyncMatrix();",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "matrixContext.set(MatrixConf.MATRIX_LOAD_PATH, \"\");",
    "for(Entry<ParameterServerId, Map<Integer, MatrixMeta>> psEntry : matrixPartitionsOnPS.entrySet()) {",
    "LOG.info(\"ps id = \" + psEntry.getKey());",
    "Map<Integer, MatrixMeta> matrixIdToMetaMap = psEntry.getValue();",
    "for(Entry<Integer, MatrixMeta> metaEntry : matrixIdToMetaMap.entrySet()) {",
    "LOG.info(\"matrix id = \" + metaEntry.getKey());",
    "LOG.info(\"matrix partitons number = \" + metaEntry.getValue().getPartitionMetas().size());",
    "}",
    "}",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "clock first",
    "wait",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Plus a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Update a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get values from pss use row/column indices",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ PSF get/update, use can implement their own psf",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get a row or a batch of rows",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Just return",
    "Just return",
    "Just return",
    "Just return",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "Sort the partitions by start column index",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "Doing average or not",
    "Filter un-important update",
    "Split this row according the matrix partitions",
    "Set split context",
    "Remove the row from matrix",
    "buf.writeDouble(0.0);",
    "TODO:",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "LOG.error(\"put response message queue failed \", e);",
    "Use Epoll for linux",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "getPSState(entry.getKey());",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "private Channel getChannel(Location loc) throws Exception {",
    "return channelManager.getOrCreateChannel(new Location(loc.getIp(), loc.getPort() + 1));",
    "}",
    "private GenericObjectPool<Channel> getChannelPool(Location loc) throws InterruptedException {",
    "return channelManager.getOrCreateChannelPool(new Location(loc.getIp(), loc.getPort() + 1), PSAgentContext",
    ".get()",
    ".getConf()",
    ".getInt(AngelConf.ANGEL_WORKER_TASK_NUMBER,",
    "AngelConf.DEFAULT_ANGEL_WORKER_TASK_NUMBER));",
    "}",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "request.getContext().setChannelPool(pool);",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "updateMatrixCache(request.getPartKey(), response.getPartition());",
    "updateMatrixCache(request.getPartKey(), response.getRowsSplit());",
    "TODO",
    "ServerRow rowSplit = PSAgentContext.get().getMatricesCache()",
    ".getRowSplit(request.getPartKey().getMatrixId(), request.getPartKey(),",
    "request.getRowIndex());",
    "response.setRowSplit(rowSplit);",
    "updateMatrixCache(request.getPartKey(), response.getRowSplit());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "TODO",
    "private void updateMatrixCache(PartitionKey partKey, ServerPartition partition) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, partition);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, ServerRow rowSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowSplit);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, List<ServerRow> rowsSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowsSplit);",
    "}",
    "Get partitions for this row",
    "Distinct get row requests",
    "Get row splits of this row from the matrix cache first",
    "responseCache.addSubResponse(rowSplit);",
    "If the row split does not exist in cache, get it from parameter server",
    "Split the param use matrix partitions",
    "Send request to PSS",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Send request to PSS",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "LOG.info(\"get row split use time=\" + (System.currentTimeMillis() - startTs));",
    "LOG.info(\"start to request \" + requestId);",
    "LOG.info(\"start to request \" + requestId);",
    "Split param use matrix partitons",
    "If all sub-results are received, just remove request and result cache",
    "Split this row according the matrix partitions",
    "Set split context",
    "Split this row according the matrix partitions",
    "Set split context",
    "long startTs = System.currentTimeMillis();",
    "LOG.error(\"combine use time = \" + (System.currentTimeMillis() - startTs));",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO",
    "TODO",
    "/////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO",
    "buf.writeDouble(0);",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Now we just support pipelined row splits merging for dense type row",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "Read matrix meta from meta file",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "matrix.startServering();",
    "return;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Read matrix meta from meta file",
    "Sort partitions",
    "TODO:",
    "int size = rows.length;",
    "int size = rows.length;",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "return Objects.toStringHelper(this).add(\"serial\", serial).add(\"listSize\", datas.size())",
    ".toString();",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load ml conf file for graph based algorithm",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "If out path exist , just remove it first",
    "Create parent directory if not exist",
    "Rename",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "throw new AngelException(e);",
    "JobStateProto jobState = report.getJobState();",
    "Check need load matrices",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "load user job resource files",
    "setLocalAddr();",
    "2.get job id",
    "5.write configuration to a xml file",
    "8.get app master client",
    "Write job file to JobTracker's fs",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "private volatile PS2PSPusherImpl ps2PSPusher;",
    "TODO",
    "Add tokens to new user so that it may execute its task correctly.",
    "TODO",
    "to exit",
    "TODO",
    "TODO",
    "ps2PSPusher.recover(ProtobufUtil.convert(needRecoverParts.get(i)));",
    "context.getSnapshotManager().processRecovery();",
    "Recover PS from snapshot or load path",
    "1. First check old snapshot",
    "2. Check new checkpoints",
    "3. Check load path setting and old save result",
    "Just init it again",
    "TODO",
    "if(ps2PSPusher != null) {",
    "ps2PSPusher.start();",
    "}",
    "public PS2PSPusherImpl getPs2PSPusher() {",
    "return ps2PSPusher;",
    "}",
    "Filter the head",
    "Get the RPC destination",
    "Get and init the queue",
    "If the queue is empty, activate the processor",
    "Just put it to the rpc queue",
    "if(useInDepWorkers) {",
    "Use independent rpc workers",
    "if (method == TransportMethod.GET_CLOCKS || method == TransportMethod.UPDATE_CLOCK) {",
    "Small rpc request, use sync to avoid thread switch",
    "return false;",
    "}",
    "return true;",
    "} else {",
    "return false;",
    "}",
    "if (!useSync && useAyncHandler) {",
    "senderPool.execute(new Sender(clientId, seqId, method, ctx, result));",
    "} else {",
    "send(clientId, seqId, method, ctx, result);",
    "}",
    "Release the input buffer",
    "Release the input buffer",
    "1. handle the rpc, get the response",
    "Release the input buffer",
    "2. Serialize the response",
    "Send the serialized response",
    "Exception happened",
    "write seq id",
    "Just serialize the head",
    "Exception happened",
    "Allocate result buffer",
    "Exception happened",
    "Just serialize the head",
    "Exception happened",
    "runningContext.printToken();",
    "Reset the response and allocate buffer again",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "TODO",
    "context.getPS2PSPusher().put(request, in, partLoc);",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "TODO",
    "int maxRPCCounter = Math.max(estSize, (int) (workerNum * factor));",
    "for (Map.Entry<Integer, ClientRunningContext> clientEntry : clientRPCCounters.entrySet()) {",
    "LOG.info(\"client \" + clientEntry.getKey() + \" running context:\");",
    "clientEntry.getValue().printToken();",
    "}",
    "return ServerState.GENERAL;",
    "Use Epoll for linux",
    "public String uuid;",
    "TODO:",
    "part = new ServerPartition();",
    "TODO:",
    "public void setChannelPool(GenericObjectPool<Channel> channelPool) {",
    "this.channelPool = channelPool;",
    "}",
    "private final ParameterServer psServer;",
    "Create and start workers",
    "Set workers",
    "Create and start workers",
    "Set workers",
    "If matrix checkpoint path not exist, just return null",
    "Return the path with maximum checkpoint id",
    "Rename temp to item path",
    "Checkpoint base path = Base dir/matrix name",
    "Path for this checkpoint",
    "Generate tmp path",
    "Delete old checkpoints",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// network io method, for model transform",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Serailize the head",
    "Serialize the storage",
    "Deserailze the head",
    "Deseralize the storage",
    "Serailize the head",
    "Serialize the storage",
    "Deserailze the head",
    "Deseralize the storage",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Notice: Basic type ServerRow only support Vector as inner storage now, so you can use methods",
    "to get inner vector for basic type ServerRow.",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "TODO: just check the value is 0 or not now",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "Use sparse storage method, as some elements in the array maybe null",
    "Array length",
    "Valid element number",
    "Element data",
    "Array len",
    "Valid element number",
    "Use sparse storage method, as some elements in the array maybe null",
    "Array length",
    "Valid element number",
    "Element data",
    "Element data",
    "Array len",
    "Valid element number",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Row type",
    "Storage method",
    "Key type",
    "Value type",
    "Vector dim",
    "Vector length",
    "Vector data",
    "Row type",
    "Storage method",
    "Key type",
    "Value type",
    "Vector dim",
    "Vector length",
    "Init the vector",
    "Vector data",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "private final List<PartitionKey> partitionKeys;",
    "Get server partition class",
    "If partition class is not set, just use the default partition class",
    "Get server partition storage class type",
    "Get value class",
    "if col == -1, we use the start/end index to calculate range,",
    "we use double to store the range value since two long minus might exceed the",
    "range of long.",
    "Serialize the head",
    "Serialize the storage",
    "Deserialize the head",
    "Deseralize the storage",
    "Serialize the head",
    "Serialize the storage",
    "Deserialize the head",
    "Deseralize the storage",
    "Row base partition",
    "If storage class is not set, use default DenseServerRowsStorage",
    "Serialize values",
    "Deserialize values",
    "Array size",
    "Actual write size",
    "Rows data",
    "Row id",
    "Row type",
    "Row data",
    "Array size",
    "Actual write row number",
    "Rows data",
    "Row id",
    "Create empty server row",
    "Row data",
    "Rows data",
    "TODO",
    "Serialize row offsets",
    "Serialize column offsets",
    "Deserialize row offset",
    "Deserialize row offset",
    "If storage is set, just get a instance",
    "If storage is not set, use default",
    "If storage is set, just get a instance",
    "If storage is not set, use default",
    "Map size",
    "Actual write size",
    "Rows data",
    "Row id",
    "Row type",
    "Row data",
    "Array size",
    "Actual write row number",
    "Rows data",
    "Row id",
    "Create empty server row",
    "Row data",
    "Rows data",
    "Use Epoll for linux",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "First check the state of the channels in the pool, if a channel is unused, just return",
    "If all channels are in use, create a new channel or wait",
    "Create a new channel",
    "add the PSAgentContext,need fix",
    "If col == -1 and start/end not set",
    "start/end set",
    "for dense type, we need to set the colNum to set dim for vectors",
    "colNum set, start/end not set",
    "Row number must > 0",
    "both set, check its valid",
    "public static final int T_INT_ARBITRARY_VALUE = 28;",
    "public static final int T_INVALID_VALUE = 29;",
    "TODO:add more vector type",
    "TODO : subDim set",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Split updates",
    "Shuffle update splits",
    "Generate part update parameters",
    "Set split context: partition key, use int key for long key vector or not ect",
    "write the max abs",
    "---------------------------------------------------",
    "---------------------------------------------------",
    "---------------------------------------------------------------",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "KeepStorage is guaranteed",
    "we gauss dense storage is more efficient",
    "v1Size < v2Size * Constant.sparseThreshold",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss dense storage is more efficient",
    "prevent rehash",
    "KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "dense preferred",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sorted preferred",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "dger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "sger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "get configuration from envs",
    "get master location",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "add dense double matrix",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "true, false",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Kubernetes Configs.",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "Start PS",
    "Start to run application",
    "Init node neighbors",
    "client.asyncUpdate(new InitNeighborOver(new InitNeighborOverParam(matrixId))).get();",
    "Sample the neighbors",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setValidIndexNum(100);",
    "siMat.setColNum(10000000000L);",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "Start PS",
    "Start to run application",
    "Init node neighbors and feats",
    "Sample the neighbors",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "Start PS",
    "Start to run application",
    "Init node neighbors",
    "Sample the neighbors",
    "sample continuously beginning from a random index",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "ServerLongAnyRow row = (ServerLongAnyRow) psContext.getMatrixStorageManager().getRow(pparam.getPartKey(), 0);",
    "ObjectIterator<Long2ObjectMap.Entry<IElement>> iter = row.iterator();",
    "while (iter.hasNext()) {",
    "Long2ObjectMap.Entry<IElement> entry = iter.next();",
    "long key = entry.getLongKey() + pparam.getPartKey().getStartCol();",
    "WalkPath value = (WalkPath) entry.getValue();",
    "",
    "if (workerPartitionId == value.getNextPartitionIdx()) {",
    "result.put(key, value.getTail2());",
    "}",
    "}",
    "int matrixId, PartitionKey partKey, long[] keyIds, int startIdx, int endIdx",
    "System.out.println(\"PathQueue: put data to queue\");",
    "System.out.println(\"queue.size: \" + queue.size());",
    "System.out.println(\"CurrPathIdx of \" + wPath.getHead() + \" is \" + wPath.getCurrPathIdx());",
    "if (numRetry == retry) {",
    "System.out.println(\"retried 3 time, got : \" + result.size());",
    "}",
    "System.out.println(\"popBatch: \" + result.size() +\" | \"+ count);",
    "getRow(partKey.getMatrixId(), rowId, partKey.getPartitionId())",
    "StringBuilder sb = new StringBuilder();",
    "sb.append(key).append(\" -> {\");",
    "for (long n: neighbor) {",
    "sb.append(n).append(\", \");",
    "}",
    "sb.append(\"} : \").append(neigh);",
    "System.out.println(sb.toString());",
    "System.out.println(\"pushed size: \" + pathTail.size());",
    "List<LinkedBlockingQueue<WalkPath>> queueList = PathQueue.getQueueList(partKey.getPartitionId());",
    "int p = 0;",
    "for (LinkedBlockingQueue<WalkPath> queue: queueList) {",
    "System.out.println(\"partition \" + p + \", size1 = \"+ pathTail.size() +  \" size2 = \" + queue.size());",
    "p++;",
    "}",
    "System.out.println(\"pushed batch finished!\");",
    "Get node neighbor number",
    "If the neighbor number is 0, just return a int[0]",
    "If count <= 0 or the neighbor number is less or equal then count, just copy all neighbors to the result array",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "Store the total neighbor number of all nodes in rowOffsets",
    "Put the node ids, node neighbor number, node neighbors to the cache",
    "No data in this partition",
    "Get total neighbor number",
    "Final matrix column indices: neighbors node ids",
    "Write positions in cloumnIndices for nodes",
    "Copy all cached sub column indices to final column indices",
    "Read position for a sub column indices",
    "Copy column indices for a node to final column indices",
    "Update write position for this node in final column indices",
    "Update the read position in sub column indices",
    "Clear all temp data",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "sample happens here to avoid memory copy on servers",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Set training data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model type",
    "String modelType = String.valueOf(RowType.T_FLOAT_DENSE);",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.set(MLConf.ML_MODEL_TYPE(), modelType);",
    "conf.setDouble(MLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "predictTest();",
    "Data format, libsvm or dummy",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set data format",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set log path",
    "Set trainning data path",
    "Set save model path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set training data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log save path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set testing data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "TODO: optimize int key indices",
    "System.out.println(\"deserialize cols.length=\" + nCols);",
    "System.out.print(\"deserialize \");",
    "System.out.print(cols[c] + \" \");",
    "System.out.println();",
    "TODO Auto-generated method stub",
    "LOG.info(\"original float length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"original double length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"parsed float length: \" + length + Arrays.toString(arr));",
    "LOG.info(\"parsed double length: \" + length + Arrays.toString(arr));",
    "ground truth: positive, precision: positive",
    "start row index for words",
    "start row index for docs",
    "doc ids",
    "topic assignments",
    "word to docs reverse index",
    "count word",
    "build word start index",
    "build word to doc reverse idx",
    "build dks",
    "dks = new TraverseHashMap[n_docs];",
    "for (int d = 0; d < n_docs; d++) {",
    "if (K < Short.MAX_VALUE) {",
    "if (docs.get(d).len < Byte.MAX_VALUE)",
    "dks[d] = new S2BTraverseMap(docs.get(d).len);",
    "if (docs.get(d).len < Short.MAX_VALUE)",
    "dks[d] = new S2STraverseMap(Math.min(K, docs.get(d).len));",
    "else",
    "dks[d] = new S2ITraverseMap(Math.min(K, docs.get(d).len));",
    "} else {",
    "dks[d] = new I2ITranverseMap(Math.min(K, docs.get(d).len));",
    "}",
    "}",
    "build dks",
    "allocate update maps",
    "Skip if no token for this word",
    "Check whether error when fetching word-topic",
    "Build FTree for current word",
    "current doc",
    "old topic assignment",
    "Check if error happens. if this happen, it's probably that failures happen to servers.",
    "We need to adjust the memory settings or network fetching parameters.",
    "Update statistics if needed",
    "Calculate psum and sample new topic",
    "Update statistics if needed",
    "Assign new topic",
    "Skip if no token for this word",
    "if (u >= p[end]) {",
    "System.out.println(\"u=\" + u + \" p[end]=\" + p[end] + \" start=\" + start + \" end=\" + end);",
    "return end;",
    "}",
    "",
    "if (u < p[start]) {",
    "System.out.println(\"u=\" + u + \" p[start]=\" + p[start] + \" start=\" + start + \" end=\" + end);",
    "return start;",
    "}",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "calculate columns",
    "reset(row);",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "node's end index in instancePos, instances in [start, end] belong to a tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "this.forest[this.currentTree].fset = sampleFeatureVector.getStorage().getValues();",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "1. decide nodes that should be calculated",
    "2. decide calculated and subtracted tree nodes",
    "3. calculate threads",
    "wait until all threads finish",
    "4. subtract threads",
    "wait until all threads finish",
    "5. send histograms to PS",
    "6. update histogram cache",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "this.phase = GBDTPhase.AFTER_SPLIT;",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "update local replica",
    "create AfterSplit task",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current depth",
    "finish current tree",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "1. update predictions of training data",
    "2. update predictions of validation data",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "if not -1, sufficient space will be allocated at once",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fSet, fid);",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "assert fvalue >= sketch[start] && fvalue <= sketch[end];",
    "if (left > end) return end - start;",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "max and min of each feature",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = (int) row.getStartCol();",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "Release-2.4.0": [
    "@maxIndex: this variable contains the max index of node/word",
    "values[b + offset] = (random.nextFloat() - 0.5f) / dimension;",
    "some params",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "window size",
    "Skip-Gram model",
    "Accumulate the input vectors from context",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "window size",
    "skip-gram model",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "some params",
    "batch sentences",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "locates the input vectors to local array to prevent randomly access",
    "on the large server row.",
    "fill 0 for context vector",
    "window size",
    "Continuous bag-of-words Models",
    "Accumulate the input vectors from context",
    "Calculate the partial dot values",
    "We should guarantee here that the sample would not equal the ``word``",
    "used to accumulate the context input vectors",
    "locates the input vector into local arrays to prevent randomly access for",
    "the large server row.",
    "window size",
    "while true to prevent sampling out a positive target",
    "how to prevent the randomly access to the output vectors??",
    "accumulate gradients for the input vectors",
    "update output vectors",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "// calculate bias",
    "if (param.getPartKey().getStartCol() <= 0 && param.getPartKey().getEndCol() > 0) {",
    "double zVal = VectorUtils.getDouble(z, 0);",
    "double nVal = VectorUtils.getDouble(n, 0);",
    "VectorUtils.setFloat(w, 0, (float) (-1.0 * alpha * zVal / (beta + Math.sqrt(nVal))));",
    "}",
    "Do nothing.",
    "split updates",
    "shuffle update splits",
    "generate part update splits",
    "set split context: partition key, use int key for long key vector or net",
    "how to do intersection for two dense vector with a given indices ??",
    "compress the neighbor IDs",
    "write out edges",
    "write out tags",
    "Get node neighbors",
    "current word",
    "neu1 stores the average value of input vectors in the context (CBOW)",
    "Continuous Bag-of-Words Model",
    "Accumulate the input vectors from context",
    "negative sampling",
    "Using the sigmoid value from the pre-computed table",
    "accumulate for the hidden layer",
    "update output layer",
    "add the counter for target",
    "update hidden layer",
    "Update the input vector for each word in the context",
    "add the counter to input",
    "update input layers",
    "update output layers",
    "for (int a = 0; a < layers.length; a++) deltas[a] = layers[a] - deltas[a];",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "if not -1, sufficient space will be allocated at once",
    "InstanceRow ins = instanceRows[insId];",
    "int[] indices = ins.indices();",
    "int[] bins = ins.bins();",
    "int nnz = indices.length;",
    "for (int j = 0; j < nnz; j++) {",
    "int fid = indices[j];",
    "if (isFeatUsed[fid - featLo]) {",
    "histograms[fid - featLo].accumulate(bins[j], gradPairs[insId]);",
    "}",
    "}",
    "1. allocate histogram",
    "2. loop non-zero instances, accumulate to histogram",
    "if (nnz <= nodeEnd - nodeStart + 1) { // loop all nnz of current feature",
    "3. add remaining grad and hess to default bin",
    "return param.calcWeights(grad, hess);",
    "numClass is usually small, so we do not use arraycopy here",
    "numClass is usually small, so we do not use arraycopy here",
    "TODO: use more schema on default bin",
    "1. set default bin to left child",
    "2. for other bins, find its location",
    "3. create split set",
    "this.nodeStats = new GBTNodeStat[numClass == 2 ? 1 : numClass];",
    "predict sparse instance with indices and values",
    "predict libsvm data",
    "Preconditions.checkArgument(preds.length == labels.length,",
    "\"LogLossMetric should be used for binary-label classification\");",
    "double loss = 0.0;",
    "for (int i = 0; i < preds.length; i++) {",
    "loss += evalOne(preds[i], labels[i]);",
    "}",
    "return loss / labels.length;",
    "double error = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "error += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "error += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return error / labels.length;",
    "Preconditions.checkArgument(preds.length != labels.length",
    "&& preds.length % labels.length == 0,",
    "\"CrossEntropyMetric should be used for multi-label classification\");",
    "double loss = 0.0;",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "loss += evalOne(pred, labels[i]);",
    "}",
    "return loss / labels.length;",
    "double correct = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "correct += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "correct += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return (float) (correct / labels.length);",
    "double errSum = 0.0f;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "errSum += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "errSum += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return Math.sqrt(errSum / labels.length);",
    "System.out.println(\"----------\");",
    "System.out.println(\"read buffer = \" + Integer.toBinaryString(readBufferT & 0b11111111)",
    "+ \", mask = \" + Integer.toBinaryString(readMaskT));",
    "readMaskT <<= 1;",
    "boolean[] bits = new boolean[]{true, true, false, false, true, false, false, false, true, true, false, true};",
    "int n = bits.length;",
    "BufferedBitSet writeBitSet = new BufferedBitSet(n);",
    "BufferedBitSet readBitSet = new BufferedBitSet(writeBitSet.getBytes(), n);",
    "if (bitSet.get(i) != bits[i]) {",
    "throw new RuntimeException(\"\" + i);",
    "}",
    "private final ByteBuffer bytes;",
    "public BufferedBitSetReader(ByteBuffer bytes, int numBits) {",
    "int capacity = bytes.capacity() * 8;",
    "readIndexT = bytes.capacity() - 1;",
    "return bytes.get(index);",
    "TODO: use arraycopy to make it faster",
    "assert from >= this.from && to <= this.to;",
    "LOG.debug(String.format(\"Create subset: [%d-%d]\", newFrom, newTo));",
    "LOG.debug(String.format(\"Get overlap: [%d-%d]\", newFrom, newTo));",
    "return bits.clone();",
    "private final SerializableBuffer bytes;",
    "private final ByteBuffer bytes;",
    "this.bytes = ByteBuffer.allocate(numBytes);",
    "public BufferedBitSetWriter(ByteBuffer bytes) {",
    "this.bytes = bytes;",
    "}",
    "bytes.put(writeIndex++, (byte) writeBuffer);",
    "public ByteBuffer getBytes() {",
    "return bytes;",
    "}",
    "ML TreeConf",
    "GBDT TreeConf",
    "edges=[x,...] firstFlow=1 => go to right if < x and go to left if > x",
    "edges=[x,...] firstFlow=0 => go to left if < x and go to right if > x",
    "different types of tree node splits, enumerated by their complexity",
    "in order to reduce model size, we give priority to split point",
    "comparison between two split points, we give priority to lower feature index",
    "TODO: comparison between two split sets",
    "public boolean leafwise;  // true if leaf-wise training, false if level-wise training",
    "TODO: regularization",
    "TODO: regularization",
    "public float insSampleRatio;  // subsample ratio for instances",
    "Use by line with weight",
    "evict entry with the smallest degree",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighbor;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighborParam;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighborResult;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.initneighbor.InitNeighbor;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.initneighbor.InitNeighborParam;",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "@Test",
    "public void testInitAndGet() throws ExecutionException, InterruptedException {",
    "Worker worker = LocalClusterContext.get().getWorker(worker0Attempt0Id).getWorker();",
    "MatrixClient client1 = worker.getPSAgent().getMatrixClient(\"w2\", 0);",
    "int matrixW1Id = client1.getMatrixId();",
    "// Generate graph data",
    "Map<Integer, int []> adjMap = generateAdjTable(nodeNum, maxNeighborNum);",
    "",
    "// Init graph adj table",
    "InitNeighbor func = new InitNeighbor(new InitNeighborParam(matrixW1Id, adjMap));",
    "client1.update(func);",
    "",
    "int [] nodeIds = new int[adjMap.size()];",
    "int i = 0;",
    "for(int nodeId : adjMap.keySet()) {",
    "nodeIds[i++] = nodeId;",
    "}",
    "",
    "// Get graph adj table from PS",
    "GetNeighbor getFunc = new GetNeighbor(new GetNeighborParam(matrixW1Id, nodeIds, maxNeighborNum));",
    "Map<Integer, int[]> getResults = ((GetNeighborResult) (client1.get(getFunc)))",
    ".getNodeIdToNeighborIndices();",
    "",
    "// Check the result",
    "for(Entry<Integer, int[]> entry : getResults.entrySet()) {",
    "Assert.assertArrayEquals(entry.getValue(), adjMap.get(entry.getKey()));",
    "}",
    "}",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "QSLRRunner runner = new QSLRRunner();",
    "runner.train(conf);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Dataset",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Softmax algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DeepFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Model type",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set WideAndDeep algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Set LDA parameters #V, #K",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set LDA algorithm parameters",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set SVM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "testSparseDoubleUDF();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "testSparseDoubleUDF();",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add comp dense double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "LOG.info(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntFloatVector row = (IntFloatVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntLongVector row = (IntLongVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setPartitionClass(CSRPartition.class);",
    "siMat.setPartitionStorageClass(IntCSRStorage.class);",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "MatrixContext siMat = new MatrixContext();",
    "siMat.setName(SPARSE_INT_MAT);",
    "siMat.setRowType(RowType.T_ANY_INTKEY_SPARSE);",
    "siMat.setRowNum(1);",
    "siMat.setValidIndexNum(100);",
    "siMat.setColNum(10000000000L);",
    "siMat.setValueType(Node.class);",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "angelClient.addMatrix(siMat);",
    "add sparse long-key double matrix",
    "Start PS",
    "Start to run application",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "https://blog.csdn.net/cocoonyang/article/details/63068108",
    "v1[i] = v1[i] + da * v2[i];",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "v1[i] = v1[i] + da * v2[i];",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "all the files in input set",
    "Shuffle the file",
    "Get the blocks for all files",
    "Adjust the maxSize to make the split more balanced",
    "Handle the splittable files",
    "Handle the unsplittable files",
    "Split the blocks",
    "If the remaining size of the current block is smaller than the required size,",
    "the remaining blocks are divided into the current split",
    "Update current split length and move to next block",
    "Clear the current block offset",
    "Current split length is > maxSize, split the block and generate a new split",
    "Clear blocks list for next split",
    "Clear the current split length",
    "If splitBlocks is not empty, just genetate a split for it",
    "get block locations from file system",
    "create an input split",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "k8sClusterManager = new KubernetesClusterManager(appContext);",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "Check is there save request",
    "LOG.info(\"PS \" + psAttemptId + \" need save \" + subSaveContext);",
    "Check is there load request",
    "LOG.info(\"PS \" + psAttemptId + \" need load \" + subLoadContext);",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "LOG.info(\"error happened in psAttempt \" + psAttemptId + \" error msg=\" + request.getMsg());",
    "remove this parameter server attempt from monitor set",
    "LOG.info(\"Epoch=\" + epoch + \" Metrics=\" + metrics);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Path tmpPath = new Path(new Path(context.getConf().get(AngelConf.ANGEL_JOB_TMP_OUTPUT_PATH)),",
    "String.valueOf(requestId));",
    "Path tmpPath = HdfsUtil.toTmpPath(new Path(saveContext.getSavePath()));",
    "saveContext.setTmpSavePath(tmpPath.toString());",
    "Filter old epoch trigger first",
    "Split the user request to sub-requests to pss",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Split the user request to sub-requests to pss",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Old parameter name",
    "Parallel GC parameters",
    "G1 params",
    "Parallel Scavenge + Parallel Old",
    "G1",
    ".append(\" -XX:G1NewSizePercent=\").append(minNewRatio)",
    ".append(\" -XX:G1MaxNewSizePercent=\").append(maxNewRatio)",
    "CMS",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "G1 params",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "restartPS(psLoc);",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and EXECUTE_SUCCESSED, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run or run over",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "todo",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnException or YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Add one sync matrix",
    "addSyncMatrix();",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "matrixContext.set(MatrixConf.MATRIX_LOAD_PATH, \"\");",
    "for(Entry<ParameterServerId, Map<Integer, MatrixMeta>> psEntry : matrixPartitionsOnPS.entrySet()) {",
    "LOG.info(\"ps id = \" + psEntry.getKey());",
    "Map<Integer, MatrixMeta> matrixIdToMetaMap = psEntry.getValue();",
    "for(Entry<Integer, MatrixMeta> metaEntry : matrixIdToMetaMap.entrySet()) {",
    "LOG.info(\"matrix id = \" + metaEntry.getKey());",
    "LOG.info(\"matrix partitons number = \" + metaEntry.getValue().getPartitionMetas().size());",
    "}",
    "}",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "clock first",
    "wait",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Plus a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Update a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get values from pss use row/column indices",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ PSF get/update, use can implement their own psf",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get a row or a batch of rows",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Just return",
    "Just return",
    "Just return",
    "Just return",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "Sort the partitions by start column index",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "Doing average or not",
    "Filter un-important update",
    "Split this row according the matrix partitions",
    "Set split context",
    "Remove the row from matrix",
    "buf.writeDouble(0.0);",
    "TODO:",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "LOG.error(\"put response message queue failed \", e);",
    "Use Epoll for linux",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "getPSState(entry.getKey());",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "private Channel getChannel(Location loc) throws Exception {",
    "return channelManager.getOrCreateChannel(new Location(loc.getIp(), loc.getPort() + 1));",
    "}",
    "private GenericObjectPool<Channel> getChannelPool(Location loc) throws InterruptedException {",
    "return channelManager.getOrCreateChannelPool(new Location(loc.getIp(), loc.getPort() + 1), PSAgentContext",
    ".get()",
    ".getConf()",
    ".getInt(AngelConf.ANGEL_WORKER_TASK_NUMBER,",
    "AngelConf.DEFAULT_ANGEL_WORKER_TASK_NUMBER));",
    "}",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "request.getContext().setChannelPool(pool);",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "updateMatrixCache(request.getPartKey(), response.getPartition());",
    "updateMatrixCache(request.getPartKey(), response.getRowsSplit());",
    "TODO",
    "ServerRow rowSplit = PSAgentContext.get().getMatricesCache()",
    ".getRowSplit(request.getPartKey().getMatrixId(), request.getPartKey(),",
    "request.getRowIndex());",
    "response.setRowSplit(rowSplit);",
    "updateMatrixCache(request.getPartKey(), response.getRowSplit());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "TODO",
    "private void updateMatrixCache(PartitionKey partKey, ServerPartition partition) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, partition);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, ServerRow rowSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowSplit);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, List<ServerRow> rowsSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowsSplit);",
    "}",
    "Get partitions for this row",
    "Distinct get row requests",
    "Get row splits of this row from the matrix cache first",
    "responseCache.addSubResponse(rowSplit);",
    "If the row split does not exist in cache, get it from parameter server",
    "Split the param use matrix partitions",
    "Send request to PSS",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Send request to PSS",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "LOG.info(\"get row split use time=\" + (System.currentTimeMillis() - startTs));",
    "LOG.info(\"start to request \" + requestId);",
    "LOG.info(\"start to request \" + requestId);",
    "Split param use matrix partitons",
    "If all sub-results are received, just remove request and result cache",
    "Split this row according the matrix partitions",
    "Set split context",
    "Split this row according the matrix partitions",
    "Set split context",
    "long startTs = System.currentTimeMillis();",
    "LOG.error(\"combine use time = \" + (System.currentTimeMillis() - startTs));",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO",
    "TODO",
    "/////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO",
    "buf.writeDouble(0);",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Now we just support pipelined row splits merging for dense type row",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "Read matrix meta from meta file",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "matrix.startServering();",
    "return;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Read matrix meta from meta file",
    "Sort partitions",
    "TODO:",
    "int size = rows.length;",
    "int size = rows.length;",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "return Objects.toStringHelper(this).add(\"serial\", serial).add(\"listSize\", datas.size())",
    ".toString();",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load ml conf file for graph based algorithm",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "If out path exist , just remove it first",
    "Create parent directory if not exist",
    "Rename",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "throw new AngelException(e);",
    "JobStateProto jobState = report.getJobState();",
    "Check need load matrices",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "load user job resource files",
    "setLocalAddr();",
    "2.get job id",
    "5.write configuration to a xml file",
    "8.get app master client",
    "Write job file to JobTracker's fs",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "private volatile PS2PSPusherImpl ps2PSPusher;",
    "TODO",
    "Add tokens to new user so that it may execute its task correctly.",
    "TODO",
    "to exit",
    "TODO",
    "TODO",
    "ps2PSPusher.recover(ProtobufUtil.convert(needRecoverParts.get(i)));",
    "context.getSnapshotManager().processRecovery();",
    "Recover PS from snapshot or load path",
    "1. First check old snapshot",
    "2. Check new checkpoints",
    "3. Check load path setting and old save result",
    "Just init it again",
    "TODO",
    "if(ps2PSPusher != null) {",
    "ps2PSPusher.start();",
    "}",
    "public PS2PSPusherImpl getPs2PSPusher() {",
    "return ps2PSPusher;",
    "}",
    "Filter the head",
    "Get the RPC destination",
    "Get and init the queue",
    "If the queue is empty, activate the processor",
    "Just put it to the rpc queue",
    "if(useInDepWorkers) {",
    "Use independent rpc workers",
    "if (method == TransportMethod.GET_CLOCKS || method == TransportMethod.UPDATE_CLOCK) {",
    "Small rpc request, use sync to avoid thread switch",
    "return false;",
    "}",
    "return true;",
    "} else {",
    "return false;",
    "}",
    "if (!useSync && useAyncHandler) {",
    "senderPool.execute(new Sender(clientId, seqId, method, ctx, result));",
    "} else {",
    "send(clientId, seqId, method, ctx, result);",
    "}",
    "Release the input buffer",
    "Release the input buffer",
    "1. handle the rpc, get the response",
    "Release the input buffer",
    "2. Serialize the response",
    "Send the serialized response",
    "Exception happened",
    "write seq id",
    "Just serialize the head",
    "Exception happened",
    "Allocate result buffer",
    "Exception happened",
    "Just serialize the head",
    "Exception happened",
    "runningContext.printToken();",
    "Reset the response and allocate buffer again",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "TODO",
    "context.getPS2PSPusher().put(request, in, partLoc);",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "TODO",
    "int maxRPCCounter = Math.max(estSize, (int) (workerNum * factor));",
    "for (Map.Entry<Integer, ClientRunningContext> clientEntry : clientRPCCounters.entrySet()) {",
    "LOG.info(\"client \" + clientEntry.getKey() + \" running context:\");",
    "clientEntry.getValue().printToken();",
    "}",
    "return ServerState.GENERAL;",
    "Use Epoll for linux",
    "public String uuid;",
    "TODO:",
    "part = new ServerPartition();",
    "TODO:",
    "public void setChannelPool(GenericObjectPool<Channel> channelPool) {",
    "this.channelPool = channelPool;",
    "}",
    "private final ParameterServer psServer;",
    "Create and start workers",
    "Set workers",
    "Create and start workers",
    "Set workers",
    "If matrix checkpoint path not exist, just return null",
    "Return the path with maximum checkpoint id",
    "Rename temp to item path",
    "Checkpoint base path = Base dir/matrix name",
    "Path for this checkpoint",
    "Generate tmp path",
    "Delete old checkpoints",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// network io method, for model transform",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Serailize the head",
    "Serialize the storage",
    "Deserailze the head",
    "Deseralize the storage",
    "Serailize the head",
    "Serialize the storage",
    "Deserailze the head",
    "Deseralize the storage",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Notice: Basic type ServerRow only support Vector as inner storage now, so you can use methods",
    "to get inner vector for basic type ServerRow.",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "TODO: just check the value is 0 or not now",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "Use sparse storage method, as some elements in the array maybe null",
    "Array length",
    "Valid element number",
    "Element data",
    "Array len",
    "Valid element number",
    "Use sparse storage method, as some elements in the array maybe null",
    "Array length",
    "Valid element number",
    "Element data",
    "Element data",
    "Array len",
    "Valid element number",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Row type",
    "Storage method",
    "Key type",
    "Value type",
    "Vector dim",
    "Vector length",
    "Vector data",
    "Row type",
    "Storage method",
    "Key type",
    "Value type",
    "Vector dim",
    "Vector length",
    "Init the vector",
    "Vector data",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "private final List<PartitionKey> partitionKeys;",
    "Get server partition class",
    "If partition class is not set, just use the default partition class",
    "Get server partition storage class type",
    "Get value class",
    "if col == -1, we use the start/end index to calculate range,",
    "we use double to store the range value since two long minus might exceed the",
    "range of long.",
    "Serialize the head",
    "Serialize the storage",
    "Deserialize the head",
    "Deseralize the storage",
    "Serialize the head",
    "Serialize the storage",
    "Deserialize the head",
    "Deseralize the storage",
    "Row base partition",
    "If storage class is not set, use default DenseServerRowsStorage",
    "Serialize values",
    "Deserialize values",
    "Array size",
    "Actual write size",
    "Rows data",
    "Row id",
    "Row type",
    "Row data",
    "Array size",
    "Actual write row number",
    "Rows data",
    "Row id",
    "Create empty server row",
    "Row data",
    "Rows data",
    "TODO",
    "Serialize row offsets",
    "Serialize column offsets",
    "Deserialize row offset",
    "Deserialize row offset",
    "If storage is set, just get a instance",
    "If storage is not set, use default",
    "If storage is set, just get a instance",
    "If storage is not set, use default",
    "Map size",
    "Actual write size",
    "Rows data",
    "Row id",
    "Row type",
    "Row data",
    "Array size",
    "Actual write row number",
    "Rows data",
    "Row id",
    "Create empty server row",
    "Row data",
    "Rows data",
    "Use Epoll for linux",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "First check the state of the channels in the pool, if a channel is unused, just return",
    "If all channels are in use, create a new channel or wait",
    "Create a new channel",
    "add the PSAgentContext,need fix",
    "If col == -1 and start/end not set",
    "start/end set",
    "for dense type, we need to set the colNum to set dim for vectors",
    "colNum set, start/end not set",
    "Row number must > 0",
    "both set, check its valid",
    "public static final int T_INT_ARBITRARY_VALUE = 28;",
    "public static final int T_INVALID_VALUE = 29;",
    "TODO:add more vector type",
    "TODO : subDim set",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Split updates",
    "Shuffle update splits",
    "Generate part update parameters",
    "Set split context: partition key, use int key for long key vector or not ect",
    "write the max abs",
    "---------------------------------------------------",
    "---------------------------------------------------",
    "---------------------------------------------------------------",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "KeepStorage is guaranteed",
    "we gauss dense storage is more efficient",
    "v1Size < v2Size * Constant.sparseThreshold",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss dense storage is more efficient",
    "prevent rehash",
    "KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "dense preferred",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sorted preferred",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "dger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "sger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "get configuration from envs",
    "get master location",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "add dense double matrix",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "true, false",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Kubernetes Configs.",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "Start PS",
    "Start to run application",
    "Init node neighbors",
    "client.asyncUpdate(new InitNeighborOver(new InitNeighborOverParam(matrixId))).get();",
    "Sample the neighbors",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setValidIndexNum(100);",
    "siMat.setColNum(10000000000L);",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "Start PS",
    "Start to run application",
    "Init node neighbors and feats",
    "Sample the neighbors",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "Start PS",
    "Start to run application",
    "Init node neighbors",
    "Sample the neighbors",
    "sample continuously beginning from a random index",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "ServerLongAnyRow row = (ServerLongAnyRow) psContext.getMatrixStorageManager().getRow(pparam.getPartKey(), 0);",
    "ObjectIterator<Long2ObjectMap.Entry<IElement>> iter = row.iterator();",
    "while (iter.hasNext()) {",
    "Long2ObjectMap.Entry<IElement> entry = iter.next();",
    "long key = entry.getLongKey() + pparam.getPartKey().getStartCol();",
    "WalkPath value = (WalkPath) entry.getValue();",
    "",
    "if (workerPartitionId == value.getNextPartitionIdx()) {",
    "result.put(key, value.getTail2());",
    "}",
    "}",
    "int matrixId, PartitionKey partKey, long[] keyIds, int startIdx, int endIdx",
    "System.out.println(\"PathQueue: put data to queue\");",
    "System.out.println(\"queue.size: \" + queue.size());",
    "System.out.println(\"CurrPathIdx of \" + wPath.getHead() + \" is \" + wPath.getCurrPathIdx());",
    "if (numRetry == retry) {",
    "System.out.println(\"retried 3 time, got : \" + result.size());",
    "}",
    "System.out.println(\"popBatch: \" + result.size() +\" | \"+ count);",
    "getRow(partKey.getMatrixId(), rowId, partKey.getPartitionId())",
    "StringBuilder sb = new StringBuilder();",
    "sb.append(key).append(\" -> {\");",
    "for (long n: neighbor) {",
    "sb.append(n).append(\", \");",
    "}",
    "sb.append(\"} : \").append(neigh);",
    "System.out.println(sb.toString());",
    "System.out.println(\"pushed size: \" + pathTail.size());",
    "List<LinkedBlockingQueue<WalkPath>> queueList = PathQueue.getQueueList(partKey.getPartitionId());",
    "int p = 0;",
    "for (LinkedBlockingQueue<WalkPath> queue: queueList) {",
    "System.out.println(\"partition \" + p + \", size1 = \"+ pathTail.size() +  \" size2 = \" + queue.size());",
    "p++;",
    "}",
    "System.out.println(\"pushed batch finished!\");",
    "Get node neighbor number",
    "If the neighbor number is 0, just return a int[0]",
    "If count <= 0 or the neighbor number is less or equal then count, just copy all neighbors to the result array",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "Store the total neighbor number of all nodes in rowOffsets",
    "Put the node ids, node neighbor number, node neighbors to the cache",
    "No data in this partition",
    "Get total neighbor number",
    "Final matrix column indices: neighbors node ids",
    "Write positions in cloumnIndices for nodes",
    "Copy all cached sub column indices to final column indices",
    "Read position for a sub column indices",
    "Copy column indices for a node to final column indices",
    "Update write position for this node in final column indices",
    "Update the read position in sub column indices",
    "Clear all temp data",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "sample happens here to avoid memory copy on servers",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Set training data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model type",
    "String modelType = String.valueOf(RowType.T_FLOAT_DENSE);",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.set(MLConf.ML_MODEL_TYPE(), modelType);",
    "conf.setDouble(MLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "predictTest();",
    "Data format, libsvm or dummy",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set data format",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set log path",
    "Set trainning data path",
    "Set save model path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set training data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log save path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set testing data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "TODO: optimize int key indices",
    "System.out.println(\"deserialize cols.length=\" + nCols);",
    "System.out.print(\"deserialize \");",
    "System.out.print(cols[c] + \" \");",
    "System.out.println();",
    "TODO Auto-generated method stub",
    "LOG.info(\"original float length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"original double length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"parsed float length: \" + length + Arrays.toString(arr));",
    "LOG.info(\"parsed double length: \" + length + Arrays.toString(arr));",
    "ground truth: positive, precision: positive",
    "start row index for words",
    "start row index for docs",
    "doc ids",
    "topic assignments",
    "word to docs reverse index",
    "count word",
    "build word start index",
    "build word to doc reverse idx",
    "build dks",
    "dks = new TraverseHashMap[n_docs];",
    "for (int d = 0; d < n_docs; d++) {",
    "if (K < Short.MAX_VALUE) {",
    "if (docs.get(d).len < Byte.MAX_VALUE)",
    "dks[d] = new S2BTraverseMap(docs.get(d).len);",
    "if (docs.get(d).len < Short.MAX_VALUE)",
    "dks[d] = new S2STraverseMap(Math.min(K, docs.get(d).len));",
    "else",
    "dks[d] = new S2ITraverseMap(Math.min(K, docs.get(d).len));",
    "} else {",
    "dks[d] = new I2ITranverseMap(Math.min(K, docs.get(d).len));",
    "}",
    "}",
    "build dks",
    "allocate update maps",
    "Skip if no token for this word",
    "Check whether error when fetching word-topic",
    "Build FTree for current word",
    "current doc",
    "old topic assignment",
    "Check if error happens. if this happen, it's probably that failures happen to servers.",
    "We need to adjust the memory settings or network fetching parameters.",
    "Update statistics if needed",
    "Calculate psum and sample new topic",
    "Update statistics if needed",
    "Assign new topic",
    "Skip if no token for this word",
    "if (u >= p[end]) {",
    "System.out.println(\"u=\" + u + \" p[end]=\" + p[end] + \" start=\" + start + \" end=\" + end);",
    "return end;",
    "}",
    "",
    "if (u < p[start]) {",
    "System.out.println(\"u=\" + u + \" p[start]=\" + p[start] + \" start=\" + start + \" end=\" + end);",
    "return start;",
    "}",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "calculate columns",
    "reset(row);",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "node's end index in instancePos, instances in [start, end] belong to a tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "this.forest[this.currentTree].fset = sampleFeatureVector.getStorage().getValues();",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "1. decide nodes that should be calculated",
    "2. decide calculated and subtracted tree nodes",
    "3. calculate threads",
    "wait until all threads finish",
    "4. subtract threads",
    "wait until all threads finish",
    "5. send histograms to PS",
    "6. update histogram cache",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "this.phase = GBDTPhase.AFTER_SPLIT;",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "update local replica",
    "create AfterSplit task",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current depth",
    "finish current tree",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "1. update predictions of training data",
    "2. update predictions of validation data",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "if not -1, sufficient space will be allocated at once",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fSet, fid);",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "assert fvalue >= sketch[start] && fvalue <= sketch[end];",
    "if (left > end) return end - start;",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "max and min of each feature",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = (int) row.getStartCol();",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "Release-3.0.0": [
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighbor;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighborParam;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighborResult;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.initneighbor.InitNeighbor;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.initneighbor.InitNeighborParam;",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "@Test",
    "public void testInitAndGet() throws ExecutionException, InterruptedException {",
    "Worker worker = LocalClusterContext.get().getWorker(worker0Attempt0Id).getWorker();",
    "MatrixClient client1 = worker.getPSAgent().getMatrixClient(\"w2\", 0);",
    "int matrixW1Id = client1.getMatrixId();",
    "// Generate graph data",
    "Map<Integer, int []> adjMap = generateAdjTable(nodeNum, maxNeighborNum);",
    "",
    "// Init graph adj table",
    "InitNeighbor func = new InitNeighbor(new InitNeighborParam(matrixW1Id, adjMap));",
    "client1.update(func);",
    "",
    "int [] nodeIds = new int[adjMap.size()];",
    "int i = 0;",
    "for(int nodeId : adjMap.keySet()) {",
    "nodeIds[i++] = nodeId;",
    "}",
    "",
    "// Get graph adj table from PS",
    "GetNeighbor getFunc = new GetNeighbor(new GetNeighborParam(matrixW1Id, nodeIds, maxNeighborNum));",
    "Map<Integer, int[]> getResults = ((GetNeighborResult) (client1.get(getFunc)))",
    ".getNodeIdToNeighborIndices();",
    "",
    "// Check the result",
    "for(Entry<Integer, int[]> entry : getResults.entrySet()) {",
    "Assert.assertArrayEquals(entry.getValue(), adjMap.get(entry.getKey()));",
    "}",
    "}",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "QSLRRunner runner = new QSLRRunner();",
    "runner.train(conf);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Dataset",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Softmax algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set AFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DeepFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set WideAndDeep algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DCN algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Set LDA parameters #V, #K",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set LDA algorithm parameters",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set SVM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "testSparseDoubleUDF();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "testSparseDoubleUDF();",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add comp dense double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "LOG.info(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntFloatVector row = (IntFloatVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntLongVector row = (IntLongVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setPartitionClass(CSRPartition.class);",
    "siMat.setPartitionStorageClass(IntCSRStorage.class);",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "MatrixContext siMat = new MatrixContext();",
    "siMat.setName(SPARSE_INT_MAT);",
    "siMat.setRowType(RowType.T_ANY_INTKEY_SPARSE);",
    "siMat.setRowNum(1);",
    "siMat.setValidIndexNum(100);",
    "siMat.setColNum(10000000000L);",
    "siMat.setValueType(Node.class);",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "angelClient.addMatrix(siMat);",
    "add sparse long-key double matrix",
    "Start PS",
    "Start to run application",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "https://blog.csdn.net/cocoonyang/article/details/63068108",
    "v1[i] = v1[i] + da * v2[i];",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "v1[i] = v1[i] + da * v2[i];",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "all the files in input set",
    "Shuffle the file",
    "Get the blocks for all files",
    "Adjust the maxSize to make the split more balanced",
    "Handle the splittable files",
    "Handle the unsplittable files",
    "Split the blocks",
    "If the remaining size of the current block is smaller than the required size,",
    "the remaining blocks are divided into the current split",
    "Update current split length and move to next block",
    "Clear the current block offset",
    "Current split length is > maxSize, split the block and generate a new split",
    "Clear blocks list for next split",
    "Clear the current split length",
    "If splitBlocks is not empty, just genetate a split for it",
    "get block locations from file system",
    "create an input split",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "k8sClusterManager = new KubernetesClusterManager(appContext);",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "Check is there save request",
    "LOG.info(\"PS \" + psAttemptId + \" need save \" + subSaveContext);",
    "Check is there load request",
    "LOG.info(\"PS \" + psAttemptId + \" need load \" + subLoadContext);",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "LOG.info(\"error happened in psAttempt \" + psAttemptId + \" error msg=\" + request.getMsg());",
    "remove this parameter server attempt from monitor set",
    "LOG.info(\"Epoch=\" + epoch + \" Metrics=\" + metrics);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Path tmpPath = new Path(new Path(context.getConf().get(AngelConf.ANGEL_JOB_TMP_OUTPUT_PATH)),",
    "String.valueOf(requestId));",
    "Path tmpPath = HdfsUtil.toTmpPath(new Path(saveContext.getSavePath()));",
    "saveContext.setTmpSavePath(tmpPath.toString());",
    "Filter old epoch trigger first",
    "Split the user request to sub-requests to pss",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Split the user request to sub-requests to pss",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "G1 params",
    ".append(\" -XX:G1NewSizePercent=\").append(minNewRatio)",
    ".append(\" -XX:G1MaxNewSizePercent=\").append(maxNewRatio)",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "G1 params",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "restartPS(psLoc);",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "TODO: 2019/5/5",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and EXECUTE_SUCCESSED, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run or run over",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "todo",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnException or YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Add one sync matrix",
    "addSyncMatrix();",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "for(Entry<ParameterServerId, Map<Integer, MatrixMeta>> psEntry : matrixPartitionsOnPS.entrySet()) {",
    "LOG.info(\"ps id = \" + psEntry.getKey());",
    "Map<Integer, MatrixMeta> matrixIdToMetaMap = psEntry.getValue();",
    "for(Entry<Integer, MatrixMeta> metaEntry : matrixIdToMetaMap.entrySet()) {",
    "LOG.info(\"matrix id = \" + metaEntry.getKey());",
    "LOG.info(\"matrix partitons number = \" + metaEntry.getValue().getPartitionMetas().size());",
    "}",
    "}",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "clock first",
    "wait",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Plus a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Update a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get values from pss use row/column indices",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ PSF get/update, use can implement their own psf",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get a row or a batch of rows",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Just return",
    "Just return",
    "Just return",
    "Just return",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "Sort the partitions by start column index",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "Doing average or not",
    "Filter un-important update",
    "Split this row according the matrix partitions",
    "Set split context",
    "Remove the row from matrix",
    "buf.writeDouble(0.0);",
    "TODO:",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.error(\"channel \" + ctx.channel() + \" inactive\");",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "LOG.error(\"put response message queue failed \", e);",
    "Use Epoll for linux",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "getPSState(entry.getKey());",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "private Channel getChannel(Location loc) throws Exception {",
    "return channelManager.getOrCreateChannel(new Location(loc.getIp(), loc.getPort() + 1));",
    "}",
    "private GenericObjectPool<Channel> getChannelPool(Location loc) throws InterruptedException {",
    "return channelManager.getOrCreateChannelPool(new Location(loc.getIp(), loc.getPort() + 1), PSAgentContext",
    ".get()",
    ".getConf()",
    ".getInt(AngelConf.ANGEL_WORKER_TASK_NUMBER,",
    "AngelConf.DEFAULT_ANGEL_WORKER_TASK_NUMBER));",
    "}",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "request.getContext().setChannelPool(pool);",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "updateMatrixCache(request.getPartKey(), response.getPartition());",
    "updateMatrixCache(request.getPartKey(), response.getRowsSplit());",
    "TODO",
    "ServerRow rowSplit = PSAgentContext.get().getMatricesCache()",
    ".getRowSplit(request.getPartKey().getMatrixId(), request.getPartKey(),",
    "request.getRowIndex());",
    "response.setRowSplit(rowSplit);",
    "updateMatrixCache(request.getPartKey(), response.getRowSplit());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "TODO",
    "private void updateMatrixCache(PartitionKey partKey, ServerPartition partition) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, partition);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, ServerRow rowSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowSplit);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, List<ServerRow> rowsSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowsSplit);",
    "}",
    "Get partitions for this row",
    "Distinct get row requests",
    "Get row splits of this row from the matrix cache first",
    "responseCache.addSubResponse(rowSplit);",
    "If the row split does not exist in cache, get it from parameter server",
    "Split the param use matrix partitions",
    "Send request to PSS",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Send request to PSS",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "LOG.info(\"get row split use time=\" + (System.currentTimeMillis() - startTs));",
    "LOG.info(\"start to request \" + requestId);",
    "LOG.info(\"start to request \" + requestId);",
    "Split param use matrix partitons",
    "If all sub-results are received, just remove request and result cache",
    "Split this row according the matrix partitions",
    "Set split context",
    "Split this row according the matrix partitions",
    "Set split context",
    "long startTs = System.currentTimeMillis();",
    "LOG.error(\"combine use time = \" + (System.currentTimeMillis() - startTs));",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO",
    "TODO",
    "/////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO",
    "buf.writeDouble(0);",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Now we just support pipelined row splits merging for dense type row",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "int size = rows.length;",
    "int size = rows.length;",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "row.getStorage().serialize(dataOutputStream);",
    "row.getStorage().deserialize(input);",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "matrix.startServering();",
    "return;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "return Objects.toStringHelper(this).add(\"serial\", serial).add(\"listSize\", datas.size())",
    ".toString();",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load ml conf file for graph based algorithm",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "If out path exist , just remove it first",
    "Create parent directory if not exist",
    "Rename",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "throw new AngelException(e);",
    "JobStateProto jobState = report.getJobState();",
    "Check need load matrices",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "load user job resource files",
    "setLocalAddr();",
    "2.get job id",
    "5.write configuration to a xml file",
    "8.get app master client",
    "Write job file to JobTracker's fs",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "private volatile PS2PSPusherImpl ps2PSPusher;",
    "TODO",
    "Add tokens to new user so that it may execute its task correctly.",
    "TODO",
    "to exit",
    "TODO",
    "TODO",
    "ps2PSPusher.recover(ProtobufUtil.convert(needRecoverParts.get(i)));",
    "context.getSnapshotManager().processRecovery();",
    "Recover PS from snapshot or load path",
    "1. First check old snapshot",
    "2. Check new checkpoints",
    "3. Check load path setting and old save result",
    "Just init it again",
    "TODO",
    "if(ps2PSPusher != null) {",
    "ps2PSPusher.start();",
    "}",
    "public PS2PSPusherImpl getPs2PSPusher() {",
    "return ps2PSPusher;",
    "}",
    "LOG.error(\"send response of request \" + requestToString(clientId, seqId) + \" failed \");",
    "LOG.error(\"send response of request failed, request seqId=\" + seqId + \", channel=\" + ch, ex);",
    "Release the input buffer",
    "Release the input buffer",
    "1. handle the rpc, get the response",
    "Release the input buffer",
    "2. Serialize the response",
    "Send the serialized response",
    "Exception happened",
    "write seq id",
    "Just serialize the head",
    "Exception happened",
    "Allocate result buffer",
    "Exception happened",
    "Just serialize the head",
    "Exception happened",
    "runningContext.printToken();",
    "Reset the response and allocate buffer again",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "TODO",
    "context.getPS2PSPusher().put(request, in, partLoc);",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "TODO",
    "return ServerState.GENERAL;",
    "Use Epoll for linux",
    "public String uuid;",
    "TODO:",
    "part = new ServerPartition();",
    "TODO:",
    "public void setChannelPool(GenericObjectPool<Channel> channelPool) {",
    "this.channelPool = channelPool;",
    "}",
    "private final ParameterServer psServer;",
    "Create and start workers",
    "Set workers",
    "Create and start workers",
    "Set workers",
    "If matrix checkpoint path not exist, just return null",
    "Return the path with maximum checkpoint id",
    "Rename temp to item path",
    "Checkpoint base path = Base dir/matrix name",
    "Path for this checkpoint",
    "Generate tmp path",
    "Delete old checkpoints",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// network io method, for model transform",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Serailize the head",
    "Serialize the storage",
    "Deserailze the head",
    "Deseralize the storage",
    "Serailize the head",
    "Serialize the storage",
    "Deserailze the head",
    "Deseralize the storage",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Notice: Basic type ServerRow only support Vector as inner storage now, so you can use methods",
    "to get inner vector for basic type ServerRow.",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "TODO: just check the value is 0 or not now",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "Use sparse storage method, as some elements in the array maybe null",
    "Array length",
    "Valid element number",
    "Element data",
    "Array len",
    "Valid element number",
    "Use sparse storage method, as some elements in the array maybe null",
    "Array length",
    "Valid element number",
    "Element data",
    "Element data",
    "Array len",
    "Valid element number",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Row type",
    "Storage method",
    "Key type",
    "Value type",
    "Vector dim",
    "Vector length",
    "Vector data",
    "Row type",
    "Storage method",
    "Key type",
    "Value type",
    "Vector dim",
    "Vector length",
    "Init the vector",
    "Vector data",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "private final List<PartitionKey> partitionKeys;",
    "Get server partition class",
    "If partition class is not set, just use the default partition class",
    "Get server partition storage class type",
    "Get value class",
    "if col == -1, we use the start/end index to calculate range,",
    "we use double to store the range value since two long minus might exceed the",
    "range of long.",
    "Serialize the head",
    "Serialize the storage",
    "Deserialize the head",
    "Deseralize the storage",
    "Row base partition",
    "If storage class is not set, use default DenseServerRowsStorage",
    "Serialize values",
    "Deserialize values",
    "Array size",
    "Actual write size",
    "Rows data",
    "Row id",
    "Row type",
    "Row data",
    "Array size",
    "Actual write row number",
    "Rows data",
    "Row id",
    "Create empty server row",
    "Row data",
    "Rows data",
    "TODO",
    "Serialize row offsets",
    "Serialize column offsets",
    "Deserialize row offset",
    "Deserialize row offset",
    "If storage is set, just get a instance",
    "If storage is not set, use default",
    "If storage is set, just get a instance",
    "If storage is not set, use default",
    "Map size",
    "Actual write size",
    "Rows data",
    "Row id",
    "Row type",
    "Row data",
    "Array size",
    "Actual write row number",
    "Rows data",
    "Row id",
    "Create empty server row",
    "Row data",
    "Rows data",
    "Use Epoll for linux",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "First check the state of the channels in the pool, if a channel is unused, just return",
    "If all channels are in use, create a new channel or wait",
    "Create a new channel",
    "add the PSAgentContext,need fix",
    "If col == -1 and start/end not set",
    "start/end set",
    "for dense type, we need to set the colNum to set dim for vectors",
    "colNum set, start/end not set",
    "Row number must > 0",
    "both set, check its valid",
    "TODO:add more vector type",
    "TODO : subDim set",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Split updates",
    "Shuffle update splits",
    "Generate part update parameters",
    "Set split context: partition key, use int key for long key vector or not ect",
    "write the max abs",
    "get configuration from envs",
    "get master location",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "add dense double matrix",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "true, false",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Kubernetes Configs.",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "Start PS",
    "Start to run application",
    "Init node neighbors",
    "client.asyncUpdate(new InitNeighborOver(new InitNeighborOverParam(matrixId))).get();",
    "Sample the neighbors",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setValidIndexNum(100);",
    "siMat.setColNum(10000000000L);",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "Start PS",
    "Start to run application",
    "Init node neighbors and feats",
    "Sample the neighbors",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "Start PS",
    "Start to run application",
    "Init node neighbors",
    "Sample the neighbors",
    "sample continuously beginning from a random index",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "Get node neighbor number",
    "If the neighbor number is 0, just return a int[0]",
    "If count <= 0 or the neighbor number is less or equal then count, just copy all neighbors to the result array",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "Store the total neighbor number of all nodes in rowOffsets",
    "Put the node ids, node neighbor number, node neighbors to the cache",
    "No data in this partition",
    "Get total neighbor number",
    "Final matrix column indices: neighbors node ids",
    "Write positions in cloumnIndices for nodes",
    "Copy all cached sub column indices to final column indices",
    "Read position for a sub column indices",
    "Copy column indices for a node to final column indices",
    "Update write position for this node in final column indices",
    "Update the read position in sub column indices",
    "Clear all temp data",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Set training data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model type",
    "String modelType = String.valueOf(RowType.T_FLOAT_DENSE);",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.set(AngelMLConf.ML_MODEL_TYPE(), modelType);",
    "conf.setDouble(AngelMLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "Data format, libsvm or dummy",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set data format",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.setStrings(AngelConf.ANGEL_ML_CONF, jsonFile);",
    "Set log path",
    "Set trainning data path",
    "Set save model path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "String savePath = LOCAL_FS + TMP_PATH + \"/model/wideDeep\";",
    "Set save model path",
    "Set log path",
    "predictTest();",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set training data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "String savePath = LOCAL_FS + TMP_PATH + \"/model/wideDeep\";",
    "Set save model path",
    "Set log path",
    "predictTest();",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "String savePath = LOCAL_FS + TMP_PATH + \"/model/wideDeep\";",
    "Set save model path",
    "Set log path",
    "predictTest();",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Model type",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "conf.setDouble(MLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "conf.setStrings(AngelConf.ANGEL_ML_CONF, jsonFile);",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log save path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set testing data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "incTrain();",
    "predictTest();",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "loss delta",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Model type",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.setStrings(AngelConf.ANGEL_ML_CONF, jsonFile);",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "TODO: optimize int key indices",
    "System.out.println(\"deserialize cols.length=\" + nCols);",
    "System.out.print(\"deserialize \");",
    "System.out.print(cols[c] + \" \");",
    "System.out.println();",
    "TODO Auto-generated method stub",
    "LOG.info(\"original float length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"original double length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"parsed float length: \" + length + Arrays.toString(arr));",
    "LOG.info(\"parsed double length: \" + length + Arrays.toString(arr));",
    "start row index for words",
    "start row index for docs",
    "doc ids",
    "topic assignments",
    "word to docs reverse index",
    "count word",
    "build word start index",
    "build word to doc reverse idx",
    "build dks",
    "dks = new TraverseHashMap[n_docs];",
    "for (int d = 0; d < n_docs; d++) {",
    "if (K < Short.MAX_VALUE) {",
    "if (docs.get(d).len < Byte.MAX_VALUE)",
    "dks[d] = new S2BTraverseMap(docs.get(d).len);",
    "if (docs.get(d).len < Short.MAX_VALUE)",
    "dks[d] = new S2STraverseMap(Math.min(K, docs.get(d).len));",
    "else",
    "dks[d] = new S2ITraverseMap(Math.min(K, docs.get(d).len));",
    "} else {",
    "dks[d] = new I2ITranverseMap(Math.min(K, docs.get(d).len));",
    "}",
    "}",
    "build dks",
    "allocate update maps",
    "Skip if no token for this word",
    "Check whether error when fetching word-topic",
    "Build FTree for current word",
    "current doc",
    "old topic assignment",
    "Check if error happens. if this happen, it's probably that failures happen to servers.",
    "We need to adjust the memory settings or network fetching parameters.",
    "Update statistics if needed",
    "Calculate psum and sample new topic",
    "Update statistics if needed",
    "Assign new topic",
    "Skip if no token for this word",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "calculate columns",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "node's end index in instancePos, instances in [start, end] belong to a tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "this.forest[this.currentTree].fset = sampleFeatureVector.getStorage().getValues();",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "1. decide nodes that should be calculated",
    "2. decide calculated and subtracted tree nodes",
    "3. calculate threads",
    "wait until all threads finish",
    "4. subtract threads",
    "wait until all threads finish",
    "5. send histograms to PS",
    "6. update histogram cache",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "this.phase = GBDTPhase.AFTER_SPLIT;",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "update local replica",
    "create AfterSplit task",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current depth",
    "finish current tree",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "1. update predictions of training data",
    "2. update predictions of validation data",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "if not -1, sufficient space will be allocated at once",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fSet, fid);",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "assert fvalue >= sketch[start] && fvalue <= sketch[end];",
    "if (left > end) return end - start;",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "max and min of each feature",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = (int) row.getStartCol();",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "Release-2.3.0": [
    "@maxIndex: this variable contains the max index of node/word",
    "values[b + offset] = (random.nextFloat() - 0.5f) / dimension;",
    "some params",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "window size",
    "Skip-Gram model",
    "Accumulate the input vectors from context",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "window size",
    "skip-gram model",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "some params",
    "batch sentences",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "locates the input vectors to local array to prevent randomly access",
    "on the large server row.",
    "fill 0 for context vector",
    "window size",
    "Continuous bag-of-words Models",
    "Accumulate the input vectors from context",
    "Calculate the partial dot values",
    "We should guarantee here that the sample would not equal the ``word``",
    "used to accumulate the context input vectors",
    "locates the input vector into local arrays to prevent randomly access for",
    "the large server row.",
    "window size",
    "while true to prevent sampling out a positive target",
    "how to prevent the randomly access to the output vectors??",
    "accumulate gradients for the input vectors",
    "update output vectors",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "// calculate bias",
    "if (param.getPartKey().getStartCol() <= 0 && param.getPartKey().getEndCol() > 0) {",
    "double zVal = VectorUtils.getDouble(z, 0);",
    "double nVal = VectorUtils.getDouble(n, 0);",
    "VectorUtils.setFloat(w, 0, (float) (-1.0 * alpha * zVal / (beta + Math.sqrt(nVal))));",
    "}",
    "Do nothing.",
    "split updates",
    "shuffle update splits",
    "generate part update splits",
    "set split context: partition key, use int key for long key vector or net",
    "how to do intersection for two dense vector with a given indices ??",
    "current word",
    "neu1 stores the average value of input vectors in the context (CBOW)",
    "Continuous Bag-of-Words Model",
    "Accumulate the input vectors from context",
    "negative sampling",
    "Using the sigmoid value from the pre-computed table",
    "accumulate for the hidden layer",
    "update output layer",
    "add the counter for target",
    "update hidden layer",
    "Update the input vector for each word in the context",
    "add the counter to input",
    "update input layers",
    "update output layers",
    "for (int a = 0; a < layers.length; a++) deltas[a] = layers[a] - deltas[a];",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "if not -1, sufficient space will be allocated at once",
    "InstanceRow ins = instanceRows[insId];",
    "int[] indices = ins.indices();",
    "int[] bins = ins.bins();",
    "int nnz = indices.length;",
    "for (int j = 0; j < nnz; j++) {",
    "int fid = indices[j];",
    "if (isFeatUsed[fid - featLo]) {",
    "histograms[fid - featLo].accumulate(bins[j], gradPairs[insId]);",
    "}",
    "}",
    "1. allocate histogram",
    "2. loop non-zero instances, accumulate to histogram",
    "if (nnz <= nodeEnd - nodeStart + 1) { // loop all nnz of current feature",
    "3. add remaining grad and hess to default bin",
    "return param.calcWeights(grad, hess);",
    "numClass is usually small, so we do not use arraycopy here",
    "numClass is usually small, so we do not use arraycopy here",
    "TODO: use more schema on default bin",
    "1. set default bin to left child",
    "2. for other bins, find its location",
    "3. create split set",
    "this.nodeStats = new GBTNodeStat[numClass == 2 ? 1 : numClass];",
    "predict sparse instance with indices and values",
    "predict libsvm data",
    "Preconditions.checkArgument(preds.length == labels.length,",
    "\"LogLossMetric should be used for binary-label classification\");",
    "double loss = 0.0;",
    "for (int i = 0; i < preds.length; i++) {",
    "loss += evalOne(preds[i], labels[i]);",
    "}",
    "return loss / labels.length;",
    "double error = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "error += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "error += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return error / labels.length;",
    "Preconditions.checkArgument(preds.length != labels.length",
    "&& preds.length % labels.length == 0,",
    "\"CrossEntropyMetric should be used for multi-label classification\");",
    "double loss = 0.0;",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "loss += evalOne(pred, labels[i]);",
    "}",
    "return loss / labels.length;",
    "double correct = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "correct += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "correct += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return (float) (correct / labels.length);",
    "double errSum = 0.0f;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "errSum += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "errSum += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return Math.sqrt(errSum / labels.length);",
    "System.out.println(\"----------\");",
    "System.out.println(\"read buffer = \" + Integer.toBinaryString(readBufferT & 0b11111111)",
    "+ \", mask = \" + Integer.toBinaryString(readMaskT));",
    "readMaskT <<= 1;",
    "boolean[] bits = new boolean[]{true, true, false, false, true, false, false, false, true, true, false, true};",
    "int n = bits.length;",
    "BufferedBitSet writeBitSet = new BufferedBitSet(n);",
    "BufferedBitSet readBitSet = new BufferedBitSet(writeBitSet.getBytes(), n);",
    "if (bitSet.get(i) != bits[i]) {",
    "throw new RuntimeException(\"\" + i);",
    "}",
    "private final ByteBuffer bytes;",
    "public BufferedBitSetReader(ByteBuffer bytes, int numBits) {",
    "int capacity = bytes.capacity() * 8;",
    "readIndexT = bytes.capacity() - 1;",
    "return bytes.get(index);",
    "TODO: use arraycopy to make it faster",
    "assert from >= this.from && to <= this.to;",
    "LOG.debug(String.format(\"Create subset: [%d-%d]\", newFrom, newTo));",
    "LOG.debug(String.format(\"Get overlap: [%d-%d]\", newFrom, newTo));",
    "return bits.clone();",
    "private final SerializableBuffer bytes;",
    "private final ByteBuffer bytes;",
    "this.bytes = ByteBuffer.allocate(numBytes);",
    "public BufferedBitSetWriter(ByteBuffer bytes) {",
    "this.bytes = bytes;",
    "}",
    "bytes.put(writeIndex++, (byte) writeBuffer);",
    "public ByteBuffer getBytes() {",
    "return bytes;",
    "}",
    "ML TreeConf",
    "GBDT TreeConf",
    "edges=[x,...] firstFlow=1 => go to right if < x and go to left if > x",
    "edges=[x,...] firstFlow=0 => go to left if < x and go to right if > x",
    "different types of tree node splits, enumerated by their complexity",
    "in order to reduce model size, we give priority to split point",
    "comparison between two split points, we give priority to lower feature index",
    "TODO: comparison between two split sets",
    "public boolean leafwise;  // true if leaf-wise training, false if level-wise training",
    "TODO: regularization",
    "TODO: regularization",
    "public float insSampleRatio;  // subsample ratio for instances",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighbor;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighborParam;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.getneighbor.GetNeighborResult;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.initneighbor.InitNeighbor;",
    "import com.tencent.angel.ml.matrix.psf.graph.adjacency.initneighbor.InitNeighborParam;",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "@Test",
    "public void testInitAndGet() throws ExecutionException, InterruptedException {",
    "Worker worker = LocalClusterContext.get().getWorker(worker0Attempt0Id).getWorker();",
    "MatrixClient client1 = worker.getPSAgent().getMatrixClient(\"w2\", 0);",
    "int matrixW1Id = client1.getMatrixId();",
    "// Generate graph data",
    "Map<Integer, int []> adjMap = generateAdjTable(nodeNum, maxNeighborNum);",
    "",
    "// Init graph adj table",
    "InitNeighbor func = new InitNeighbor(new InitNeighborParam(matrixW1Id, adjMap));",
    "client1.update(func);",
    "",
    "int [] nodeIds = new int[adjMap.size()];",
    "int i = 0;",
    "for(int nodeId : adjMap.keySet()) {",
    "nodeIds[i++] = nodeId;",
    "}",
    "",
    "// Get graph adj table from PS",
    "GetNeighbor getFunc = new GetNeighbor(new GetNeighborParam(matrixW1Id, nodeIds, maxNeighborNum));",
    "Map<Integer, int[]> getResults = ((GetNeighborResult) (client1.get(getFunc)))",
    ".getNodeIdToNeighborIndices();",
    "",
    "// Check the result",
    "for(Entry<Integer, int[]> entry : getResults.entrySet()) {",
    "Assert.assertArrayEquals(entry.getValue(), adjMap.get(entry.getKey()));",
    "}",
    "}",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "QSLRRunner runner = new QSLRRunner();",
    "runner.train(conf);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Dataset",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Softmax algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DeepFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Model type",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set WideAndDeep algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Set LDA parameters #V, #K",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set LDA algorithm parameters",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set SVM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "testSparseDoubleUDF();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "testSparseDoubleUDF();",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add comp dense double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleUDF();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "LOG.info(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntFloatVector row = (IntFloatVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntLongVector row = (IntLongVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setPartitionClass(CSRPartition.class);",
    "siMat.setPartitionStorageClass(IntCSRStorage.class);",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "MatrixContext siMat = new MatrixContext();",
    "siMat.setName(SPARSE_INT_MAT);",
    "siMat.setRowType(RowType.T_ANY_INTKEY_SPARSE);",
    "siMat.setRowNum(1);",
    "siMat.setValidIndexNum(100);",
    "siMat.setColNum(10000000000L);",
    "siMat.setValueType(Node.class);",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "angelClient.addMatrix(siMat);",
    "add sparse long-key double matrix",
    "Start PS",
    "Start to run application",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "https://blog.csdn.net/cocoonyang/article/details/63068108",
    "v1[i] = v1[i] + da * v2[i];",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "v1[i] = v1[i] + da * v2[i];",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "all the files in input set",
    "Shuffle the file",
    "Get the blocks for all files",
    "Adjust the maxSize to make the split more balanced",
    "Handle the splittable files",
    "Handle the unsplittable files",
    "Split the blocks",
    "If the remaining size of the current block is smaller than the required size,",
    "the remaining blocks are divided into the current split",
    "Update current split length and move to next block",
    "Clear the current block offset",
    "Current split length is > maxSize, split the block and generate a new split",
    "Clear blocks list for next split",
    "Clear the current split length",
    "If splitBlocks is not empty, just genetate a split for it",
    "get block locations from file system",
    "create an input split",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "Check is there save request",
    "LOG.info(\"PS \" + psAttemptId + \" need save \" + subSaveContext);",
    "Check is there load request",
    "LOG.info(\"PS \" + psAttemptId + \" need load \" + subLoadContext);",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "LOG.info(\"error happened in psAttempt \" + psAttemptId + \" error msg=\" + request.getMsg());",
    "remove this parameter server attempt from monitor set",
    "LOG.info(\"Epoch=\" + epoch + \" Metrics=\" + metrics);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Path tmpPath = new Path(new Path(context.getConf().get(AngelConf.ANGEL_JOB_TMP_OUTPUT_PATH)),",
    "String.valueOf(requestId));",
    "Path tmpPath = HdfsUtil.toTmpPath(new Path(saveContext.getSavePath()));",
    "saveContext.setTmpSavePath(tmpPath.toString());",
    "Filter old epoch trigger first",
    "Split the user request to sub-requests to pss",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Split the user request to sub-requests to pss",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "G1 params",
    ".append(\" -XX:G1NewSizePercent=\").append(minNewRatio)",
    ".append(\" -XX:G1MaxNewSizePercent=\").append(maxNewRatio)",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "G1 params",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "restartPS(psLoc);",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and EXECUTE_SUCCESSED, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run or run over",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnException or YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Add one sync matrix",
    "addSyncMatrix();",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "for(Entry<ParameterServerId, Map<Integer, MatrixMeta>> psEntry : matrixPartitionsOnPS.entrySet()) {",
    "LOG.info(\"ps id = \" + psEntry.getKey());",
    "Map<Integer, MatrixMeta> matrixIdToMetaMap = psEntry.getValue();",
    "for(Entry<Integer, MatrixMeta> metaEntry : matrixIdToMetaMap.entrySet()) {",
    "LOG.info(\"matrix id = \" + metaEntry.getKey());",
    "LOG.info(\"matrix partitons number = \" + metaEntry.getValue().getPartitionMetas().size());",
    "}",
    "}",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "clock first",
    "wait",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Plus a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Update a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get values from pss use row/column indices",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ PSF get/update, use can implement their own psf",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get a row or a batch of rows",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Just return",
    "Just return",
    "Just return",
    "Just return",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "Sort the partitions by start column index",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "Doing average or not",
    "Filter un-important update",
    "Split this row according the matrix partitions",
    "Set split context",
    "Remove the row from matrix",
    "buf.writeDouble(0.0);",
    "TODO:",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.error(\"channel \" + ctx.channel() + \" inactive\");",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "LOG.error(\"put response message queue failed \", e);",
    "Use Epoll for linux",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "getPSState(entry.getKey());",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "private Channel getChannel(Location loc) throws Exception {",
    "return channelManager.getOrCreateChannel(new Location(loc.getIp(), loc.getPort() + 1));",
    "}",
    "private GenericObjectPool<Channel> getChannelPool(Location loc) throws InterruptedException {",
    "return channelManager.getOrCreateChannelPool(new Location(loc.getIp(), loc.getPort() + 1), PSAgentContext",
    ".get()",
    ".getConf()",
    ".getInt(AngelConf.ANGEL_WORKER_TASK_NUMBER,",
    "AngelConf.DEFAULT_ANGEL_WORKER_TASK_NUMBER));",
    "}",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "request.getContext().setChannelPool(pool);",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "updateMatrixCache(request.getPartKey(), response.getPartition());",
    "updateMatrixCache(request.getPartKey(), response.getRowsSplit());",
    "TODO",
    "ServerRow rowSplit = PSAgentContext.get().getMatricesCache()",
    ".getRowSplit(request.getPartKey().getMatrixId(), request.getPartKey(),",
    "request.getRowIndex());",
    "response.setRowSplit(rowSplit);",
    "updateMatrixCache(request.getPartKey(), response.getRowSplit());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "TODO",
    "private void updateMatrixCache(PartitionKey partKey, ServerPartition partition) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, partition);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, ServerRow rowSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowSplit);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, List<ServerRow> rowsSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowsSplit);",
    "}",
    "Get partitions for this row",
    "Distinct get row requests",
    "Get row splits of this row from the matrix cache first",
    "responseCache.addSubResponse(rowSplit);",
    "If the row split does not exist in cache, get it from parameter server",
    "Split the param use matrix partitions",
    "Send request to PSS",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Send request to PSS",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "LOG.info(\"get row split use time=\" + (System.currentTimeMillis() - startTs));",
    "LOG.info(\"start to request \" + requestId);",
    "LOG.info(\"start to request \" + requestId);",
    "Split param use matrix partitons",
    "If all sub-results are received, just remove request and result cache",
    "Split this row according the matrix partitions",
    "Set split context",
    "Split this row according the matrix partitions",
    "Set split context",
    "long startTs = System.currentTimeMillis();",
    "LOG.error(\"combine use time = \" + (System.currentTimeMillis() - startTs));",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO: ServerLongDoubleRow maybe use IntDoubleVector as inner storage",
    "TODO",
    "TODO",
    "/////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO",
    "buf.writeDouble(0);",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Now we just support pipelined row splits merging for dense type row",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "Read matrix meta from meta file",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "matrix.startServering();",
    "return;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Read matrix meta from meta file",
    "Sort partitions",
    "TODO:",
    "int size = rows.length;",
    "int size = rows.length;",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "return Objects.toStringHelper(this).add(\"serial\", serial).add(\"listSize\", datas.size())",
    ".toString();",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load ml conf file for graph based algorithm",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "If out path exist , just remove it first",
    "Create parent directory if not exist",
    "Rename",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "throw new AngelException(e);",
    "JobStateProto jobState = report.getJobState();",
    "Check need load matrices",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "load user job resource files",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "private volatile PS2PSPusherImpl ps2PSPusher;",
    "TODO",
    "Add tokens to new user so that it may execute its task correctly.",
    "TODO",
    "to exit",
    "TODO",
    "TODO",
    "ps2PSPusher.recover(ProtobufUtil.convert(needRecoverParts.get(i)));",
    "context.getSnapshotManager().processRecovery();",
    "Recover PS from snapshot or load path",
    "1. First check old snapshot",
    "2. Check new checkpoints",
    "3. Check load path setting and old save result",
    "Just init it again",
    "TODO",
    "if(ps2PSPusher != null) {",
    "ps2PSPusher.start();",
    "}",
    "public PS2PSPusherImpl getPs2PSPusher() {",
    "return ps2PSPusher;",
    "}",
    "LOG.error(\"send response of request \" + requestToString(clientId, seqId) + \" failed \");",
    "LOG.error(\"send response of request failed, request seqId=\" + seqId + \", channel=\" + ch, ex);",
    "Release the input buffer",
    "Release the input buffer",
    "1. handle the rpc, get the response",
    "Release the input buffer",
    "2. Serialize the response",
    "Send the serialized response",
    "Exception happened",
    "write seq id",
    "Just serialize the head",
    "Exception happened",
    "Allocate result buffer",
    "Exception happened",
    "Just serialize the head",
    "Exception happened",
    "runningContext.printToken();",
    "Reset the response and allocate buffer again",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "TODO",
    "context.getPS2PSPusher().put(request, in, partLoc);",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "TODO",
    "return ServerState.GENERAL;",
    "Use Epoll for linux",
    "public String uuid;",
    "TODO:",
    "part = new ServerPartition();",
    "TODO:",
    "public void setChannelPool(GenericObjectPool<Channel> channelPool) {",
    "this.channelPool = channelPool;",
    "}",
    "private final ParameterServer psServer;",
    "Create and start workers",
    "Set workers",
    "Create and start workers",
    "Set workers",
    "If matrix checkpoint path not exist, just return null",
    "Return the path with maximum checkpoint id",
    "Rename temp to item path",
    "Checkpoint base path = Base dir/matrix name",
    "Path for this checkpoint",
    "Generate tmp path",
    "Delete old checkpoints",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// network io method, for model transform",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Serailize the head",
    "Serialize the storage",
    "Deserailze the head",
    "Deseralize the storage",
    "Serailize the head",
    "Serialize the storage",
    "Deserailze the head",
    "Deseralize the storage",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Notice: Basic type ServerRow only support Vector as inner storage now, so you can use methods",
    "to get inner vector for basic type ServerRow.",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "TODO: just check the value is 0 or not now",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "Use sparse storage method, as some elements in the array maybe null",
    "Array length",
    "Valid element number",
    "Element data",
    "Array len",
    "Valid element number",
    "Use sparse storage method, as some elements in the array maybe null",
    "Array length",
    "Valid element number",
    "Element data",
    "Element data",
    "Array len",
    "Valid element number",
    "Attention: Only update the exist values for sorted storage method",
    "Attention: Only update exist element",
    "TODO: just check the value is zero or not now",
    "SPARSE and SORT, check index exist or not, When using SORT mode storage, the search efficiency is very low.",
    "Row type",
    "Storage method",
    "Key type",
    "Value type",
    "Vector dim",
    "Vector length",
    "Vector data",
    "Row type",
    "Storage method",
    "Key type",
    "Value type",
    "Vector dim",
    "Vector length",
    "Init the vector",
    "Vector data",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "Sparse storage, use the iterator to avoid array copy",
    "Get the array pair",
    "Impossible now",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "If use sorted storage, we should get the array pair first",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "Just update the exist element now!!",
    "Just update the exist element now!!",
    "TODO: just check the value is 0 or not now",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "Element data",
    "Valid element number",
    "Element data",
    "Valid element number",
    "Deserialize the data",
    "private final List<PartitionKey> partitionKeys;",
    "Get server partition class",
    "If partition class is not set, just use the default partition class",
    "Get server partition storage class type",
    "Get value class",
    "if col == -1, we use the start/end index to calculate range,",
    "we use double to store the range value since two long minus might exceed the",
    "range of long.",
    "Serialize the head",
    "Serialize the storage",
    "Deserialize the head",
    "Deseralize the storage",
    "Row base partition",
    "If storage class is not set, use default DenseServerRowsStorage",
    "Serialize values",
    "Deserialize values",
    "Array size",
    "Actual write size",
    "Rows data",
    "Row id",
    "Row type",
    "Row data",
    "Array size",
    "Actual write row number",
    "Rows data",
    "Row id",
    "Create empty server row",
    "Row data",
    "Rows data",
    "TODO",
    "Serialize row offsets",
    "Serialize column offsets",
    "Deserialize row offset",
    "Deserialize row offset",
    "If storage is set, just get a instance",
    "If storage is not set, use default",
    "If storage is set, just get a instance",
    "If storage is not set, use default",
    "Map size",
    "Actual write size",
    "Rows data",
    "Row id",
    "Row type",
    "Row data",
    "Array size",
    "Actual write row number",
    "Rows data",
    "Row id",
    "Create empty server row",
    "Row data",
    "Rows data",
    "Use Epoll for linux",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "First check the state of the channels in the pool, if a channel is unused, just return",
    "If all channels are in use, create a new channel or wait",
    "Create a new channel",
    "add the PSAgentContext,need fix",
    "If col == -1 and start/end not set",
    "start/end set",
    "for dense type, we need to set the colNum to set dim for vectors",
    "colNum set, start/end not set",
    "Row number must > 0",
    "both set, check its valid",
    "public static final int T_INT_ARBITRARY_VALUE = 28;",
    "public static final int T_INVALID_VALUE = 29;",
    "TODO:add more vector type",
    "TODO : subDim set",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Split updates",
    "Shuffle update splits",
    "Generate part update parameters",
    "Set split context: partition key, use int key for long key vector or not ect",
    "write the max abs",
    "---------------------------------------------------",
    "---------------------------------------------------",
    "---------------------------------------------------------------",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "KeepStorage is guaranteed",
    "we gauss dense storage is more efficient",
    "v1Size < v2Size * Constant.sparseThreshold",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss dense storage is more efficient",
    "prevent rehash",
    "KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "dense preferred",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sorted preferred",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "dger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "sger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "add dense double matrix",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "true, false",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "Start PS",
    "Start to run application",
    "Init node neighbors",
    "client.asyncUpdate(new InitNeighborOver(new InitNeighborOverParam(matrixId))).get();",
    "Sample the neighbors",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "siMat.setValidIndexNum(100);",
    "siMat.setColNum(10000000000L);",
    "siMat.setPartitionStorageClass(LongElementMapStorage.class);",
    "siMat.setPartitionClass(CSRPartition.class);",
    "Start PS",
    "Start to run application",
    "Init node neighbors and feats",
    "Sample the neighbors",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_MODEL_PARTITIONER_PARTITION_SIZE, 1000);",
    "get a angel client",
    "add sparse float matrix",
    "Start PS",
    "Start to run application",
    "Init node neighbors",
    "Sample the neighbors",
    "sample continuously beginning from a random index",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "Get node neighbor number",
    "If the neighbor number is 0, just return a int[0]",
    "If count <= 0 or the neighbor number is less or equal then count, just copy all neighbors to the result array",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "System.out.println(\"serialize size=\" + (endIndex - startIndex));",
    "System.out.println(\"deserialize size=\" + nodesToNeighbors.size());",
    "Store the total neighbor number of all nodes in rowOffsets",
    "Put the node ids, node neighbor number, node neighbors to the cache",
    "No data in this partition",
    "Get total neighbor number",
    "Final matrix column indices: neighbors node ids",
    "Write positions in cloumnIndices for nodes",
    "Copy all cached sub column indices to final column indices",
    "Read position for a sub column indices",
    "Copy column indices for a node to final column indices",
    "Update write position for this node in final column indices",
    "Update the read position in sub column indices",
    "Clear all temp data",
    "Get node neighbor number",
    "If the neighbor number > count, just copy a range of neighbors to the result array, the copy position is random",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Set training data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model type",
    "String modelType = String.valueOf(RowType.T_FLOAT_DENSE);",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.set(MLConf.ML_MODEL_TYPE(), modelType);",
    "conf.setDouble(MLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "predictTest();",
    "Data format, libsvm or dummy",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set data format",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set log path",
    "Set trainning data path",
    "Set save model path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set training data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log save path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set testing data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "loss delta",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "TODO: optimize int key indices",
    "System.out.println(\"deserialize cols.length=\" + nCols);",
    "System.out.print(\"deserialize \");",
    "System.out.print(cols[c] + \" \");",
    "System.out.println();",
    "TODO Auto-generated method stub",
    "LOG.info(\"original float length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"original double length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"parsed float length: \" + length + Arrays.toString(arr));",
    "LOG.info(\"parsed double length: \" + length + Arrays.toString(arr));",
    "ground truth: positive, precision: positive",
    "start row index for words",
    "start row index for docs",
    "doc ids",
    "topic assignments",
    "word to docs reverse index",
    "count word",
    "build word start index",
    "build word to doc reverse idx",
    "build dks",
    "dks = new TraverseHashMap[n_docs];",
    "for (int d = 0; d < n_docs; d++) {",
    "if (K < Short.MAX_VALUE) {",
    "if (docs.get(d).len < Byte.MAX_VALUE)",
    "dks[d] = new S2BTraverseMap(docs.get(d).len);",
    "if (docs.get(d).len < Short.MAX_VALUE)",
    "dks[d] = new S2STraverseMap(Math.min(K, docs.get(d).len));",
    "else",
    "dks[d] = new S2ITraverseMap(Math.min(K, docs.get(d).len));",
    "} else {",
    "dks[d] = new I2ITranverseMap(Math.min(K, docs.get(d).len));",
    "}",
    "}",
    "build dks",
    "allocate update maps",
    "Skip if no token for this word",
    "Check whether error when fetching word-topic",
    "Build FTree for current word",
    "current doc",
    "old topic assignment",
    "Check if error happens. if this happen, it's probably that failures happen to servers.",
    "We need to adjust the memory settings or network fetching parameters.",
    "Update statistics if needed",
    "Calculate psum and sample new topic",
    "Update statistics if needed",
    "Assign new topic",
    "Skip if no token for this word",
    "if (u >= p[end]) {",
    "System.out.println(\"u=\" + u + \" p[end]=\" + p[end] + \" start=\" + start + \" end=\" + end);",
    "return end;",
    "}",
    "",
    "if (u < p[start]) {",
    "System.out.println(\"u=\" + u + \" p[start]=\" + p[start] + \" start=\" + start + \" end=\" + end);",
    "return start;",
    "}",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "calculate columns",
    "reset(row);",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "node's end index in instancePos, instances in [start, end] belong to a tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "this.forest[this.currentTree].fset = sampleFeatureVector.getStorage().getValues();",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "1. decide nodes that should be calculated",
    "2. decide calculated and subtracted tree nodes",
    "3. calculate threads",
    "wait until all threads finish",
    "4. subtract threads",
    "wait until all threads finish",
    "5. send histograms to PS",
    "6. update histogram cache",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "this.phase = GBDTPhase.AFTER_SPLIT;",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "update local replica",
    "create AfterSplit task",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current depth",
    "finish current tree",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "1. update predictions of training data",
    "2. update predictions of validation data",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "if not -1, sufficient space will be allocated at once",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fSet, fid);",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "assert fvalue >= sketch[start] && fvalue <= sketch[end];",
    "if (left > end) return end - start;",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "max and min of each feature",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = (int) row.getStartCol();",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "Release-2.2.0": [
    "@maxIndex: this variable contains the max index of node/word",
    "values[b + offset] = (random.nextFloat() - 0.5f) / dimension;",
    "some params",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "window size",
    "Skip-Gram model",
    "Accumulate the input vectors from context",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "window size",
    "skip-gram model",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "some params",
    "batch sentences",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "locates the input vectors to local array to prevent randomly access",
    "on the large server row.",
    "fill 0 for context vector",
    "window size",
    "Continuous bag-of-words Models",
    "Accumulate the input vectors from context",
    "Calculate the partial dot values",
    "We should guarantee here that the sample would not equal the ``word``",
    "used to accumulate the context input vectors",
    "locates the input vector into local arrays to prevent randomly access for",
    "the large server row.",
    "window size",
    "while true to prevent sampling out a positive target",
    "how to prevent the randomly access to the output vectors??",
    "accumulate gradients for the input vectors",
    "update output vectors",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "// calculate bias",
    "if (param.getPartKey().getStartCol() <= 0 && param.getPartKey().getEndCol() > 0) {",
    "double zVal = VectorUtils.getDouble(z, 0);",
    "double nVal = VectorUtils.getDouble(n, 0);",
    "VectorUtils.setFloat(w, 0, (float) (-1.0 * alpha * zVal / (beta + Math.sqrt(nVal))));",
    "}",
    "Do nothing.",
    "current word",
    "neu1 stores the average value of input vectors in the context (CBOW)",
    "Continuous Bag-of-Words Model",
    "Accumulate the input vectors from context",
    "negative sampling",
    "Using the sigmoid value from the pre-computed table",
    "accumulate for the hidden layer",
    "update output layer",
    "add the counter for target",
    "update hidden layer",
    "Update the input vector for each word in the context",
    "add the counter to input",
    "update input layers",
    "update output layers",
    "for (int a = 0; a < layers.length; a++) deltas[a] = layers[a] - deltas[a];",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "if not -1, sufficient space will be allocated at once",
    "InstanceRow ins = instanceRows[insId];",
    "int[] indices = ins.indices();",
    "int[] bins = ins.bins();",
    "int nnz = indices.length;",
    "for (int j = 0; j < nnz; j++) {",
    "int fid = indices[j];",
    "if (isFeatUsed[fid - featLo]) {",
    "histograms[fid - featLo].accumulate(bins[j], gradPairs[insId]);",
    "}",
    "}",
    "1. allocate histogram",
    "2. loop non-zero instances, accumulate to histogram",
    "if (nnz <= nodeEnd - nodeStart + 1) { // loop all nnz of current feature",
    "3. add remaining grad and hess to default bin",
    "return param.calcWeights(grad, hess);",
    "numClass is usually small, so we do not use arraycopy here",
    "numClass is usually small, so we do not use arraycopy here",
    "TODO: use more schema on default bin",
    "1. set default bin to left child",
    "2. for other bins, find its location",
    "3. create split set",
    "this.nodeStats = new GBTNodeStat[numClass == 2 ? 1 : numClass];",
    "predict sparse instance with indices and values",
    "predict libsvm data",
    "Preconditions.checkArgument(preds.length == labels.length,",
    "\"LogLossMetric should be used for binary-label classification\");",
    "double loss = 0.0;",
    "for (int i = 0; i < preds.length; i++) {",
    "loss += evalOne(preds[i], labels[i]);",
    "}",
    "return loss / labels.length;",
    "double error = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "error += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "error += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return error / labels.length;",
    "Preconditions.checkArgument(preds.length != labels.length",
    "&& preds.length % labels.length == 0,",
    "\"CrossEntropyMetric should be used for multi-label classification\");",
    "double loss = 0.0;",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "loss += evalOne(pred, labels[i]);",
    "}",
    "return loss / labels.length;",
    "double correct = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "correct += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "correct += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return (float) (correct / labels.length);",
    "double errSum = 0.0f;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "errSum += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "errSum += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return Math.sqrt(errSum / labels.length);",
    "System.out.println(\"----------\");",
    "System.out.println(\"read buffer = \" + Integer.toBinaryString(readBufferT & 0b11111111)",
    "+ \", mask = \" + Integer.toBinaryString(readMaskT));",
    "readMaskT <<= 1;",
    "boolean[] bits = new boolean[]{true, true, false, false, true, false, false, false, true, true, false, true};",
    "int n = bits.length;",
    "BufferedBitSet writeBitSet = new BufferedBitSet(n);",
    "BufferedBitSet readBitSet = new BufferedBitSet(writeBitSet.getBytes(), n);",
    "if (bitSet.get(i) != bits[i]) {",
    "throw new RuntimeException(\"\" + i);",
    "}",
    "private final ByteBuffer bytes;",
    "public BufferedBitSetReader(ByteBuffer bytes, int numBits) {",
    "int capacity = bytes.capacity() * 8;",
    "readIndexT = bytes.capacity() - 1;",
    "return bytes.get(index);",
    "TODO: use arraycopy to make it faster",
    "assert from >= this.from && to <= this.to;",
    "LOG.debug(String.format(\"Create subset: [%d-%d]\", newFrom, newTo));",
    "LOG.debug(String.format(\"Get overlap: [%d-%d]\", newFrom, newTo));",
    "return bits.clone();",
    "private final SerializableBuffer bytes;",
    "private final ByteBuffer bytes;",
    "this.bytes = ByteBuffer.allocate(numBytes);",
    "public BufferedBitSetWriter(ByteBuffer bytes) {",
    "this.bytes = bytes;",
    "}",
    "bytes.put(writeIndex++, (byte) writeBuffer);",
    "public ByteBuffer getBytes() {",
    "return bytes;",
    "}",
    "ML TreeConf",
    "GBDT TreeConf",
    "different types of tree node splits, enumerated by their complexity",
    "in order to reduce model size, we give priority to split point",
    "comparison between two split points, we give priority to lower feature index",
    "TODO: comparison between two split sets",
    "public boolean leafwise;  // true if leaf-wise training, false if level-wise training",
    "TODO: regularization",
    "TODO: regularization",
    "public float insSampleRatio;  // subsample ratio for instances",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "QSLRRunner runner = new QSLRRunner();",
    "runner.train(conf);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Dataset",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Softmax algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DeepFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Model type",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set WideAndDeep algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Set LDA parameters #V, #K",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set LDA algorithm parameters",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set SVM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "https://blog.csdn.net/cocoonyang/article/details/63068108",
    "v1[i] = v1[i] + da * v2[i];",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "v1[i] = v1[i] + da * v2[i];",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "all the files in input set",
    "Shuffle the file",
    "Get the blocks for all files",
    "Adjust the maxSize to make the split more balanced",
    "Handle the splittable files",
    "Handle the unsplittable files",
    "Split the blocks",
    "If the remaining size of the current block is smaller than the required size,",
    "the remaining blocks are divided into the current split",
    "Update current split length and move to next block",
    "Clear the current block offset",
    "Current split length is > maxSize, split the block and generate a new split",
    "Clear blocks list for next split",
    "Clear the current split length",
    "If splitBlocks is not empty, just genetate a split for it",
    "get block locations from file system",
    "create an input split",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "Check is there save request",
    "Check is there load request",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "LOG.info(\"Epoch=\" + epoch + \" Metrics=\" + metrics);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Path tmpPath = new Path(new Path(context.getConf().get(AngelConf.ANGEL_JOB_TMP_OUTPUT_PATH)),",
    "String.valueOf(requestId));",
    "Path tmpPath = HdfsUtil.toTmpPath(new Path(saveContext.getSavePath()));",
    "saveContext.setTmpSavePath(tmpPath.toString());",
    "Filter old epoch trigger first",
    "Split the user request to sub-requests to pss",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Split the user request to sub-requests to pss",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and EXECUTE_SUCCESSED, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run or run over",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Add one sync matrix",
    "addSyncMatrix();",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "for(Entry<ParameterServerId, Map<Integer, MatrixMeta>> psEntry : matrixPartitionsOnPS.entrySet()) {",
    "LOG.info(\"ps id = \" + psEntry.getKey());",
    "Map<Integer, MatrixMeta> matrixIdToMetaMap = psEntry.getValue();",
    "for(Entry<Integer, MatrixMeta> metaEntry : matrixIdToMetaMap.entrySet()) {",
    "LOG.info(\"matrix id = \" + metaEntry.getKey());",
    "LOG.info(\"matrix partitons number = \" + metaEntry.getValue().getPartitionMetas().size());",
    "}",
    "}",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "clock first",
    "wait",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Plus a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Update a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get values from pss use row/column indices",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ PSF get/update, use can implement their own psf",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get a row or a batch of rows",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Just return",
    "Just return",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "checkNotNull(func, \"func\");",
    "Return a empty vector",
    "TODO:",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "TODO:",
    "Doing average or not",
    "Filter un-important update",
    "Split this row according the matrix partitions",
    "Set split context",
    "Remove the row from matrix",
    "buf.writeDouble(0.0);",
    "TODO",
    "TODO: write map default value",
    "buf.writeDouble(0);",
    "TODO:",
    "TODO:",
    "TODO:",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.error(\"channel \" + ctx.channel() + \" inactive\");",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "LOG.error(\"put response message queue failed \", e);",
    "Use Epoll for linux",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "private Channel getChannel(Location loc) throws Exception {",
    "return channelManager.getOrCreateChannel(new Location(loc.getIp(), loc.getPort() + 1));",
    "}",
    "private GenericObjectPool<Channel> getChannelPool(Location loc) throws InterruptedException {",
    "return channelManager.getOrCreateChannelPool(new Location(loc.getIp(), loc.getPort() + 1), PSAgentContext",
    ".get()",
    ".getConf()",
    ".getInt(AngelConf.ANGEL_WORKER_TASK_NUMBER,",
    "AngelConf.DEFAULT_ANGEL_WORKER_TASK_NUMBER));",
    "}",
    "LOG.error(\"send request \" + request + \" is interrupted\");",
    "LOG.error(\"send request \" + request + \" failed, \", e);",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "request.getContext().setChannelPool(pool);",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "updateMatrixCache(request.getPartKey(), response.getPartition());",
    "updateMatrixCache(request.getPartKey(), response.getRowsSplit());",
    "TODO",
    "ServerRow rowSplit = PSAgentContext.get().getMatricesCache()",
    ".getRowSplit(request.getPartKey().getMatrixId(), request.getPartKey(),",
    "request.getRowIndex());",
    "response.setRowSplit(rowSplit);",
    "updateMatrixCache(request.getPartKey(), response.getRowSplit());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "TODO",
    "private void updateMatrixCache(PartitionKey partKey, ServerPartition partition) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, partition);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, ServerRow rowSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowSplit);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, List<ServerRow> rowsSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowsSplit);",
    "}",
    "Get partitions for this row",
    "Distinct get row requests",
    "Need get from ps or storage/cache",
    "Switch to new request id, send a new request",
    "First get this row from matrix storage",
    "MatrixStorage matrixStorage =",
    "PSAgentContext.get().getMatrixStorageManager().getMatrixStoage(matrixId);",
    "TVector row = matrixStorage.getRow(rowIndex);",
    "if (row != null && row.getClock() >= clock) {",
    "result.set(row);",
    "return row;",
    "}",
    "Get row splits of this row from the matrix cache first",
    "responseCache.addSubResponse(rowSplit);",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "matrixStorage.addRow(rowIndex, row);",
    "Just wait result",
    "Split the param use matrix partitions",
    "Send request to PSS",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Send request to PSS",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "LOG.info(\"get row split use time=\" + (System.currentTimeMillis() - startTs));",
    "LOG.info(\"start to request \" + requestId);",
    "LOG.info(\"start to request \" + requestId);",
    "Split param use matrix partitons",
    "If all sub-results are received, just remove request and result cache",
    "LOG.info(\"request = \" + request + \", cache = \" + cache);",
    "LOG.info(\"start to merge \" + cache + \" for request \" + request);",
    "LOG.info(\"psf get merge use time = \" + (System.currentTimeMillis() - startTs));",
    "Split this row according the matrix partitions",
    "Set split context",
    "Split this row according the matrix partitions",
    "Set split context",
    "long startTs = System.currentTimeMillis();",
    "LOG.error(\"combine use time = \" + (System.currentTimeMillis() - startTs));",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO",
    "TODO",
    "/////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO",
    "buf.writeDouble(0);",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Now we just support pipelined row splits merging for dense type row",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "Read matrix meta from meta file",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "matrix.startServering();",
    "return;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Read matrix meta from meta file",
    "Sort partitions",
    "int size = rows.length;",
    "int size = rows.length;",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "return Objects.toStringHelper(this).add(\"serial\", serial).add(\"listSize\", datas.size())",
    ".toString();",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load ml conf file for graph based algorithm",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "If out path exist , just remove it first",
    "Create parent directory if not exist",
    "Rename",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "throw new AngelException(e);",
    "JobStateProto jobState = report.getJobState();",
    "Check need load matrices",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "load user job resource files",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "private volatile PS2PSPusherImpl ps2PSPusher;",
    "TODO",
    "Add tokens to new user so that it may execute its task correctly.",
    "TODO",
    "to exit",
    "TODO",
    "TODO",
    "ps2PSPusher.recover(ProtobufUtil.convert(needRecoverParts.get(i)));",
    "context.getSnapshotManager().processRecovery();",
    "Recover PS from snapshot or load path",
    "First check snapshot",
    "Check load path setting",
    "TODO",
    "if(ps2PSPusher != null) {",
    "ps2PSPusher.start();",
    "}",
    "public PS2PSPusherImpl getPs2PSPusher() {",
    "return ps2PSPusher;",
    "}",
    "LOG.error(\"send response of request \" + requestToString(clientId, seqId) + \" failed \");",
    "LOG.error(\"send response of request failed, request seqId=\" + seqId + \", channel=\" + ch, ex);",
    "Release the input buffer",
    "Release the input buffer",
    "1. handle the rpc, get the response",
    "Release the input buffer",
    "2. Serialize the response",
    "Send the serialized response",
    "Exception happened",
    "write seq id",
    "Just serialize the head",
    "Exception happened",
    "Allocate result buffer",
    "Exception happened",
    "Just serialize the head",
    "Exception happened",
    "Reset the response and allocate buffer again",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "TODO",
    "context.getPS2PSPusher().put(request, in, partLoc);",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "TODO",
    "return ServerState.GENERAL;",
    "Use Epoll for linux",
    "public String uuid;",
    "public void setChannelPool(GenericObjectPool<Channel> channelPool) {",
    "this.channelPool = channelPool;",
    "}",
    "private final ParameterServer psServer;",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// network io method, for model transform",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "public ObjectIterator<Long2FloatMap.Entry> getIter() {",
    "return ((LongFloatVector) row).getStorage().entryIterator();",
    "}",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "public ObjectIterator<Long2LongMap.Entry> getIter() {",
    "return ((LongLongVector) row).getStorage().entryIterator();",
    "}",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO: dynamic add/delete row",
    "private final List<PartitionKey> partitionKeys;",
    "if col == -1, we use the start/end index to calculate range,",
    "we use double to store the range value since two long minus might exceed the",
    "range of long.",
    "Use Epoll for linux",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "First check the state of the channels in the pool, if a channel is unused, just return",
    "If all channels are in use, create a new channel or wait",
    "Create a new channel",
    "add the PSAgentContext,need fix",
    "If col == -1 and start/end not set",
    "start/end set",
    "for dense type, we need to set the colNum to set dim for vectors",
    "colNum set, start/end not set",
    "Row number must > 0",
    "both set, check its valid",
    "TODO:add more vector type",
    "TODO : subDim set",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "write the max abs",
    "---------------------------------------------------",
    "---------------------------------------------------",
    "---------------------------------------------------------------",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "KeepStorage is guaranteed",
    "we gauss dense storage is more efficient",
    "v1Size < v2Size * Constant.sparseThreshold",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss dense storage is more efficient",
    "prevent rehash",
    "KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "dense preferred",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sorted preferred",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "dger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "sger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "add dense double matrix",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "true, false",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Set training data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model type",
    "String modelType = String.valueOf(RowType.T_FLOAT_DENSE);",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.set(MLConf.ML_MODEL_TYPE(), modelType);",
    "conf.setDouble(MLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "predictTest();",
    "Data format, libsvm or dummy",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set data format",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set log path",
    "Set trainning data path",
    "Set save model path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set training data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log save path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set testing data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "loss delta",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "TODO: optimize int key indices",
    "System.out.println(\"deserialize cols.length=\" + nCols);",
    "System.out.print(\"deserialize \");",
    "System.out.print(cols[c] + \" \");",
    "System.out.println();",
    "TODO Auto-generated method stub",
    "LOG.info(\"original float length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"original double length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"parsed float length: \" + length + Arrays.toString(arr));",
    "LOG.info(\"parsed double length: \" + length + Arrays.toString(arr));",
    "ground truth: positive, precision: positive",
    "start row index for words",
    "start row index for docs",
    "doc ids",
    "topic assignments",
    "word to docs reverse index",
    "count word",
    "build word start index",
    "build word to doc reverse idx",
    "build dks",
    "dks = new TraverseHashMap[n_docs];",
    "for (int d = 0; d < n_docs; d++) {",
    "if (K < Short.MAX_VALUE) {",
    "if (docs.get(d).len < Byte.MAX_VALUE)",
    "dks[d] = new S2BTraverseMap(docs.get(d).len);",
    "if (docs.get(d).len < Short.MAX_VALUE)",
    "dks[d] = new S2STraverseMap(Math.min(K, docs.get(d).len));",
    "else",
    "dks[d] = new S2ITraverseMap(Math.min(K, docs.get(d).len));",
    "} else {",
    "dks[d] = new I2ITranverseMap(Math.min(K, docs.get(d).len));",
    "}",
    "}",
    "build dks",
    "allocate update maps",
    "Skip if no token for this word",
    "Check whether error when fetching word-topic",
    "Build FTree for current word",
    "current doc",
    "old topic assignment",
    "Check if error happens. if this happen, it's probably that failures happen to servers.",
    "We need to adjust the memory settings or network fetching parameters.",
    "Update statistics if needed",
    "Calculate psum and sample new topic",
    "Update statistics if needed",
    "Assign new topic",
    "Skip if no token for this word",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "calculate columns",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "node's end index in instancePos, instances in [start, end] belong to a tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "this.forest[this.currentTree].fset = sampleFeatureVector.getStorage().getValues();",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "1. decide nodes that should be calculated",
    "2. decide calculated and subtracted tree nodes",
    "3. calculate threads",
    "wait until all threads finish",
    "4. subtract threads",
    "wait until all threads finish",
    "5. send histograms to PS",
    "6. update histogram cache",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "this.phase = GBDTPhase.AFTER_SPLIT;",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "update local replica",
    "create AfterSplit task",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current depth",
    "finish current tree",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "1. update predictions of training data",
    "2. update predictions of validation data",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "if not -1, sufficient space will be allocated at once",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fSet, fid);",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "assert fvalue >= sketch[start] && fvalue <= sketch[end];",
    "if (left > end) return end - start;",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "max and min of each feature",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = (int) row.getStartCol();",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "Release-2.1.0": [
    "@maxIndex: this variable contains the max index of node/word",
    "values[b + offset] = (random.nextFloat() - 0.5f) / dimension;",
    "some params",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "window size",
    "Skip-Gram model",
    "Accumulate the input vectors from context",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "window size",
    "skip-gram model",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "some params",
    "batch sentences",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "locates the input vectors to local array to prevent randomly access",
    "on the large server row.",
    "fill 0 for context vector",
    "window size",
    "Continuous bag-of-words Models",
    "Accumulate the input vectors from context",
    "Calculate the partial dot values",
    "We should guarantee here that the sample would not equal the ``word``",
    "used to accumulate the context input vectors",
    "locates the input vector into local arrays to prevent randomly access for",
    "the large server row.",
    "window size",
    "while true to prevent sampling out a positive target",
    "how to prevent the randomly access to the output vectors??",
    "accumulate gradients for the input vectors",
    "update output vectors",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "// calculate bias",
    "if (param.getPartKey().getStartCol() <= 0 && param.getPartKey().getEndCol() > 0) {",
    "double zVal = VectorUtils.getDouble(z, 0);",
    "double nVal = VectorUtils.getDouble(n, 0);",
    "VectorUtils.setFloat(w, 0, (float) (-1.0 * alpha * zVal / (beta + Math.sqrt(nVal))));",
    "}",
    "Do nothing.",
    "current word",
    "neu1 stores the average value of input vectors in the context (CBOW)",
    "Continuous Bag-of-Words Model",
    "Accumulate the input vectors from context",
    "negative sampling",
    "Using the sigmoid value from the pre-computed table",
    "accumulate for the hidden layer",
    "update output layer",
    "add the counter for target",
    "update hidden layer",
    "Update the input vector for each word in the context",
    "add the counter to input",
    "update input layers",
    "update output layers",
    "for (int a = 0; a < layers.length; a++) deltas[a] = layers[a] - deltas[a];",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "if not -1, sufficient space will be allocated at once",
    "InstanceRow ins = instanceRows[insId];",
    "int[] indices = ins.indices();",
    "int[] bins = ins.bins();",
    "int nnz = indices.length;",
    "for (int j = 0; j < nnz; j++) {",
    "int fid = indices[j];",
    "if (isFeatUsed[fid - featLo]) {",
    "histograms[fid - featLo].accumulate(bins[j], gradPairs[insId]);",
    "}",
    "}",
    "1. allocate histogram",
    "2. loop non-zero instances, accumulate to histogram",
    "if (nnz <= nodeEnd - nodeStart + 1) { // loop all nnz of current feature",
    "3. add remaining grad and hess to default bin",
    "return param.calcWeights(grad, hess);",
    "numClass is usually small, so we do not use arraycopy here",
    "numClass is usually small, so we do not use arraycopy here",
    "TODO: use more schema on default bin",
    "1. set default bin to left child",
    "2. for other bins, find its location",
    "3. create split set",
    "this.nodeStats = new GBTNodeStat[numClass == 2 ? 1 : numClass];",
    "predict sparse instance with indices and values",
    "predict libsvm data",
    "different types of tree node splits, enumerated by their complexity",
    "in order to reduce model size, we give priority to split point",
    "comparison between two split points, we give priority to lower feature index",
    "TODO: comparison between two split sets",
    "public boolean leafwise;  // true if leaf-wise training, false if level-wise training",
    "TODO: regularization",
    "TODO: regularization",
    "public float insSampleRatio;  // subsample ratio for instances",
    "Preconditions.checkArgument(preds.length == labels.length,",
    "\"LogLossMetric should be used for binary-label classification\");",
    "double loss = 0.0;",
    "for (int i = 0; i < preds.length; i++) {",
    "loss += evalOne(preds[i], labels[i]);",
    "}",
    "return loss / labels.length;",
    "double error = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "error += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "error += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return error / labels.length;",
    "Preconditions.checkArgument(preds.length != labels.length",
    "&& preds.length % labels.length == 0,",
    "\"CrossEntropyMetric should be used for multi-label classification\");",
    "double loss = 0.0;",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "loss += evalOne(pred, labels[i]);",
    "}",
    "return loss / labels.length;",
    "double correct = 0.0;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "correct += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "correct += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return (float) (correct / labels.length);",
    "double errSum = 0.0f;",
    "if (preds.length == labels.length) {",
    "for (int i = 0; i < preds.length; i++) {",
    "errSum += evalOne(preds[i], labels[i]);",
    "}",
    "} else {",
    "int numLabel = preds.length / labels.length;",
    "float[] pred = new float[numLabel];",
    "for (int i = 0; i < labels.length; i++) {",
    "System.arraycopy(preds, i * numLabel, pred, 0, numLabel);",
    "errSum += evalOne(pred, labels[i]);",
    "}",
    "}",
    "return Math.sqrt(errSum / labels.length);",
    "System.out.println(\"----------\");",
    "System.out.println(\"read buffer = \" + Integer.toBinaryString(readBufferT & 0b11111111)",
    "+ \", mask = \" + Integer.toBinaryString(readMaskT));",
    "readMaskT <<= 1;",
    "boolean[] bits = new boolean[]{true, true, false, false, true, false, false, false, true, true, false, true};",
    "int n = bits.length;",
    "BufferedBitSet writeBitSet = new BufferedBitSet(n);",
    "BufferedBitSet readBitSet = new BufferedBitSet(writeBitSet.getBytes(), n);",
    "if (bitSet.get(i) != bits[i]) {",
    "throw new RuntimeException(\"\" + i);",
    "}",
    "private final ByteBuffer bytes;",
    "public BufferedBitSetReader(ByteBuffer bytes, int numBits) {",
    "int capacity = bytes.capacity() * 8;",
    "readIndexT = bytes.capacity() - 1;",
    "return bytes.get(index);",
    "TODO: use arraycopy to make it faster",
    "assert from >= this.from && to <= this.to;",
    "LOG.debug(String.format(\"Create subset: [%d-%d]\", newFrom, newTo));",
    "LOG.debug(String.format(\"Get overlap: [%d-%d]\", newFrom, newTo));",
    "return bits.clone();",
    "private final SerializableBuffer bytes;",
    "private final ByteBuffer bytes;",
    "this.bytes = ByteBuffer.allocate(numBytes);",
    "public BufferedBitSetWriter(ByteBuffer bytes) {",
    "this.bytes = bytes;",
    "}",
    "bytes.put(writeIndex++, (byte) writeBuffer);",
    "public ByteBuffer getBytes() {",
    "return bytes;",
    "}",
    "ML TreeConf",
    "GBDT TreeConf",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "QSLRRunner runner = new QSLRRunner();",
    "runner.train(conf);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Dataset",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Softmax algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DeepFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Model type",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set WideAndDeep algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Set LDA parameters #V, #K",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set LDA algorithm parameters",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set SVM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "https://blog.csdn.net/cocoonyang/article/details/63068108",
    "v1[i] = v1[i] + da * v2[i];",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "v1[i] = v1[i] + da * v2[i];",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "Check is there save request",
    "Check is there load request",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "LOG.info(\"Epoch=\" + epoch + \" Metrics=\" + metrics);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Path tmpPath = new Path(new Path(context.getConf().get(AngelConf.ANGEL_JOB_TMP_OUTPUT_PATH)),",
    "String.valueOf(requestId));",
    "Path tmpPath = HdfsUtil.toTmpPath(new Path(saveContext.getSavePath()));",
    "saveContext.setTmpSavePath(tmpPath.toString());",
    "Filter old epoch trigger first",
    "Split the user request to sub-requests to pss",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Split the user request to sub-requests to pss",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and EXECUTE_SUCCESSED, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Add one sync matrix",
    "addSyncMatrix();",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "for(Entry<ParameterServerId, Map<Integer, MatrixMeta>> psEntry : matrixPartitionsOnPS.entrySet()) {",
    "LOG.info(\"ps id = \" + psEntry.getKey());",
    "Map<Integer, MatrixMeta> matrixIdToMetaMap = psEntry.getValue();",
    "for(Entry<Integer, MatrixMeta> metaEntry : matrixIdToMetaMap.entrySet()) {",
    "LOG.info(\"matrix id = \" + metaEntry.getKey());",
    "LOG.info(\"matrix partitons number = \" + metaEntry.getValue().getPartitionMetas().size());",
    "}",
    "}",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "clock first",
    "wait",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Plus a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Update a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get values from pss use row/column indices",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ PSF get/update, use can implement their own psf",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get a row or a batch of rows",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO:",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "TODO:",
    "Doing average or not",
    "Filter un-important update",
    "Split this row according the matrix partitions",
    "Set split context",
    "Remove the row from matrix",
    "buf.writeDouble(0.0);",
    "TODO",
    "TODO: write map default value",
    "buf.writeDouble(0);",
    "TODO:",
    "TODO:",
    "TODO:",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.error(\"channel \" + ctx.channel() + \" inactive\");",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "LOG.error(\"put response message queue failed \", e);",
    "Use Epoll for linux",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "private Channel getChannel(Location loc) throws Exception {",
    "return channelManager.getOrCreateChannel(new Location(loc.getIp(), loc.getPort() + 1));",
    "}",
    "private GenericObjectPool<Channel> getChannelPool(Location loc) throws InterruptedException {",
    "return channelManager.getOrCreateChannelPool(new Location(loc.getIp(), loc.getPort() + 1), PSAgentContext",
    ".get()",
    ".getConf()",
    ".getInt(AngelConf.ANGEL_WORKER_TASK_NUMBER,",
    "AngelConf.DEFAULT_ANGEL_WORKER_TASK_NUMBER));",
    "}",
    "LOG.error(\"send request \" + request + \" is interrupted\");",
    "LOG.error(\"send request \" + request + \" failed, \", e);",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "request.getContext().setChannelPool(pool);",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "updateMatrixCache(request.getPartKey(), response.getPartition());",
    "updateMatrixCache(request.getPartKey(), response.getRowsSplit());",
    "TODO",
    "ServerRow rowSplit = PSAgentContext.get().getMatricesCache()",
    ".getRowSplit(request.getPartKey().getMatrixId(), request.getPartKey(),",
    "request.getRowIndex());",
    "response.setRowSplit(rowSplit);",
    "updateMatrixCache(request.getPartKey(), response.getRowSplit());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "TODO",
    "private void updateMatrixCache(PartitionKey partKey, ServerPartition partition) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, partition);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, ServerRow rowSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowSplit);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, List<ServerRow> rowsSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowsSplit);",
    "}",
    "Get partitions for this row",
    "Distinct get row requests",
    "Need get from ps or storage/cache",
    "Switch to new request id, send a new request",
    "First get this row from matrix storage",
    "MatrixStorage matrixStorage =",
    "PSAgentContext.get().getMatrixStorageManager().getMatrixStoage(matrixId);",
    "TVector row = matrixStorage.getRow(rowIndex);",
    "if (row != null && row.getClock() >= clock) {",
    "result.set(row);",
    "return row;",
    "}",
    "Get row splits of this row from the matrix cache first",
    "responseCache.addSubResponse(rowSplit);",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "matrixStorage.addRow(rowIndex, row);",
    "Just wait result",
    "Split the param use matrix partitions",
    "Send request to PSS",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Send request to PSS",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "LOG.info(\"get row split use time=\" + (System.currentTimeMillis() - startTs));",
    "LOG.info(\"start to request \" + requestId);",
    "LOG.info(\"start to request \" + requestId);",
    "Split param use matrix partitons",
    "If all sub-results are received, just remove request and result cache",
    "LOG.info(\"request = \" + request + \", cache = \" + cache);",
    "LOG.info(\"start to merge \" + cache + \" for request \" + request);",
    "LOG.info(\"psf get merge use time = \" + (System.currentTimeMillis() - startTs));",
    "Split this row according the matrix partitions",
    "Set split context",
    "Split this row according the matrix partitions",
    "Set split context",
    "long startTs = System.currentTimeMillis();",
    "LOG.error(\"combine use time = \" + (System.currentTimeMillis() - startTs));",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO",
    "TODO",
    "/////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO",
    "buf.writeDouble(0);",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Now we just support pipelined row splits merging for dense type row",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "Read matrix meta from meta file",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "matrix.startServering();",
    "return;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Read matrix meta from meta file",
    "Sort partitions",
    "int size = rows.length;",
    "int size = rows.length;",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "return Objects.toStringHelper(this).add(\"serial\", serial).add(\"listSize\", datas.size())",
    ".toString();",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load ml conf file for graph based algorithm",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "throw new AngelException(e);",
    "JobStateProto jobState = report.getJobState();",
    "Check need load matrices",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "load user job resource files",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "private volatile PS2PSPusherImpl ps2PSPusher;",
    "TODO",
    "Add tokens to new user so that it may execute its task correctly.",
    "TODO",
    "to exit",
    "TODO",
    "TODO",
    "ps2PSPusher.recover(ProtobufUtil.convert(needRecoverParts.get(i)));",
    "context.getSnapshotManager().processRecovery();",
    "Recover PS from snapshot or load path",
    "First check snapshot",
    "Check load path setting",
    "TODO",
    "if(ps2PSPusher != null) {",
    "ps2PSPusher.start();",
    "}",
    "public PS2PSPusherImpl getPs2PSPusher() {",
    "return ps2PSPusher;",
    "}",
    "LOG.error(\"send response of request \" + requestToString(clientId, seqId) + \" failed \");",
    "LOG.error(\"send response of request failed, request seqId=\" + seqId + \", channel=\" + ch, ex);",
    "Release the input buffer",
    "Release the input buffer",
    "1. handle the rpc, get the response",
    "Release the input buffer",
    "2. Serialize the response",
    "Send the serialized response",
    "Exception happened",
    "write seq id",
    "Just serialize the head",
    "Exception happened",
    "Allocate result buffer",
    "Exception happened",
    "Just serialize the head",
    "Exception happened",
    "Reset the response and allocate buffer again",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "TODO",
    "context.getPS2PSPusher().put(request, in, partLoc);",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "TODO",
    "return ServerState.GENERAL;",
    "Use Epoll for linux",
    "public String uuid;",
    "public void setChannelPool(GenericObjectPool<Channel> channelPool) {",
    "this.channelPool = channelPool;",
    "}",
    "private final ParameterServer psServer;",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// network io method, for model transform",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "public ObjectIterator<Long2FloatMap.Entry> getIter() {",
    "return ((LongFloatVector) row).getStorage().entryIterator();",
    "}",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "public ObjectIterator<Long2LongMap.Entry> getIter() {",
    "return ((LongLongVector) row).getStorage().entryIterator();",
    "}",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO: dynamic add/delete row",
    "private final List<PartitionKey> partitionKeys;",
    "if col == -1, we use the start/end index to calculate range,",
    "we use double to store the range value since two long minus might exceed the",
    "range of long.",
    "Use Epoll for linux",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "First check the state of the channels in the pool, if a channel is unused, just return",
    "If all channels are in use, create a new channel or wait",
    "Create a new channel",
    "add the PSAgentContext,need fix",
    "If col == -1 and start/end not set",
    "start/end set",
    "for dense type, we need to set the colNum to set dim for vectors",
    "colNum set, start/end not set",
    "Row number must > 0",
    "both set, check its valid",
    "TODO:add more vector type",
    "TODO : subDim set",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "write the max abs",
    "---------------------------------------------------",
    "---------------------------------------------------",
    "---------------------------------------------------------------",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "KeepStorage is guaranteed",
    "we gauss dense storage is more efficient",
    "v1Size < v2Size * Constant.sparseThreshold",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss dense storage is more efficient",
    "prevent rehash",
    "KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "dense preferred",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sorted preferred",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "dger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "sger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "not the first time",
    "first time and do the sample",
    "set to zero",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "add dense double matrix",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "true, false",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Set training data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model type",
    "String modelType = String.valueOf(RowType.T_FLOAT_DENSE);",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.set(MLConf.ML_MODEL_TYPE(), modelType);",
    "conf.setDouble(MLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "predictTest();",
    "Data format, libsvm or dummy",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set data format",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set log path",
    "Set trainning data path",
    "Set save model path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set training data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log save path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set testing data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "loss delta",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "TODO: optimize int key indices",
    "System.out.println(\"deserialize cols.length=\" + nCols);",
    "System.out.print(\"deserialize \");",
    "System.out.print(cols[c] + \" \");",
    "System.out.println();",
    "TODO Auto-generated method stub",
    "LOG.info(\"original float length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"original double length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"parsed float length: \" + length + Arrays.toString(arr));",
    "LOG.info(\"parsed double length: \" + length + Arrays.toString(arr));",
    "ground truth: positive, precision: positive",
    "start row index for words",
    "start row index for docs",
    "doc ids",
    "topic assignments",
    "word to docs reverse index",
    "count word",
    "build word start index",
    "build word to doc reverse idx",
    "build dks",
    "dks = new TraverseHashMap[n_docs];",
    "for (int d = 0; d < n_docs; d++) {",
    "if (K < Short.MAX_VALUE) {",
    "if (docs.get(d).len < Byte.MAX_VALUE)",
    "dks[d] = new S2BTraverseMap(docs.get(d).len);",
    "if (docs.get(d).len < Short.MAX_VALUE)",
    "dks[d] = new S2STraverseMap(Math.min(K, docs.get(d).len));",
    "else",
    "dks[d] = new S2ITraverseMap(Math.min(K, docs.get(d).len));",
    "} else {",
    "dks[d] = new I2ITranverseMap(Math.min(K, docs.get(d).len));",
    "}",
    "}",
    "build dks",
    "allocate update maps",
    "Skip if no token for this word",
    "Check whether error when fetching word-topic",
    "Build FTree for current word",
    "current doc",
    "old topic assignment",
    "Check if error happens. if this happen, it's probably that failures happen to servers.",
    "We need to adjust the memory settings or network fetching parameters.",
    "Update statistics if needed",
    "Calculate psum and sample new topic",
    "Update statistics if needed",
    "Assign new topic",
    "Skip if no token for this word",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "calculate columns",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "node's end index in instancePos, instances in [start, end] belong to a tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "this.forest[this.currentTree].fset = sampleFeatureVector.getStorage().getValues();",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "1. decide nodes that should be calculated",
    "2. decide calculated and subtracted tree nodes",
    "3. calculate threads",
    "wait until all threads finish",
    "4. subtract threads",
    "wait until all threads finish",
    "5. send histograms to PS",
    "6. update histogram cache",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "this.phase = GBDTPhase.AFTER_SPLIT;",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "update local replica",
    "create AfterSplit task",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current depth",
    "finish current tree",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "1. update predictions of training data",
    "2. update predictions of validation data",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "if not -1, sufficient space will be allocated at once",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fSet, fid);",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "assert fvalue >= sketch[start] && fvalue <= sketch[end];",
    "if (left > end) return end - start;",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "max and min of each feature",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = (int) row.getStartCol();",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "Release-2.0.2": [
    "@maxIndex: this variable contains the max index of node/word",
    "values[b + offset] = (random.nextFloat() - 0.5f) / dimension;",
    "some params",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "window size",
    "Skip-Gram model",
    "Accumulate the input vectors from context",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "window size",
    "skip-gram model",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "some params",
    "batch sentences",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "locates the input vectors to local array to prevent randomly access",
    "on the large server row.",
    "fill 0 for context vector",
    "window size",
    "Continuous bag-of-words Models",
    "Accumulate the input vectors from context",
    "Calculate the partial dot values",
    "We should guarantee here that the sample would not equal the ``word``",
    "used to accumulate the context input vectors",
    "locates the input vector into local arrays to prevent randomly access for",
    "the large server row.",
    "window size",
    "while true to prevent sampling out a positive target",
    "how to prevent the randomly access to the output vectors??",
    "accumulate gradients for the input vectors",
    "update output vectors",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "calculate bias",
    "Do nothing.",
    "current word",
    "neu1 stores the average value of input vectors in the context (CBOW)",
    "Continuous Bag-of-Words Model",
    "Accumulate the input vectors from context",
    "negative sampling",
    "Using the sigmoid value from the pre-computed table",
    "accumulate for the hidden layer",
    "update output layer",
    "add the counter for target",
    "update hidden layer",
    "Update the input vector for each word in the context",
    "add the counter to input",
    "update input layers",
    "update output layers",
    "for (int a = 0; a < layers.length; a++) deltas[a] = layers[a] - deltas[a];",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "QSLRRunner runner = new QSLRRunner();",
    "runner.train(conf);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Dataset",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Softmax algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DeepFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Model type",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set WideAndDeep algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Set LDA parameters #V, #K",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set LDA algorithm parameters",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set SVM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "https://blog.csdn.net/cocoonyang/article/details/63068108",
    "v1[i] = v1[i] + da * v2[i];",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "v1[i] = v1[i] + da * v2[i];",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "Check is there save request",
    "Check is there load request",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "LOG.info(\"Epoch=\" + epoch + \" Metrics=\" + metrics);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Path tmpPath = new Path(new Path(context.getConf().get(AngelConf.ANGEL_JOB_TMP_OUTPUT_PATH)),",
    "String.valueOf(requestId));",
    "Path tmpPath = HdfsUtil.toTmpPath(new Path(saveContext.getSavePath()));",
    "saveContext.setTmpSavePath(tmpPath.toString());",
    "Filter old epoch trigger first",
    "Split the user request to sub-requests to pss",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Split the user request to sub-requests to pss",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and EXECUTE_SUCCESSED, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Add one sync matrix",
    "addSyncMatrix();",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "for(Entry<ParameterServerId, Map<Integer, MatrixMeta>> psEntry : matrixPartitionsOnPS.entrySet()) {",
    "LOG.info(\"ps id = \" + psEntry.getKey());",
    "Map<Integer, MatrixMeta> matrixIdToMetaMap = psEntry.getValue();",
    "for(Entry<Integer, MatrixMeta> metaEntry : matrixIdToMetaMap.entrySet()) {",
    "LOG.info(\"matrix id = \" + metaEntry.getKey());",
    "LOG.info(\"matrix partitons number = \" + metaEntry.getValue().getPartitionMetas().size());",
    "}",
    "}",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "clock first",
    "wait",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Plus a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Update a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get values from pss use row/column indices",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ PSF get/update, use can implement their own psf",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get a row or a batch of rows",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO:",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "TODO:",
    "Doing average or not",
    "Filter un-important update",
    "Split this row according the matrix partitions",
    "Set split context",
    "Remove the row from matrix",
    "buf.writeDouble(0.0);",
    "TODO",
    "TODO: write map default value",
    "buf.writeDouble(0);",
    "TODO:",
    "TODO:",
    "TODO:",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.error(\"channel \" + ctx.channel() + \" inactive\");",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "LOG.error(\"put response message queue failed \", e);",
    "Use Epoll for linux",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "private Channel getChannel(Location loc) throws Exception {",
    "return channelManager.getOrCreateChannel(new Location(loc.getIp(), loc.getPort() + 1));",
    "}",
    "private GenericObjectPool<Channel> getChannelPool(Location loc) throws InterruptedException {",
    "return channelManager.getOrCreateChannelPool(new Location(loc.getIp(), loc.getPort() + 1), PSAgentContext",
    ".get()",
    ".getConf()",
    ".getInt(AngelConf.ANGEL_WORKER_TASK_NUMBER,",
    "AngelConf.DEFAULT_ANGEL_WORKER_TASK_NUMBER));",
    "}",
    "LOG.error(\"send request \" + request + \" is interrupted\");",
    "LOG.error(\"send request \" + request + \" failed, \", e);",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "request.getContext().setChannelPool(pool);",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "updateMatrixCache(request.getPartKey(), response.getPartition());",
    "updateMatrixCache(request.getPartKey(), response.getRowsSplit());",
    "TODO",
    "ServerRow rowSplit = PSAgentContext.get().getMatricesCache()",
    ".getRowSplit(request.getPartKey().getMatrixId(), request.getPartKey(),",
    "request.getRowIndex());",
    "response.setRowSplit(rowSplit);",
    "updateMatrixCache(request.getPartKey(), response.getRowSplit());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "TODO",
    "private void updateMatrixCache(PartitionKey partKey, ServerPartition partition) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, partition);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, ServerRow rowSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowSplit);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, List<ServerRow> rowsSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowsSplit);",
    "}",
    "Get partitions for this row",
    "Distinct get row requests",
    "Need get from ps or storage/cache",
    "Switch to new request id, send a new request",
    "First get this row from matrix storage",
    "MatrixStorage matrixStorage =",
    "PSAgentContext.get().getMatrixStorageManager().getMatrixStoage(matrixId);",
    "TVector row = matrixStorage.getRow(rowIndex);",
    "if (row != null && row.getClock() >= clock) {",
    "result.set(row);",
    "return row;",
    "}",
    "Get row splits of this row from the matrix cache first",
    "responseCache.addSubResponse(rowSplit);",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "matrixStorage.addRow(rowIndex, row);",
    "Just wait result",
    "Split the param use matrix partitions",
    "Send request to PSS",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Send request to PSS",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "LOG.info(\"get row split use time=\" + (System.currentTimeMillis() - startTs));",
    "LOG.info(\"start to request \" + requestId);",
    "LOG.info(\"start to request \" + requestId);",
    "Split param use matrix partitons",
    "If all sub-results are received, just remove request and result cache",
    "LOG.info(\"request = \" + request + \", cache = \" + cache);",
    "LOG.info(\"start to merge \" + cache + \" for request \" + request);",
    "LOG.info(\"psf get merge use time = \" + (System.currentTimeMillis() - startTs));",
    "Split this row according the matrix partitions",
    "Set split context",
    "Split this row according the matrix partitions",
    "Set split context",
    "long startTs = System.currentTimeMillis();",
    "LOG.error(\"combine use time = \" + (System.currentTimeMillis() - startTs));",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO",
    "TODO",
    "/////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO",
    "buf.writeDouble(0);",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Now we just support pipelined row splits merging for dense type row",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "Read matrix meta from meta file",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "matrix.startServering();",
    "return;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Read matrix meta from meta file",
    "Sort partitions",
    "int size = rows.length;",
    "int size = rows.length;",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "return Objects.toStringHelper(this).add(\"serial\", serial).add(\"listSize\", datas.size())",
    ".toString();",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load ml conf file for graph based algorithm",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "throw new AngelException(e);",
    "JobStateProto jobState = report.getJobState();",
    "Check need load matrices",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "load user job resource files",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "private volatile PS2PSPusherImpl ps2PSPusher;",
    "TODO",
    "Add tokens to new user so that it may execute its task correctly.",
    "TODO",
    "to exit",
    "TODO",
    "TODO",
    "ps2PSPusher.recover(ProtobufUtil.convert(needRecoverParts.get(i)));",
    "context.getSnapshotManager().processRecovery();",
    "Recover PS from snapshot or load path",
    "First check snapshot",
    "Check load path setting",
    "TODO",
    "if(ps2PSPusher != null) {",
    "ps2PSPusher.start();",
    "}",
    "public PS2PSPusherImpl getPs2PSPusher() {",
    "return ps2PSPusher;",
    "}",
    "LOG.error(\"send response of request \" + requestToString(clientId, seqId) + \" failed \");",
    "LOG.error(\"send response of request failed, request seqId=\" + seqId + \", channel=\" + ch, ex);",
    "Release the input buffer",
    "Release the input buffer",
    "1. handle the rpc, get the response",
    "Release the input buffer",
    "2. Serialize the response",
    "Send the serialized response",
    "Exception happened",
    "write seq id",
    "Just serialize the head",
    "Exception happened",
    "Allocate result buffer",
    "Exception happened",
    "Just serialize the head",
    "Exception happened",
    "Reset the response and allocate buffer again",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "TODO",
    "context.getPS2PSPusher().put(request, in, partLoc);",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "TODO",
    "return ServerState.GENERAL;",
    "Use Epoll for linux",
    "public String uuid;",
    "public void setChannelPool(GenericObjectPool<Channel> channelPool) {",
    "this.channelPool = channelPool;",
    "}",
    "private final ParameterServer psServer;",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// network io method, for model transform",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "public ObjectIterator<Long2FloatMap.Entry> getIter() {",
    "return ((LongFloatVector) row).getStorage().entryIterator();",
    "}",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "public ObjectIterator<Long2LongMap.Entry> getIter() {",
    "return ((LongLongVector) row).getStorage().entryIterator();",
    "}",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO: dynamic add/delete row",
    "private final List<PartitionKey> partitionKeys;",
    "Use Epoll for linux",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "First check the state of the channels in the pool, if a channel is unused, just return",
    "If all channels are in use, create a new channel or wait",
    "Create a new channel",
    "add the PSAgentContext,need fix",
    "TODO:add more vector type",
    "TODO : subDim set",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "write the max abs",
    "---------------------------------------------------",
    "---------------------------------------------------",
    "---------------------------------------------------------------",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "KeepStorage is guaranteed",
    "we gauss dense storage is more efficient",
    "v1Size < v2Size * Constant.sparseThreshold",
    "KeepStorage is guaranteed",
    "ignore the isInplace option, since v2 is dense",
    "the value in old storage can be changed safe, so switch a storage",
    "but user required keep storage, we can prevent rehash",
    "we gauss dense storage is more efficient",
    "prevent rehash",
    "KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "dense preferred",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sorted preferred",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "dense preferred, KeepStorage is guaranteed",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "slower but memory efficient, for small vector only",
    "dense preferred, KeepStorage is guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "sparse preferred, keep storage guaranteed",
    "sparse preferred, keep storage guaranteed",
    "preferred dense",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "we gauss dense storage is more efficient",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "we gauss the indices of v2 maybe is a subset of v1, or overlap is very large",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "mat1 trans true, mat trans true",
    "mat1 trans true, mat trans false",
    "mat1 trans false, mat trans true, important",
    "mat1 trans false, mat trans false",
    "dger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "sger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "add dense double matrix",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "true, false",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Set training data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model type",
    "String modelType = String.valueOf(RowType.T_FLOAT_DENSE);",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.set(MLConf.ML_MODEL_TYPE(), modelType);",
    "conf.setDouble(MLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "predictTest();",
    "Data format, libsvm or dummy",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set data format",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set log path",
    "Set trainning data path",
    "Set save model path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set training data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log save path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set testing data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "loss delta",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "TODO: optimize int key indices",
    "System.out.println(\"deserialize cols.length=\" + nCols);",
    "System.out.print(\"deserialize \");",
    "System.out.print(cols[c] + \" \");",
    "System.out.println();",
    "TODO Auto-generated method stub",
    "LOG.info(\"original float length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"original double length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"parsed float length: \" + length + Arrays.toString(arr));",
    "LOG.info(\"parsed double length: \" + length + Arrays.toString(arr));",
    "ground truth: positive, precision: positive",
    "start row index for words",
    "start row index for docs",
    "doc ids",
    "topic assignments",
    "word to docs reverse index",
    "count word",
    "build word start index",
    "build word to doc reverse idx",
    "build dks",
    "dks = new TraverseHashMap[n_docs];",
    "for (int d = 0; d < n_docs; d++) {",
    "if (K < Short.MAX_VALUE) {",
    "if (docs.get(d).len < Byte.MAX_VALUE)",
    "dks[d] = new S2BTraverseMap(docs.get(d).len);",
    "if (docs.get(d).len < Short.MAX_VALUE)",
    "dks[d] = new S2STraverseMap(Math.min(K, docs.get(d).len));",
    "else",
    "dks[d] = new S2ITraverseMap(Math.min(K, docs.get(d).len));",
    "} else {",
    "dks[d] = new I2ITranverseMap(Math.min(K, docs.get(d).len));",
    "}",
    "}",
    "build dks",
    "allocate update maps",
    "Skip if no token for this word",
    "Check whether error when fetching word-topic",
    "Build FTree for current word",
    "current doc",
    "old topic assignment",
    "Check if error happens. if this happen, it's probably that failures happen to servers.",
    "We need to adjust the memory settings or network fetching parameters.",
    "Update statistics if needed",
    "Calculate psum and sample new topic",
    "Update statistics if needed",
    "Assign new topic",
    "Skip if no token for this word",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "calculate columns",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "node's end index in instancePos, instances in [start, end] belong to a tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "this.forest[this.currentTree].fset = sampleFeatureVector.getStorage().getValues();",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "1. decide nodes that should be calculated",
    "2. decide calculated and subtracted tree nodes",
    "3. calculate threads",
    "wait until all threads finish",
    "4. subtract threads",
    "wait until all threads finish",
    "5. send histograms to PS",
    "6. update histogram cache",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "this.phase = GBDTPhase.AFTER_SPLIT;",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "update local replica",
    "create AfterSplit task",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current depth",
    "finish current tree",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "1. update predictions of training data",
    "2. update predictions of validation data",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "if not -1, sufficient space will be allocated at once",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fSet, fid);",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "assert fvalue >= sketch[start] && fvalue <= sketch[end];",
    "if (left > end) return end - start;",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "max and min of each feature",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = (int) row.getStartCol();",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "Release-2.0.1": [
    "@maxIndex: this variable contains the max index of node/word",
    "values[b + offset] = (random.nextFloat() - 0.5f) / dimension;",
    "some params",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "window size",
    "Skip-Gram model",
    "Accumulate the input vectors from context",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "window size",
    "skip-gram model",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "some params",
    "batch sentences",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "locates the input vectors to local array to prevent randomly access",
    "on the large server row.",
    "fill 0 for context vector",
    "window size",
    "Continuous bag-of-words Models",
    "Accumulate the input vectors from context",
    "Calculate the partial dot values",
    "We should guarantee here that the sample would not equal the ``word``",
    "used to accumulate the context input vectors",
    "locates the input vector into local arrays to prevent randomly access for",
    "the large server row.",
    "window size",
    "while true to prevent sampling out a positive target",
    "how to prevent the randomly access to the output vectors??",
    "accumulate gradients for the input vectors",
    "update output vectors",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "calculate bias",
    "Do nothing.",
    "current word",
    "neu1 stores the average value of input vectors in the context (CBOW)",
    "Continuous Bag-of-Words Model",
    "Accumulate the input vectors from context",
    "negative sampling",
    "Using the sigmoid value from the pre-computed table",
    "accumulate for the hidden layer",
    "update output layer",
    "add the counter for target",
    "update hidden layer",
    "Update the input vector for each word in the context",
    "add the counter to input",
    "update input layers",
    "update output layers",
    "for (int a = 0; a < layers.length; a++) deltas[a] = layers[a] - deltas[a];",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "QSLRRunner runner = new QSLRRunner();",
    "runner.train(conf);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Dataset",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Softmax algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DeepFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Model type",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set WideAndDeep algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Set LDA parameters #V, #K",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set LDA algorithm parameters",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set SVM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "https://blog.csdn.net/cocoonyang/article/details/63068108",
    "v1[i] = v1[i] + da * v2[i];",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "v1[i] = v1[i] + da * v2[i];",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "Check is there save request",
    "Check is there load request",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "LOG.info(\"Epoch=\" + epoch + \" Metrics=\" + metrics);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Path tmpPath = new Path(new Path(context.getConf().get(AngelConf.ANGEL_JOB_TMP_OUTPUT_PATH)),",
    "String.valueOf(requestId));",
    "Path tmpPath = HdfsUtil.toTmpPath(new Path(saveContext.getSavePath()));",
    "saveContext.setTmpSavePath(tmpPath.toString());",
    "Filter old epoch trigger first",
    "Split the user request to sub-requests to pss",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Split the user request to sub-requests to pss",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and EXECUTE_SUCCESSED, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Add one sync matrix",
    "addSyncMatrix();",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "for(Entry<ParameterServerId, Map<Integer, MatrixMeta>> psEntry : matrixPartitionsOnPS.entrySet()) {",
    "LOG.info(\"ps id = \" + psEntry.getKey());",
    "Map<Integer, MatrixMeta> matrixIdToMetaMap = psEntry.getValue();",
    "for(Entry<Integer, MatrixMeta> metaEntry : matrixIdToMetaMap.entrySet()) {",
    "LOG.info(\"matrix id = \" + metaEntry.getKey());",
    "LOG.info(\"matrix partitons number = \" + metaEntry.getValue().getPartitionMetas().size());",
    "}",
    "}",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "clock first",
    "wait",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Plus a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Update a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get values from pss use row/column indices",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ PSF get/update, use can implement their own psf",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get a row or a batch of rows",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO:",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "TODO:",
    "Doing average or not",
    "Filter un-important update",
    "Split this row according the matrix partitions",
    "Set split context",
    "Remove the row from matrix",
    "buf.writeDouble(0.0);",
    "TODO",
    "TODO: write map default value",
    "buf.writeDouble(0);",
    "TODO:",
    "TODO:",
    "TODO:",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.error(\"channel \" + ctx.channel() + \" inactive\");",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "LOG.error(\"put response message queue failed \", e);",
    "Use Epoll for linux",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "private Channel getChannel(Location loc) throws Exception {",
    "return channelManager.getOrCreateChannel(new Location(loc.getIp(), loc.getPort() + 1));",
    "}",
    "private GenericObjectPool<Channel> getChannelPool(Location loc) throws InterruptedException {",
    "return channelManager.getOrCreateChannelPool(new Location(loc.getIp(), loc.getPort() + 1), PSAgentContext",
    ".get()",
    ".getConf()",
    ".getInt(AngelConf.ANGEL_WORKER_TASK_NUMBER,",
    "AngelConf.DEFAULT_ANGEL_WORKER_TASK_NUMBER));",
    "}",
    "LOG.error(\"send request \" + request + \" is interrupted\");",
    "LOG.error(\"send request \" + request + \" failed, \", e);",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "request.getContext().setChannelPool(pool);",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "updateMatrixCache(request.getPartKey(), response.getPartition());",
    "updateMatrixCache(request.getPartKey(), response.getRowsSplit());",
    "TODO",
    "ServerRow rowSplit = PSAgentContext.get().getMatricesCache()",
    ".getRowSplit(request.getPartKey().getMatrixId(), request.getPartKey(),",
    "request.getRowIndex());",
    "response.setRowSplit(rowSplit);",
    "updateMatrixCache(request.getPartKey(), response.getRowSplit());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "TODO",
    "private void updateMatrixCache(PartitionKey partKey, ServerPartition partition) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, partition);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, ServerRow rowSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowSplit);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, List<ServerRow> rowsSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowsSplit);",
    "}",
    "Get partitions for this row",
    "Distinct get row requests",
    "Need get from ps or storage/cache",
    "Switch to new request id, send a new request",
    "First get this row from matrix storage",
    "MatrixStorage matrixStorage =",
    "PSAgentContext.get().getMatrixStorageManager().getMatrixStoage(matrixId);",
    "TVector row = matrixStorage.getRow(rowIndex);",
    "if (row != null && row.getClock() >= clock) {",
    "result.set(row);",
    "return row;",
    "}",
    "Get row splits of this row from the matrix cache first",
    "responseCache.addSubResponse(rowSplit);",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "matrixStorage.addRow(rowIndex, row);",
    "Just wait result",
    "Split the param use matrix partitions",
    "Send request to PSS",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Send request to PSS",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "LOG.info(\"get row split use time=\" + (System.currentTimeMillis() - startTs));",
    "LOG.info(\"start to request \" + requestId);",
    "LOG.info(\"start to request \" + requestId);",
    "Split param use matrix partitons",
    "If all sub-results are received, just remove request and result cache",
    "LOG.info(\"request = \" + request + \", cache = \" + cache);",
    "LOG.info(\"start to merge \" + cache + \" for request \" + request);",
    "LOG.info(\"psf get merge use time = \" + (System.currentTimeMillis() - startTs));",
    "Split this row according the matrix partitions",
    "Set split context",
    "Split this row according the matrix partitions",
    "Set split context",
    "long startTs = System.currentTimeMillis();",
    "LOG.error(\"combine use time = \" + (System.currentTimeMillis() - startTs));",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO",
    "TODO",
    "/////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO",
    "buf.writeDouble(0);",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Now we just support pipelined row splits merging for dense type row",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "Read matrix meta from meta file",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "matrix.startServering();",
    "return;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Read matrix meta from meta file",
    "Sort partitions",
    "int size = rows.length;",
    "int size = rows.length;",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "return Objects.toStringHelper(this).add(\"serial\", serial).add(\"listSize\", datas.size())",
    ".toString();",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load ml conf file for graph based algorithm",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "throw new AngelException(e);",
    "JobStateProto jobState = report.getJobState();",
    "Check need load matrices",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "load user job resource files",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "private volatile PS2PSPusherImpl ps2PSPusher;",
    "TODO",
    "Add tokens to new user so that it may execute its task correctly.",
    "TODO",
    "to exit",
    "TODO",
    "TODO",
    "ps2PSPusher.recover(ProtobufUtil.convert(needRecoverParts.get(i)));",
    "context.getSnapshotManager().processRecovery();",
    "Recover PS from snapshot or load path",
    "First check snapshot",
    "Check load path setting",
    "TODO",
    "if(ps2PSPusher != null) {",
    "ps2PSPusher.start();",
    "}",
    "public PS2PSPusherImpl getPs2PSPusher() {",
    "return ps2PSPusher;",
    "}",
    "LOG.error(\"send response of request \" + requestToString(clientId, seqId) + \" failed \");",
    "LOG.error(\"send response of request failed, request seqId=\" + seqId + \", channel=\" + ch, ex);",
    "Release the input buffer",
    "Release the input buffer",
    "1. handle the rpc, get the response",
    "Release the input buffer",
    "2. Serialize the response",
    "Send the serialized response",
    "Exception happened",
    "write seq id",
    "Just serialize the head",
    "Exception happened",
    "Allocate result buffer",
    "Exception happened",
    "Just serialize the head",
    "Exception happened",
    "Reset the response and allocate buffer again",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "TODO",
    "context.getPS2PSPusher().put(request, in, partLoc);",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "TODO",
    "return ServerState.GENERAL;",
    "Use Epoll for linux",
    "public String uuid;",
    "public void setChannelPool(GenericObjectPool<Channel> channelPool) {",
    "this.channelPool = channelPool;",
    "}",
    "private final ParameterServer psServer;",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// network io method, for model transform",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "public ObjectIterator<Long2FloatMap.Entry> getIter() {",
    "return ((LongFloatVector) row).getStorage().entryIterator();",
    "}",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "public ObjectIterator<Long2LongMap.Entry> getIter() {",
    "return ((LongLongVector) row).getStorage().entryIterator();",
    "}",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO: dynamic add/delete row",
    "private final List<PartitionKey> partitionKeys;",
    "Use Epoll for linux",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "First check the state of the channels in the pool, if a channel is unused, just return",
    "If all channels are in use, create a new channel or wait",
    "Create a new channel",
    "add the PSAgentContext,need fix",
    "TODO:add more vector type",
    "TODO : subDim set",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "write the max abs",
    "---------------------------------------------------",
    "---------------------------------------------------",
    "---------------------------------------------------------------",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "-----------------",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Transform mat1, generate a new matrix",
    "Split the row indices of mat1Trans",
    "Parallel execute use fork-join",
    "Get the sub-matrix of left matrix, split by row",
    "Get the sub-matrix of left matrix, split by row",
    "dger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "sger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "add dense double matrix",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "true, false",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Set training data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.setDouble(MLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "predictTest();",
    "Data format, libsvm or dummy",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set data format",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set log path",
    "Set trainning data path",
    "Set save model path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set training data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log save path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set testing data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "loss delta",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "TODO: optimize int key indices",
    "System.out.println(\"deserialize cols.length=\" + nCols);",
    "System.out.print(\"deserialize \");",
    "System.out.print(cols[c] + \" \");",
    "System.out.println();",
    "TODO Auto-generated method stub",
    "LOG.info(\"original float length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"original double length: \" + len + Arrays.toString(Arrays.copyOfRange(arr, start, end)));",
    "LOG.info(\"parsed float length: \" + length + Arrays.toString(arr));",
    "LOG.info(\"parsed double length: \" + length + Arrays.toString(arr));",
    "ground truth: positive, precision: positive",
    "start row index for words",
    "start row index for docs",
    "doc ids",
    "topic assignments",
    "word to docs reverse index",
    "count word",
    "build word start index",
    "build word to doc reverse idx",
    "build dks",
    "dks = new TraverseHashMap[n_docs];",
    "for (int d = 0; d < n_docs; d++) {",
    "if (K < Short.MAX_VALUE) {",
    "if (docs.get(d).len < Byte.MAX_VALUE)",
    "dks[d] = new S2BTraverseMap(docs.get(d).len);",
    "if (docs.get(d).len < Short.MAX_VALUE)",
    "dks[d] = new S2STraverseMap(Math.min(K, docs.get(d).len));",
    "else",
    "dks[d] = new S2ITraverseMap(Math.min(K, docs.get(d).len));",
    "} else {",
    "dks[d] = new I2ITranverseMap(Math.min(K, docs.get(d).len));",
    "}",
    "}",
    "build dks",
    "allocate update maps",
    "Skip if no token for this word",
    "Check whether error when fetching word-topic",
    "Build FTree for current word",
    "current doc",
    "old topic assignment",
    "Check if error happens. if this happen, it's probably that failures happen to servers.",
    "We need to adjust the memory settings or network fetching parameters.",
    "Update statistics if needed",
    "Calculate psum and sample new topic",
    "Update statistics if needed",
    "Assign new topic",
    "Skip if no token for this word",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "calculate columns",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "node's end index in instancePos, instances in [start, end] belong to a tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "this.forest[this.currentTree].fset = sampleFeatureVector.getStorage().getValues();",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "1. decide nodes that should be calculated",
    "2. decide calculated and subtracted tree nodes",
    "3. calculate threads",
    "wait until all threads finish",
    "4. subtract threads",
    "wait until all threads finish",
    "5. send histograms to PS",
    "6. update histogram cache",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "this.phase = GBDTPhase.AFTER_SPLIT;",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "update local replica",
    "create AfterSplit task",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current depth",
    "finish current tree",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "1. update predictions of training data",
    "2. update predictions of validation data",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "if not -1, sufficient space will be allocated at once",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fSet, fid);",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "assert fvalue >= sketch[start] && fvalue <= sketch[end];",
    "if (left > end) return end - start;",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "max and min of each feature",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = (int) row.getStartCol();",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "Release-2.0.0": [
    "@maxIndex: this variable contains the max index of node/word",
    "some params",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "Skip-Gram model",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "window size",
    "Skip-Gram model",
    "Accumulate the input vectors from context",
    "Negative sampling",
    "used to accumulate the updates for input vectors",
    "window size",
    "skip-gram model",
    "Negative sampling",
    "accumulate for the hidden layer",
    "update output layer",
    "update the hidden layer",
    "update input",
    "update output",
    "some params",
    "batch sentences",
    "max index for node/word",
    "compute number of nodes for one row",
    "check the length of dot values",
    "merge dot values from all partitions",
    "locates the input vectors to local array to prevent randomly access",
    "on the large server row.",
    "fill 0 for context vector",
    "window size",
    "Continuous bag-of-words Models",
    "Accumulate the input vectors from context",
    "Calculate the partial dot values",
    "We should guarantee here that the sample would not equal the ``word``",
    "used to accumulate the context input vectors",
    "locates the input vector into local arrays to prevent randomly access for",
    "the large server row.",
    "window size",
    "while true to prevent sampling out a positive target",
    "how to prevent the randomly access to the output vectors??",
    "accumulate gradients for the input vectors",
    "update output vectors",
    "update input",
    "update output",
    "Some params",
    "compute number of nodes for one row",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "QSLRRunner runner = new QSLRRunner();",
    "runner.train(conf);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Dataset",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Softmax algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DeepFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Model type",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set WideAndDeep algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Set LDA parameters #V, #K",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set LDA algorithm parameters",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set SVM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "RowOffset rowOffset = partMeta.getRowMetas().get(rowId);",
    "input.seek(rowOffset.getOffset());",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleCompUDF();",
    "testSparseDoubleCompUDF();",
    "testDenseFloatCompUDF();",
    "testSparseFloatCompUDF();",
    "testDenseIntCompUDF();",
    "testSparseIntCompUDF();",
    "testDenseLongCompUDF();",
    "testSparseLongCompUDF();",
    "testSparseDoubleLongKeyCompUDF();",
    "testSparseFloatLongKeyCompUDF();",
    "testSparseIntLongKeyCompUDF();",
    "testSparseLongLongKeyCompUDF();",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add comp dense double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "LOG.info(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntFloatVector row = (IntFloatVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntLongVector row = (IntLongVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "https://blog.csdn.net/cocoonyang/article/details/63068108",
    "v1[i] = v1[i] + da * v2[i];",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "v1[i] = v1[i] + da * v2[i];",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "test worker getActiveTaskNum",
    "test worker getTaskNum",
    "test worker getTaskManager",
    "test workerId",
    "test workerAttemptId",
    "tet worker initFinished",
    "test worker getInitMinclock",
    "test worker loacation",
    "test AppId",
    "test Conf",
    "test UserName",
    "master location",
    "masterClient",
    "test psAgent",
    "test worker get dataBlockManager",
    "workerGroup.getSplits();",
    "application",
    "lcation",
    "workerGroup info",
    "worker info",
    "task",
    "using mock object",
    "verification",
    "Stubbing",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "Check is there save request",
    "Check is there load request",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "LOG.info(\"Epoch=\" + epoch + \" Metrics=\" + metrics);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Path tmpPath = new Path(new Path(context.getConf().get(AngelConf.ANGEL_JOB_TMP_OUTPUT_PATH)),",
    "String.valueOf(requestId));",
    "Path tmpPath = HdfsUtil.toTmpPath(new Path(saveContext.getSavePath()));",
    "saveContext.setTmpSavePath(tmpPath.toString());",
    "Filter old epoch trigger first",
    "Split the user request to sub-requests to pss",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Split the user request to sub-requests to pss",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and EXECUTE_SUCCESSED, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Add one sync matrix",
    "addSyncMatrix();",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "for(Entry<ParameterServerId, Map<Integer, MatrixMeta>> psEntry : matrixPartitionsOnPS.entrySet()) {",
    "LOG.info(\"ps id = \" + psEntry.getKey());",
    "Map<Integer, MatrixMeta> matrixIdToMetaMap = psEntry.getValue();",
    "for(Entry<Integer, MatrixMeta> metaEntry : matrixIdToMetaMap.entrySet()) {",
    "LOG.info(\"matrix id = \" + metaEntry.getKey());",
    "LOG.info(\"matrix partitons number = \" + metaEntry.getValue().getPartitionMetas().size());",
    "}",
    "}",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "clock first",
    "wait",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Plus a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Update a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get values from pss use row/column indices",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ PSF get/update, use can implement their own psf",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get a row or a batch of rows",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO:",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "TODO:",
    "Doing average or not",
    "Filter un-important update",
    "Split this row according the matrix partitions",
    "Set split context",
    "Remove the row from matrix",
    "buf.writeDouble(0.0);",
    "TODO",
    "TODO: write map default value",
    "buf.writeDouble(0);",
    "TODO:",
    "TODO:",
    "TODO:",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.error(\"channel \" + ctx.channel() + \" inactive\");",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "LOG.error(\"put response message queue failed \", e);",
    "Use Epoll for linux",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "private Channel getChannel(Location loc) throws Exception {",
    "return channelManager.getOrCreateChannel(new Location(loc.getIp(), loc.getPort() + 1));",
    "}",
    "private GenericObjectPool<Channel> getChannelPool(Location loc) throws InterruptedException {",
    "return channelManager.getOrCreateChannelPool(new Location(loc.getIp(), loc.getPort() + 1), PSAgentContext",
    ".get()",
    ".getConf()",
    ".getInt(AngelConf.ANGEL_WORKER_TASK_NUMBER,",
    "AngelConf.DEFAULT_ANGEL_WORKER_TASK_NUMBER));",
    "}",
    "LOG.error(\"send request \" + request + \" is interrupted\");",
    "LOG.error(\"send request \" + request + \" failed, \", e);",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "request.getContext().setChannelPool(pool);",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "updateMatrixCache(request.getPartKey(), response.getPartition());",
    "updateMatrixCache(request.getPartKey(), response.getRowsSplit());",
    "TODO",
    "ServerRow rowSplit = PSAgentContext.get().getMatricesCache()",
    ".getRowSplit(request.getPartKey().getMatrixId(), request.getPartKey(),",
    "request.getRowIndex());",
    "response.setRowSplit(rowSplit);",
    "updateMatrixCache(request.getPartKey(), response.getRowSplit());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "TODO",
    "private void updateMatrixCache(PartitionKey partKey, ServerPartition partition) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, partition);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, ServerRow rowSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowSplit);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, List<ServerRow> rowsSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowsSplit);",
    "}",
    "Get partitions for this row",
    "Distinct get row requests",
    "Need get from ps or storage/cache",
    "Switch to new request id, send a new request",
    "First get this row from matrix storage",
    "MatrixStorage matrixStorage =",
    "PSAgentContext.get().getMatrixStorageManager().getMatrixStoage(matrixId);",
    "TVector row = matrixStorage.getRow(rowIndex);",
    "if (row != null && row.getClock() >= clock) {",
    "result.set(row);",
    "return row;",
    "}",
    "Get row splits of this row from the matrix cache first",
    "responseCache.addSubResponse(rowSplit);",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "matrixStorage.addRow(rowIndex, row);",
    "Just wait result",
    "Split the param use matrix partitions",
    "Send request to PSS",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Send request to PSS",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "LOG.info(\"get row split use time=\" + (System.currentTimeMillis() - startTs));",
    "LOG.info(\"start to request \" + requestId);",
    "LOG.info(\"start to request \" + requestId);",
    "Split param use matrix partitons",
    "If all sub-results are received, just remove request and result cache",
    "LOG.info(\"request = \" + request + \", cache = \" + cache);",
    "LOG.info(\"start to merge \" + cache + \" for request \" + request);",
    "LOG.info(\"psf get merge use time = \" + (System.currentTimeMillis() - startTs));",
    "Split this row according the matrix partitions",
    "Set split context",
    "Split this row according the matrix partitions",
    "Set split context",
    "long startTs = System.currentTimeMillis();",
    "LOG.error(\"combine use time = \" + (System.currentTimeMillis() - startTs));",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {",
    "return key1.getStartCol() < key2.getStartCol() ? -1 : 1;",
    "});",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO",
    "TODO",
    "/////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO",
    "buf.writeDouble(0);",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Now we just support pipelined row splits merging for dense type row",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "Read matrix meta from meta file",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "matrix.startServering();",
    "return;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Read matrix meta from meta file",
    "Sort partitions",
    "int size = rows.length;",
    "int size = rows.length;",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "int size = rows.size();",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "return Objects.toStringHelper(this).add(\"serial\", serial).add(\"listSize\", datas.size())",
    ".toString();",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load ml conf file for graph based algorithm",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "throw new AngelException(e);",
    "JobStateProto jobState = report.getJobState();",
    "Check need load matrices",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "load user job resource files",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "private volatile PS2PSPusherImpl ps2PSPusher;",
    "TODO",
    "Add tokens to new user so that it may execute its task correctly.",
    "TODO",
    "to exit",
    "TODO",
    "TODO",
    "ps2PSPusher.recover(ProtobufUtil.convert(needRecoverParts.get(i)));",
    "context.getSnapshotManager().processRecovery();",
    "Recover PS from snapshot or load path",
    "First check snapshot",
    "Check load path setting",
    "TODO",
    "if(ps2PSPusher != null) {",
    "ps2PSPusher.start();",
    "}",
    "public PS2PSPusherImpl getPs2PSPusher() {",
    "return ps2PSPusher;",
    "}",
    "LOG.error(\"send response of request \" + requestToString(clientId, seqId) + \" failed \");",
    "LOG.error(\"send response of request failed, request seqId=\" + seqId + \", channel=\" + ch, ex);",
    "Release the input buffer",
    "Release the input buffer",
    "1. handle the rpc, get the response",
    "Release the input buffer",
    "2. Serialize the response",
    "Send the serialized response",
    "Exception happened",
    "write seq id",
    "Just serialize the head",
    "Exception happened",
    "Allocate result buffer",
    "Exception happened",
    "Just serialize the head",
    "Exception happened",
    "Reset the response and allocate buffer again",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "TODO",
    "context.getPS2PSPusher().put(request, in, partLoc);",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "TODO",
    "return ServerState.GENERAL;",
    "Use Epoll for linux",
    "public String uuid;",
    "public void setChannelPool(GenericObjectPool<Channel> channelPool) {",
    "this.channelPool = channelPool;",
    "}",
    "private final ParameterServer psServer;",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO:default value",
    "buf.readDouble();",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// network io method, for model transform",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "public ObjectIterator<Long2FloatMap.Entry> getIter() {",
    "return ((LongFloatVector) row).getStorage().entryIterator();",
    "}",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "public ObjectIterator<Long2LongMap.Entry> getIter() {",
    "return ((LongLongVector) row).getStorage().entryIterator();",
    "}",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO: dynamic add/delete row",
    "private final List<PartitionKey> partitionKeys;",
    "Use Epoll for linux",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "First check the state of the channels in the pool, if a channel is unused, just return",
    "If all channels are in use, create a new channel or wait",
    "Create a new channel",
    "add the PSAgentContext,need fix",
    "TODO:add more vector type",
    "TODO : subDim set",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "write the max abs",
    "---------------------------------------------------",
    "---------------------------------------------------",
    "---------------------------------------------------------------",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "dger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "sger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "add dense double matrix",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "true, false",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Set training data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.setDouble(MLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set log path",
    "Set trainning data path",
    "Set save model path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set training data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log save path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set testing data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "loss delta",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "gradient descent first, then truncated",
    "TODO: optimize int key indices",
    "System.out.println(\"deserialize cols.length=\" + nCols);",
    "System.out.print(\"deserialize \");",
    "System.out.print(cols[c] + \" \");",
    "System.out.println();",
    "TODO Auto-generated method stub",
    "ground truth: positive, precision: positive",
    "start row index for words",
    "start row index for docs",
    "doc ids",
    "topic assignments",
    "word to docs reverse index",
    "count word",
    "build word start index",
    "build word to doc reverse idx",
    "build dks",
    "dks = new TraverseHashMap[n_docs];",
    "for (int d = 0; d < n_docs; d++) {",
    "if (K < Short.MAX_VALUE) {",
    "if (docs.get(d).len < Byte.MAX_VALUE)",
    "dks[d] = new S2BTraverseMap(docs.get(d).len);",
    "if (docs.get(d).len < Short.MAX_VALUE)",
    "dks[d] = new S2STraverseMap(Math.min(K, docs.get(d).len));",
    "else",
    "dks[d] = new S2ITraverseMap(Math.min(K, docs.get(d).len));",
    "} else {",
    "dks[d] = new I2ITranverseMap(Math.min(K, docs.get(d).len));",
    "}",
    "}",
    "build dks",
    "allocate update maps",
    "Skip if no token for this word",
    "Check whether error when fetching word-topic",
    "Build FTree for current word",
    "current doc",
    "old topic assignment",
    "Check if error happens. if this happen, it's probably that failures happen to servers.",
    "We need to adjust the memory settings or network fetching parameters.",
    "Update statistics if needed",
    "Calculate psum and sample new topic",
    "Update statistics if needed",
    "Assign new topic",
    "Skip if no token for this word",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "calculate columns",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "node's end index in instancePos, instances in [start, end] belong to a tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "this.forest[this.currentTree].fset = sampleFeatureVector.getStorage().getValues();",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "1. decide nodes that should be calculated",
    "2. decide calculated and subtracted tree nodes",
    "3. calculate threads",
    "wait until all threads finish",
    "4. subtract threads",
    "wait until all threads finish",
    "5. send histograms to PS",
    "6. update histogram cache",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "this.phase = GBDTPhase.AFTER_SPLIT;",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "update local replica",
    "create AfterSplit task",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current depth",
    "finish current tree",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "1. update predictions of training data",
    "2. update predictions of validation data",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "if not -1, sufficient space will be allocated at once",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fSet, fid);",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "assert fvalue >= sketch[start] && fvalue <= sketch[end];",
    "if (left > end) return end - start;",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "max and min of each feature",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "TODO: only support dense double now",
    "int sendStartCol = (int) row.getStartCol();",
    "find the max abs",
    "compress data",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "2.0.0-alpha": [
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "todo:implements",
    "todo: implements",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "QSLRRunner runner = new QSLRRunner();",
    "runner.train(conf);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Dataset",
    "Data format",
    "Feature number of train data",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Ratio of validation",
    "Learning rate",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set DeepFM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Model type",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters",
    "Set model class",
    "Dataset",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set WideAndDeep algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format",
    "Set LDA parameters #V, #K",
    "Set file system",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource, #worker, #task, #PS",
    "Set LDA algorithm parameters",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set SVM algorithm parameters",
    "Set model class",
    "Dataset",
    "Data format, libsvm or dummy",
    "Model type",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set file system",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "Set data path",
    "Set angel resource parameters #worker, #task, #PS",
    "Set LR algorithm parameters",
    "Set model class",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "Start PS",
    "Start to run application",
    "mMatrix.setNnz(100000000);",
    "mMatrix.setNnz(100000000);",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "DenseIntVector deltaVec = new DenseIntVector(100000, delta);",
    "deltaVec.setMatrixId(matrixW1Id);",
    "deltaVec.setRowId(0);",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "testDenseDoubleCompUDF();",
    "testSparseDoubleCompUDF();",
    "testDenseFloatCompUDF();",
    "testSparseFloatCompUDF();",
    "testDenseIntCompUDF();",
    "testSparseIntCompUDF();",
    "testDenseLongCompUDF();",
    "testSparseLongCompUDF();",
    "testSparseDoubleLongKeyCompUDF();",
    "testSparseFloatLongKeyCompUDF();",
    "testSparseIntLongKeyCompUDF();",
    "testSparseLongLongKeyCompUDF();",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "client1.clock().get();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntDoubleVector row = (IntDoubleVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntFloatVector row = (IntFloatVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "IndexGet func = new IndexGet(new IndexGetParam(matrixW1Id, 0, index));",
    "IntLongVector row = (IntLongVector) ((GetRowResult) client1.get(func)).getRow();",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add comp dense float matrix",
    "add comp dense float matrix",
    "Start PS",
    "Start to run application",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add comp dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add comp dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense long matrix",
    "add comp dense long matrix",
    "add sparse long matrix",
    "add component sparse long matrix",
    "add comp dense long double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add component long-key sparse float matrix",
    "add sparse long-key float matrix",
    "add component long-key sparse float matrix",
    "add component long-key sparse int matrix",
    "add sparse long-key int matrix",
    "add component long-key sparse int matrix",
    "add component long-key sparse long matrix",
    "add sparse long-key long matrix",
    "add component long-key sparse long matrix",
    "Start PS",
    "Start to run application",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "System.out.println(\"id=\" + id + \", value=\" + mergedRow.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "Assert.assertTrue(index.length == row.size());",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "CompSparseDoubleVector deltaVec = new CompSparseDoubleVector(matrixW1Id, 0, feaNum, feaNum);",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "for (int i = 0; i < feaNum; i++) {",
    "deltaVec.set(i, i);",
    "}",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(\"id=\" + id + \", value=\" + row.get(id));",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "System.out.println(content);",
    "https://blog.csdn.net/cocoonyang/article/details/63068108",
    "v1[i] = v1[i] + da * v2[i];",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "v1[i] = v1[i] + da * v2[i];",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "y := alpha*A*x + beta*y",
    "dgemm(String transa, String transb,",
    "int m, int n, int k,",
    "double alpha,",
    "double[] a, int lda,",
    "double[] b, int ldb,",
    "double beta,",
    "double[] c, int ldc);",
    "C := alpha*op( A )*op( B ) + beta*C",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "test worker getActiveTaskNum",
    "test worker getTaskNum",
    "test worker getTaskManager",
    "test workerId",
    "test workerAttemptId",
    "tet worker initFinished",
    "test worker getInitMinclock",
    "test worker loacation",
    "test AppId",
    "test Conf",
    "test UserName",
    "master location",
    "masterClient",
    "test psAgent",
    "test worker get dataBlockManager",
    "workerGroup.getSplits();",
    "application",
    "lcation",
    "workerGroup info",
    "worker info",
    "task",
    "Matrix parameters",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "Create an Angel client",
    "Add different types of matrix",
    "DenseIntMatrix expect = new DenseIntMatrix(diRow, diCol);",
    "using mock object",
    "verification",
    "Stubbing",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "Init model saver & loader",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "Check is there save request",
    "Check is there load request",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "LOG.info(\"Epoch=\" + epoch + \" Metrics=\" + metrics);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "saveContext.setTmpSavePath(HdfsUtil.generateTmpDirectory(context.getConf(),",
    "context.getApplicationId().toString(), new Path(saveContext.getSavePath())).toString());",
    "Filter old epoch trigger first",
    "Split the user request to sub-requests to pss",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Split the user request to sub-requests to pss",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and EXECUTE_SUCCESSED, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Add one sync matrix",
    "addSyncMatrix();",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "for(Entry<ParameterServerId, Map<Integer, MatrixMeta>> psEntry : matrixPartitionsOnPS.entrySet()) {",
    "LOG.info(\"ps id = \" + psEntry.getKey());",
    "Map<Integer, MatrixMeta> matrixIdToMetaMap = psEntry.getValue();",
    "for(Entry<Integer, MatrixMeta> metaEntry : matrixIdToMetaMap.entrySet()) {",
    "LOG.info(\"matrix id = \" + metaEntry.getKey());",
    "LOG.info(\"matrix partitons number = \" + metaEntry.getValue().getPartitionMetas().size());",
    "}",
    "}",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "clock first",
    "wait",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Plus a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Update a vector/matrix to the matrix stored in pss",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get values from pss use row/column indices",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ PSF get/update, use can implement their own psf",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "/ Get a row or a batch of rows",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO:",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "TODO:",
    "Doing average or not",
    "Filter un-important update",
    "Split this row according the matrix partitions",
    "Set split context",
    "Remove the row from matrix",
    "TODO",
    "TODO: write map default value",
    "TODO:",
    "TODO:",
    "TODO:",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.error(\"channel \" + ctx.channel() + \" inactive\");",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "LOG.error(\"put response message queue failed \", e);",
    "Use Epoll for linux",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "private Channel getChannel(Location loc) throws Exception {",
    "return channelManager.getOrCreateChannel(new Location(loc.getIp(), loc.getPort() + 1));",
    "}",
    "private GenericObjectPool<Channel> getChannelPool(Location loc) throws InterruptedException {",
    "return channelManager.getOrCreateChannelPool(new Location(loc.getIp(), loc.getPort() + 1), PSAgentContext",
    ".get()",
    ".getConf()",
    ".getInt(AngelConf.ANGEL_WORKER_TASK_NUMBER,",
    "AngelConf.DEFAULT_ANGEL_WORKER_TASK_NUMBER));",
    "}",
    "LOG.error(\"send request \" + request + \" is interrupted\");",
    "LOG.error(\"send request \" + request + \" failed, \", e);",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "request.getContext().setChannelPool(pool);",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "updateMatrixCache(request.getPartKey(), response.getPartition());",
    "updateMatrixCache(request.getPartKey(), response.getRowsSplit());",
    "TODO",
    "ServerRow rowSplit = PSAgentContext.get().getMatricesCache()",
    ".getRowSplit(request.getPartKey().getMatrixId(), request.getPartKey(),",
    "request.getRowIndex());",
    "response.setRowSplit(rowSplit);",
    "updateMatrixCache(request.getPartKey(), response.getRowSplit());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "LOG.info(\"user request id \" + request.getUserRequestId());",
    "TODO",
    "private void updateMatrixCache(PartitionKey partKey, ServerPartition partition) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, partition);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, ServerRow rowSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowSplit);",
    "}",
    "private void updateMatrixCache(PartitionKey partKey, List<ServerRow> rowsSplit) {",
    "PSAgentContext.get().getMatricesCache().update(partKey.getMatrixId(), partKey, rowsSplit);",
    "}",
    "Get partitions for this row",
    "Distinct get row requests",
    "Need get from ps or storage/cache",
    "Switch to new request id, send a new request",
    "First get this row from matrix storage",
    "MatrixStorage matrixStorage =",
    "PSAgentContext.get().getMatrixStorageManager().getMatrixStoage(matrixId);",
    "TVector row = matrixStorage.getRow(rowIndex);",
    "if (row != null && row.getClock() >= clock) {",
    "result.set(row);",
    "return row;",
    "}",
    "Get row splits of this row from the matrix cache first",
    "responseCache.addSubResponse(rowSplit);",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "matrixStorage.addRow(rowIndex, row);",
    "Just wait result",
    "Split the param use matrix partitions",
    "Send request to PSS",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Send request to PSS",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "LOG.info(\"get row split use time=\" + (System.currentTimeMillis() - startTs));",
    "LOG.info(\"start to request \" + requestId);",
    "LOG.info(\"start to request \" + requestId);",
    "Split param use matrix partitons",
    "If all sub-results are received, just remove request and result cache",
    "LOG.info(\"request = \" + request + \", cache = \" + cache);",
    "LOG.info(\"start to merge \" + cache + \" for request \" + request);",
    "LOG.info(\"psf get merge use time = \" + (System.currentTimeMillis() - startTs));",
    "Split this row according the matrix partitions",
    "Set split context",
    "Split this row according the matrix partitions",
    "Set split context",
    "long startTs = System.currentTimeMillis();",
    "LOG.error(\"combine use time = \" + (System.currentTimeMillis() - startTs));",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO",
    "TODO",
    "/////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "Now we just support pipelined row splits merging for dense type row",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load ml conf file for graph based algorithm",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "throw new AngelException(e);",
    "JobStateProto jobState = report.getJobState();",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "private volatile PS2PSPusherImpl ps2PSPusher;",
    "TODO",
    "Add tokens to new user so that it may execute its task correctly.",
    "TODO",
    "to exit",
    "TODO",
    "TODO",
    "ps2PSPusher.recover(ProtobufUtil.convert(needRecoverParts.get(i)));",
    "context.getSnapshotManager().processRecovery();",
    "First check snapshot",
    "Check load path setting",
    "TODO",
    "if(ps2PSPusher != null) {",
    "ps2PSPusher.start();",
    "}",
    "public PS2PSPusherImpl getPs2PSPusher() {",
    "return ps2PSPusher;",
    "}",
    "LOG.error(\"send response of request \" + requestToString(clientId, seqId) + \" failed \");",
    "LOG.error(\"send response of request failed, request seqId=\" + seqId + \", channel=\" + ch, ex);",
    "Release the input buffer",
    "Release the input buffer",
    "1. handle the rpc, get the response",
    "Release the input buffer",
    "2. Serialize the response",
    "Send the serialized response",
    "Just serialize the head",
    "Exception happened",
    "Just serialize the head",
    "Exception happened",
    "Reset the response and allocate buffer again",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "TODO",
    "context.getPS2PSPusher().put(request, in, partLoc);",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "TODO",
    "return ServerState.GENERAL;",
    "Use Epoll for linux",
    "public String uuid;",
    "public void setChannelPool(GenericObjectPool<Channel> channelPool) {",
    "this.channelPool = channelPool;",
    "}",
    "private final ParameterServer psServer;",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO:default value",
    "TODO",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// disk io method, for model read/load",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////// network io method, for model transform",
    "///////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "Methods with out lock operation, you must call startWrite/startRead before using these methods",
    "and call endWrite/endRead after",
    "////////////////////////////////////////////////////////////////////////////////////////////////",
    "TODO: dynamic add/delete row",
    "private final List<PartitionKey> partitionKeys;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "Use Epoll for linux",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "First check the state of the channels in the pool, if a channel is unused, just return",
    "If all channels are in use, create a new channel or wait",
    "Create a new channel",
    "add the PSAgentContext,need fix",
    "TODO:add more vector type",
    "TODO : subDim set",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "write the max abs",
    "---------------------------------------------------",
    "---------------------------------------------------",
    "---------------------------------------------------------------",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "axis = 0: on rows",
    "axis = 1: on cols",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "1. find the insert point",
    "2. check the capacity and insert",
    "3. increase size",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "multi-rehash",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "slower but memory efficient, for small vector only",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "no rehashor one onle rehash is required, nothing to optimization",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "to avoid multi-rehash",
    "dger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "sger(int m, int n, double alpha, double [ ] x, int incx, double [ ] y, int incy, double [ ] a, int lda)",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "IntDoubleVector vector = (IntDoubleVector) ((GetRowResult) matrixClient.get(func)).getRow();",
    "add dense double matrix",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "true, false",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "conf.setDouble(MLConf.ML_DATA_POSNEG_RATIO(), posnegRatio);",
    "predictTest();",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "class number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set log path",
    "Set trainning data path",
    "Set save model path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "predictTest();",
    "Set actionType train",
    "Set training data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log save path",
    "Set actionType train",
    "Set testing data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "predictTest();",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "loss delta",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "predictTest();",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Data is classification",
    "Model is classification",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "gradient descent first, then truncated",
    "StringBuffer sb = new StringBuffer();",
    "sb.append(\"GetColsParam values \");",
    "sb.append(values[i] +\" \");",
    "LOG.error(sb.toString());",
    "StringBuffer sb = new StringBuffer();",
    "sb.append(\"GetColsParams \");",
    "for (int i = 0; i < this.cols.length; i ++) {",
    "sb.append(this.cols[i] + \" \");",
    "}",
    "LOG.error(sb.toString());",
    "Arrays.sort(rows);",
    "int sum = 0;",
    "System.out.println(\"pkeys.size=\" + pkeys.size());",
    "params.add(new PartitionGetColsParam(matrixId, pkeys.get(0), rows, cols));",
    "sum += part.length;",
    "LOG.info(\"split length = \" + sum + \", cols = \" + cols.length);",
    "System.out.println(\"deserialize cols.length=\" + nCols);",
    "System.out.print(\"deserialize \");",
    "System.out.print(cols[c] + \" \");",
    "System.out.println();",
    "System.out.print(\"PartitionGet \");",
    "for (int i = 0; i < cols.length; i ++) {",
    "System.out.print(cols[i] + \" \");",
    "}",
    "System.out.println();",
    "System.out.println(\"doGet Double cols.length=\" + cols.length);",
    "LOG.info(\"Here merge\");",
    "int sum = 0;",
    "sum += rrr.cols.length;",
    "LOG.error(\"double rrr.cols = \" + sum + \", map size = \" + maps.size());",
    "IntDoubleVector[] allVectors = new IntDoubleVector[allColumns.length];",
    "for (int i = 0; i < allColumns.length; i ++)",
    "allVectors[i] = maps.get(allColumns[i]);",
    "return new GetColsResult(VFactory.denseLongVector(allColumns),",
    "VFactory.compIntDoubleVector(dim, allVectors, allVectors.length));",
    "int sum = 0;",
    "sum += cols.length;",
    "System.out.print(\" \" + cols[i]);",
    "System.out.println();",
    "LOG.error(\"float rrr.cols = \" + sum + \", map size = \" + maps.size());",
    "IntFloatVector[] allVectors = new IntFloatVector[allColumns.length];",
    "for (int i = 0; i < allColumns.length; i ++)",
    "allVectors[i] = maps.get(allColumns[i]);",
    "return new GetColsResult(VFactory.denseLongVector(allColumns),",
    "VFactory.compIntFloatVector(dim, allVectors, allVectors.length));",
    "TODO Auto-generated method stub",
    "ground truth: positive, precision: positive",
    "start row index for words",
    "start row index for docs",
    "doc ids",
    "topic assignments",
    "word to docs reverse index",
    "count word",
    "build word start index",
    "build word to doc reverse idx",
    "build dks",
    "dks = new TraverseHashMap[n_docs];",
    "for (int d = 0; d < n_docs; d++) {",
    "if (K < Short.MAX_VALUE) {",
    "if (docs.get(d).len < Byte.MAX_VALUE)",
    "dks[d] = new S2BTraverseMap(docs.get(d).len);",
    "if (docs.get(d).len < Short.MAX_VALUE)",
    "dks[d] = new S2STraverseMap(Math.min(K, docs.get(d).len));",
    "else",
    "dks[d] = new S2ITraverseMap(Math.min(K, docs.get(d).len));",
    "} else {",
    "dks[d] = new I2ITranverseMap(Math.min(K, docs.get(d).len));",
    "}",
    "}",
    "build dks",
    "allocate update maps",
    "Skip if no token for this word",
    "Check whether error when fetching word-topic",
    "Build FTree for current word",
    "current doc",
    "old topic assignment",
    "Check if error happens. if this happen, it's probably that failures happen to servers.",
    "We need to adjust the memory settings or network fetching parameters.",
    "Update statistics if needed",
    "Calculate psum and sample new topic",
    "Update statistics if needed",
    "Assign new topic",
    "Skip if no token for this word",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "calculate columns",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "node's end index in instancePos, instances in [start, end] belong to a tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "this.forest[this.currentTree].fset = sampleFeatureVector.getStorage().getValues();",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "1. decide nodes that should be calculated",
    "2. decide calculated and subtracted tree nodes",
    "3. calculate threads",
    "wait until all threads finish",
    "4. subtract threads",
    "wait until all threads finish",
    "5. send histograms to PS",
    "6. update histogram cache",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "this.phase = GBDTPhase.AFTER_SPLIT;",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "update local replica",
    "create AfterSplit task",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current depth",
    "finish current tree",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "1. update predictions of training data",
    "2. update predictions of validation data",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "if not -1, sufficient space will be allocated at once",
    "copy the highest levels",
    "copy baseBuffer",
    "merge two non-empty quantile sketches",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fSet, fid);",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "if (left > end) return end - start;",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "max and min of each feature",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "TODO: only support dense double now",
    "int sendStartCol = (int) row.getStartCol();",
    "find the max abs",
    "compress data",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "v1.5.1": [
    "implement Zip2Map interface",
    "implement Zip3Map interface",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "TODO: Have to deal with default values",
    "asum += Math.abs(data.defaultReturnValue()) * (entireSize - data.size());",
    "TODO: Have to deal with default values",
    "sum += (entireSize - keys.size()) * data1.defaultReturnValue() * data2.defaultReturnValue();",
    "TODO: Have to deal with default values",
    "qSum += Math.pow(data.defaultReturnValue(), 2) * (entireSize - data.size());",
    "TODO: Have to deal with default values",
    "asum += data.defaultReturnValue() * (entireSize - data.size());",
    "find the max abs",
    "compress data",
    "TODO: a better way is needed to deal with defaultValue",
    "TODO: a better way is needed to deal with defaultValue",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Input Path, please modify ${YOUR_ANGEL_HOME} as your local angel installation path,",
    "e.g. if your path is /home/angel/angel_1.3.0, your input_path should be:",
    "\"file:///home/angel/angel_1.3.0/data/exampledata/GBDTLocalExampleData/agaricus.txt.train\",",
    "and your out_path could be: \"file:///home/angel/angel_1.3.0/data/output\"",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "set input, output path",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample ratio",
    "Data format,libsvm or dummy",
    "Train batch number per epoch",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set job queue, if you use YARN deploy mode, you can set job queue by",
    "self.conf.set('mapreduce.job.queue.name', 'default')",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #tast, #ps",
    "set sgd LR algorithim parameters # feature # epoch",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Input Path, please modify ${YOUR_ANGEL_HOME} as your local angel installation path,",
    "e.g. if your path is /home/angel/angel_1.3.0, your input_path should be:",
    "\"file:///home/angel/angel_1.3.0/data/exampledata/GBDTLocalExampleData/agaricus.txt.train\",",
    "and your out_path could be: \"file:///home/angel/angel_1.3.0/data/output\"",
    "if you need, you can delete the annotation mark before Line35,Line36,Line61,Line62, so",
    "there is no need for you to pass the configs every time you submit the pyangel job.",
    "input_path = \"file:///${YOUR_ANGEL_HOME}/data/exampledata/GBDTLocalExampleData/agaricus.txt.train\"",
    "output_path = \"file:///${YOUR_ANGEL_HOME}/data/output\"",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Use local deploy mode and dummy data spliter",
    "set input] = output path",
    "self.conf[AngelConf.ANGEL_TRAIN_DATA_PATH] = input_path",
    "self.conf[AngelConf.ANGEL_SAVE_MODEL_PATH] = output_path",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic self.configuration key",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "Set PS Model values",
    "Wait for all tasks finish this clock",
    "Get values of index array",
    "Set PS Model values",
    "Wait for all tasks finish this clock",
    "Get values of index array",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Default location for user home directories #",
    "Default value for FS_HOME_DIR_KEY #",
    "Default umask for files created in HDFS #",
    "Default value for FS_PERMISSIONS_UMASK_KEY #",
    "How often does RPC client send pings to RPC server #",
    "Default value for IPC_PING_INTERVAL_KEY #",
    "Enables pings from RPC client to the server #",
    "Default value of IPC_CLIENT_PING_KEY #",
    "Responses larger than this will be logged #",
    "Default value for IPC_SERVER_RPC_MAX_RESPONSE_SIZE_KEY #",
    "Number of threads in RPC server reading from the socket #",
    "Default value for IPC_SERVER_RPC_READ_THREADS_KEY #",
    "How many calls per handler are allowed in the queue. #",
    "Default value for IPC_SERVER_HANDLER_QUEUE_SIZE_KEY #",
    "Internal buffer size for Lzo compressordecompressors #/",
    "Default value for IO_COMPRESSION_CODEC_LZO_BUFFERSIZE_KEY #",
    "This is for specifying the implementation for the mappings from",
    "hostnames to the racks they belong to",
    "Internal buffer size for Snappy compressordecompressors #/",
    "Default value for IO_COMPRESSION_CODEC_SNAPPY_BUFFERSIZE_KEY #",
    "Internal buffer size for Snappy compressordecompressors #/",
    "Default value for IO_COMPRESSION_CODEC_SNAPPY_BUFFERSIZE_KEY #",
    "Service Authorization",
    "HA health monitor and failover controller.",
    "How often to retry connecting to the service.",
    "How often to check the service.",
    "How long to sleep after an unexpected RPC error.",
    "Timeout for the actual monitorHealth() calls. *",
    "Timeout that the FC waits for the new active to become active",
    "Timeout that the FC waits for the old active to go to standby",
    "FC connection retries for graceful fencing",
    "Timeout that the CLI (manual) FC waits for monitorHealth, getServiceState",
    "Static user web-filter properties.",
    "See StaticUserWebFilter.",
    "EnableDisable aliases serving from jetty",
    "Path to the Kerberos ticket cache.  Setting this will force",
    "UserGroupInformation to use only this ticket cache file when creating a",
    "FileSystem instance.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Input Path, please modify ${YOUR_ANGEL_HOME} as your local angel installation path,",
    "e.g. if your path is /home/angel/angel_1.3.0, your input_path should be:",
    "\"file:///home/angel/angel_1.3.0/data/exampledata/GBDTLocalExampleData/agaricus.txt.train\",",
    "and your out_path could be: \"file:///home/angel/angel_1.3.0/data/output\"",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set GBDT category feature",
    "set input, output path",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample ratio",
    "Data format,libsvm or dummy",
    "Train batch number per epoch",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set job queue, if you use YARN deploy mode, you can set job queue by",
    "self.conf.set('mapreduce.job.queue.name', 'default')",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #tast, #ps",
    "set sgd LR algorithim parameters # feature # epoch",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Set log path",
    "Set actionType train",
    "Load Model from HDFS.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic self.configuration key",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "If the enviroment has ANGEL_HOME set trust it.",
    "Add the path of the PyAngel module if it exists",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "Normalize the paths",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Get Java HashMap instance which converted from a python dict",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Run ParameterServer  & ParameterServerAgent",
    "Only Run ParameterServer",
    "Run ParameterServer & Worker(embedded ParameterServerAgent)",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To Do",
    "Modify the way to get current Angel version",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Launch the Py4j gateway",
    "Start a socket that will be used by PythonGatewayServer to communicate its port to python sub-proc",
    "Don't send ctrl-c / SIGINT to the Java gateway:",
    "We use select() here in order to avoid blocking indefinitely if the subprocess dies",
    "before connecting",
    "Determine which ephemeral port the server started on:",
    "Connect to the gateway",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To do: need python edition of TVector",
    "To do: need python edition of GetFunc",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Create an angel job client",
    "Submit this application",
    "Create a KMeans model",
    "Load model meta to client",
    "Start",
    "Run user task and wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Save the trained model to HDFS",
    "Stop",
    "Create an angel job client",
    "Submit this application",
    "Create KMeans model",
    "Add the model meta to client",
    "Start",
    "Run user task and wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Stop",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Training job to obtain a model",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Create an angel job client",
    "Submit this application",
    "Create a model",
    "Load model meta to client",
    "Run user task",
    "Wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Save the incremental trained model to HDFS",
    "Stop",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "If the enviroment has ANGEL_HOME set trust it.",
    "Add the path of the PyAngel module if it exists",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "Normalize the paths",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Get Java HashMap instance which converted from a python dict",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Run ParameterServer  & ParameterServerAgent",
    "Only Run ParameterServer",
    "Run ParameterServer & Worker(embedded ParameterServerAgent)",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To Do",
    "Modify the way to get current Angel version",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Launch the Py4j gateway",
    "Start a socket that will be used by PythonGatewayServer to communicate its port to python sub-proc",
    "Don't send ctrl-c / SIGINT to the Java gateway:",
    "We use select() here in order to avoid blocking indefinitely if the subprocess dies",
    "before connecting",
    "Determine which ephemeral port the server started on:",
    "Connect to the gateway",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To do: need python edition of TVector",
    "To do: need python edition of GetFunc",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Training job to obtain a model",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Create an angel job client",
    "Submit this application",
    "Create a model",
    "Load model meta to client",
    "Run user task",
    "Wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Save the incremental trained model to HDFS",
    "Stop",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "mMatrix.setNnz(100000000);",
    "mMatrix.setNnz(100000000);",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "DenseIntVector deltaVec = new DenseIntVector(100000, delta);",
    "deltaVec.setMatrixId(matrixW1Id);",
    "deltaVec.setRowId(0);",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "group0Id = new WorkerGroupId(0);",
    "worker0Id = new WorkerId(group0Id, 0);",
    "worker0Attempt0Id = new WorkerAttemptId(worker0Id, 0);",
    "task0Id = new TaskId(0);",
    "task1Id = new TaskId(1);",
    "test this func in testWriteTo",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "LOG.info(index[0] + \" \" + value[0]);",
    "LOG.info(index[1] + \" \" + value[1]);",
    "LOG.info(index[2] + \" \" + value[2]);",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plusBy",
    "@Test",
    "public void dotDenseFloatVector() throws Exception {",
    "int dim = 1000;",
    "Random random = new Random(System.currentTimeMillis());",
    "",
    "double[] values = new double[dim];",
    "float[] values_1 = new float[dim];",
    "for (int i = 0; i < dim; i++) {",
    "values[i] = random.nextDouble();",
    "values_1[i] = random.nextFloat();",
    "}",
    "",
    "DenseDoubleVector vec = new DenseDoubleVector(dim, values);",
    "TDoubleVector vec_1 = new DenseFloatVector(dim, values_1);",
    "",
    "double sum = 0.0;",
    "for (int i = 0; i < dim; i++) {",
    "sum += values[i] * values_1[i];",
    "}",
    "",
    "assertEquals(sum, vec.dot(vec_1));",
    "",
    "}",
    "@Test",
    "public void plusDenseFlaotVector() throws Exception {",
    "double[] value_1 = new double[]{0.1, 0.2, 0.3, 0.4, 0.5};",
    "double[] value_2 = new double[]{0.1f, 0.2f, 0.3f, 0.4f, 0.5f};",
    "DenseDoubleVector vec = new DenseDoubleVector(5, value_1);",
    "TDoubleVector vec_1 = new DenseFloatVector(5, value_2);",
    "",
    "TDoubleVector vec_2 = vec.plus(vec_1);",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(value_1[i] + value_2[i], vec_2.get(i));",
    "",
    "",
    "TDoubleVector vec_3 = vec.plus(vec_1, 2.0);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec_3.get(i), value_1[i] + 2 * value_2[i]);",
    "",
    "double[] oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + vec_1.get(i));",
    "",
    "oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1, 3);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + 3 * vec_1.get(i));",
    "}",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "@Test",
    "public void plusBy3() throws Exception {",
    "float[][] value = {{1.0f, 2.0f}, {3.0f, 4.0f}};",
    "DenseFloatMatrix mat = new DenseFloatMatrix(2, 2,value);",
    "TFloatVector vec = new DenseFloatVector(2, new float[]{1.0f, 1.0f});",
    "vec.setRowId(0);",
    "TDoubleVector vec_1 = new DenseDoubleVector(2, new double[]{1.0f, 1.0f});",
    "vec_1.setRowId(1);",
    "TDoubleVector vec_2 = new SparseDoubleVector(2);",
    "vec_2.set(1, 1.0);",
    "vec_2.setRowId(0);",
    "",
    "mat.plusBy(vec);",
    "mat.plusBy(vec_1);",
    "mat.plusBy(vec_2);",
    "",
    "assertEquals(2.0f, mat.get(0, 0));",
    "assertEquals(4.0f, mat.get(0, 1));",
    "assertEquals(4.0f, mat.get(1, 0));",
    "assertEquals(5.0f, mat.get(1, 1));",
    "}",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "Start PS",
    "Start to run application",
    "Assert.assertTrue(index.length == row.size());",
    "Assert.assertTrue(index.length == row.size());",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "test worker getActiveTaskNum",
    "test worker getTaskNum",
    "test worker getTaskManager",
    "test workerId",
    "test workerAttemptId",
    "tet worker initFinished",
    "test worker getInitMinclock",
    "test worker loacation",
    "test AppId",
    "test Conf",
    "test UserName",
    "master location",
    "masterClient",
    "test psAgent",
    "test worker get dataBlockManager",
    "workerGroup.getSplits();",
    "application",
    "lcation",
    "workerGroup info",
    "worker info",
    "task",
    "Matrix parameters",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "Create an Angel client",
    "Add different types of matrix",
    "using mock object",
    "verification",
    "Stubbing",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "check if parameter server can commit now.",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Add mr",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "init and start master committer",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and COMMITTING, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "Filter it, removing zero values",
    "Doing average or not",
    "Split this row according the matrix partitions",
    "Add the splits to the result container",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "TODO: use Epoll for linux future",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "channelManager.printPools();",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "Check if the result of the sub-request is received",
    "Update received result number",
    "Get row splits received",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO Auto-generated method stub",
    "Check futures, if the result of a sub-request is received, put it to the result queue",
    "Now we just support pipelined row splits merging for dense type row",
    "Get partitions for this row",
    "First get this row from matrix storage",
    "If the row exists in the matrix storage and the clock value meets the requirements, just",
    "return",
    "Get row splits of this row from the matrix cache first",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "Wait until the clock value of this row is greater than or equal to the value",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "JobStateProto jobState = report.getJobState();",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "Add tokens to new user so that it may execute its task correctly.",
    "to exit",
    "context.getSnapshotManager().processRecovery();",
    "private final ParameterServer psServer;",
    "return ServerState.GENERAL;",
    "lock.readLock().lock();",
    "lock.readLock().unlock();",
    "data.rewind();",
    "lock.readLock().lock();",
    "lock.readLock().unlock();",
    "data.rewind();",
    "lock.readLock().lock();",
    "lock.readLock().unlock();",
    "data.rewind();",
    "output.writeInt(clock);",
    "clock = input.readInt();",
    "output.writeDouble(getDefaultValue());",
    "private final List<PartitionKey> partitionKeys;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "Mapping from taskId to clock value.",
    "TODO: use Epoll for linux future",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "add the PSAgentContext,need fix",
    "return this;",
    "return this;",
    "return this;",
    "return this;",
    "return this;",
    "TODO Should be implemented",
    "TODO Should be implemented",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "TODO:",
    "public String uuid;",
    "this.uuid = UUID.randomUUID().toString();",
    "byte [] data = uuid.getBytes();",
    "buf.writeInt(data.length);",
    "buf.writeBytes(data);",
    "int size = buf.readInt();",
    "byte [] data = new byte[size];",
    "buf.readBytes(data);",
    "uuid = new String(data);",
    "return \"PartitionRequest{\" + \"clock=\" + clock + \", partKey=\" + partKey + \", uuid=\" + uuid + \", comeFromPs=\"",
    "+ comeFromPs + \"} \" + super.toString();",
    "public String uuid;",
    "write the max abs",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "TODO Auto-generated constructor stub",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set feature number",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set FM predict output path",
    "Set actionType train",
    "Set feature number",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Submit GBDT Train Task",
    "Load Model from HDFS.",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, save model, log path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "number of mini batch within a update periorid",
    "Data format, libsvm or dummy",
    "Batch size",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "conf.setBoolean(MLConf.ML_INDEX_GET_ENABLE(), true);",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Sample ratio",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set FTRL LR algorithm parameters #feature #epoch",
    "FtrlLRPredictTest();",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType train",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set MLR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set feature number",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "Set",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set FM predict output path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation Ratio",
    "Data format",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set basic configuration keys",
    "Set data format",
    "Use local deploy mode",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd SVM algorithm parameters",
    "set input, output path",
    "Set save model path",
    "Set actionType train",
    "Set log path",
    "Submit LR Train Task",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log sava path",
    "Set actionType prediction",
    "double z=pre*y;",
    "if(z<=0) return 0.5-z;",
    "else if(z>0 && z<1) return 0.5*Math.pow(1-z,2);",
    "return 0.0;",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "TODO Auto-generated method stub",
    "start row index for words",
    "doc ids",
    "topic assignments",
    "count word",
    "build word start index",
    "build dks",
    "model.wtMat().increment(w, update);",
    "update.plusBy(t, 1);",
    "model.wtMat().increment(w, update);",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "calculate columns",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "3. set phase to GET_SKETCH",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "7. set phase to run active",
    "1. start threads of active tree nodes",
    "1.1. start threads for active nodes to generate histogram",
    "1.2. set thread status to batch num",
    "1.3. set the oplog to active",
    "2. check thread stats, if all threads finish, return",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "histogram = (TDoubleVector) ((GetRowResult) histMat.get(func)).getRow();",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "than the split value",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current tree",
    "finish current depth",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = startFid * 7; // each split contains 7 doubles",
    "System.out.println(\"Indices: \" + Arrays.toString(indices));",
    "t[i][code]++;",
    "else if (Math.random() > 0.5) {",
    "t[i][code] = freq;",
    "}",
    "System.out.println(\"Change from \" + t[i][code] + \" to \" + freq);",
    "ret = Math.min(ret, t[i][h[i].encode(key)]);",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "v1.5.0": [
    "implement Zip2Map interface",
    "implement Zip3Map interface",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "TODO: Have to deal with default values",
    "asum += Math.abs(data.defaultReturnValue()) * (entireSize - data.size());",
    "TODO: Have to deal with default values",
    "sum += (entireSize - keys.size()) * data1.defaultReturnValue() * data2.defaultReturnValue();",
    "TODO: Have to deal with default values",
    "qSum += Math.pow(data.defaultReturnValue(), 2) * (entireSize - data.size());",
    "TODO: Have to deal with default values",
    "asum += data.defaultReturnValue() * (entireSize - data.size());",
    "find the max abs",
    "compress data",
    "TODO: a better way is needed to deal with defaultValue",
    "TODO: a better way is needed to deal with defaultValue",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Input Path, please modify ${YOUR_ANGEL_HOME} as your local angel installation path,",
    "e.g. if your path is /home/angel/angel_1.3.0, your input_path should be:",
    "\"file:///home/angel/angel_1.3.0/data/exampledata/GBDTLocalExampleData/agaricus.txt.train\",",
    "and your out_path could be: \"file:///home/angel/angel_1.3.0/data/output\"",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "set input, output path",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample ratio",
    "Data format,libsvm or dummy",
    "Train batch number per epoch",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set job queue, if you use YARN deploy mode, you can set job queue by",
    "self.conf.set('mapreduce.job.queue.name', 'default')",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #tast, #ps",
    "set sgd LR algorithim parameters # feature # epoch",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Input Path, please modify ${YOUR_ANGEL_HOME} as your local angel installation path,",
    "e.g. if your path is /home/angel/angel_1.3.0, your input_path should be:",
    "\"file:///home/angel/angel_1.3.0/data/exampledata/GBDTLocalExampleData/agaricus.txt.train\",",
    "and your out_path could be: \"file:///home/angel/angel_1.3.0/data/output\"",
    "if you need, you can delete the annotation mark before Line35,Line36,Line61,Line62, so",
    "there is no need for you to pass the configs every time you submit the pyangel job.",
    "input_path = \"file:///${YOUR_ANGEL_HOME}/data/exampledata/GBDTLocalExampleData/agaricus.txt.train\"",
    "output_path = \"file:///${YOUR_ANGEL_HOME}/data/output\"",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Use local deploy mode and dummy data spliter",
    "set input] = output path",
    "self.conf[AngelConf.ANGEL_TRAIN_DATA_PATH] = input_path",
    "self.conf[AngelConf.ANGEL_SAVE_MODEL_PATH] = output_path",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic self.configuration key",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "Set PS Model values",
    "Wait for all tasks finish this clock",
    "Get values of index array",
    "Set PS Model values",
    "Wait for all tasks finish this clock",
    "Get values of index array",
    "Pull func1 = new Pull(client.getMatrixId(), 1);",
    "taskContext.globalSync(client.getMatrixId());",
    "TVector row1 = ((GetRowResult) client.get(func1)).getRow();",
    "double [] delta1 = new double[col];",
    "for(int i = 0; i < col; i++) {",
    "delta1[i] = 2.0;",
    "}",
    "DenseDoubleVector deltaV1 = new DenseDoubleVector(col, delta1);",
    "deltaV1.setMatrixId(client.getMatrixId());",
    "deltaV1.setRowId(1);",
    "client.increment(deltaV1);",
    "conf.setInt(AngelConf.ANGEL_STALENESS, -1);",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Default location for user home directories #",
    "Default value for FS_HOME_DIR_KEY #",
    "Default umask for files created in HDFS #",
    "Default value for FS_PERMISSIONS_UMASK_KEY #",
    "How often does RPC client send pings to RPC server #",
    "Default value for IPC_PING_INTERVAL_KEY #",
    "Enables pings from RPC client to the server #",
    "Default value of IPC_CLIENT_PING_KEY #",
    "Responses larger than this will be logged #",
    "Default value for IPC_SERVER_RPC_MAX_RESPONSE_SIZE_KEY #",
    "Number of threads in RPC server reading from the socket #",
    "Default value for IPC_SERVER_RPC_READ_THREADS_KEY #",
    "How many calls per handler are allowed in the queue. #",
    "Default value for IPC_SERVER_HANDLER_QUEUE_SIZE_KEY #",
    "Internal buffer size for Lzo compressordecompressors #/",
    "Default value for IO_COMPRESSION_CODEC_LZO_BUFFERSIZE_KEY #",
    "This is for specifying the implementation for the mappings from",
    "hostnames to the racks they belong to",
    "Internal buffer size for Snappy compressordecompressors #/",
    "Default value for IO_COMPRESSION_CODEC_SNAPPY_BUFFERSIZE_KEY #",
    "Internal buffer size for Snappy compressordecompressors #/",
    "Default value for IO_COMPRESSION_CODEC_SNAPPY_BUFFERSIZE_KEY #",
    "Service Authorization",
    "HA health monitor and failover controller.",
    "How often to retry connecting to the service.",
    "How often to check the service.",
    "How long to sleep after an unexpected RPC error.",
    "Timeout for the actual monitorHealth() calls. *",
    "Timeout that the FC waits for the new active to become active",
    "Timeout that the FC waits for the old active to go to standby",
    "FC connection retries for graceful fencing",
    "Timeout that the CLI (manual) FC waits for monitorHealth, getServiceState",
    "Static user web-filter properties.",
    "See StaticUserWebFilter.",
    "EnableDisable aliases serving from jetty",
    "Path to the Kerberos ticket cache.  Setting this will force",
    "UserGroupInformation to use only this ticket cache file when creating a",
    "FileSystem instance.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Input Path, please modify ${YOUR_ANGEL_HOME} as your local angel installation path,",
    "e.g. if your path is /home/angel/angel_1.3.0, your input_path should be:",
    "\"file:///home/angel/angel_1.3.0/data/exampledata/GBDTLocalExampleData/agaricus.txt.train\",",
    "and your out_path could be: \"file:///home/angel/angel_1.3.0/data/output\"",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set GBDT category feature",
    "set input, output path",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample ratio",
    "Data format,libsvm or dummy",
    "Train batch number per epoch",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set job queue, if you use YARN deploy mode, you can set job queue by",
    "self.conf.set('mapreduce.job.queue.name', 'default')",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #tast, #ps",
    "set sgd LR algorithim parameters # feature # epoch",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Set log path",
    "Set actionType train",
    "Load Model from HDFS.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic self.configuration key",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "If the enviroment has ANGEL_HOME set trust it.",
    "Add the path of the PyAngel module if it exists",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "Normalize the paths",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Get Java HashMap instance which converted from a python dict",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Run ParameterServer  & ParameterServerAgent",
    "Only Run ParameterServer",
    "Run ParameterServer & Worker(embedded ParameterServerAgent)",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To Do",
    "Modify the way to get current Angel version",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Launch the Py4j gateway",
    "Start a socket that will be used by PythonGatewayServer to communicate its port to python sub-proc",
    "Don't send ctrl-c / SIGINT to the Java gateway:",
    "We use select() here in order to avoid blocking indefinitely if the subprocess dies",
    "before connecting",
    "Determine which ephemeral port the server started on:",
    "Connect to the gateway",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To do: need python edition of TVector",
    "To do: need python edition of GetFunc",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Create an angel job client",
    "Submit this application",
    "Create a KMeans model",
    "Load model meta to client",
    "Start",
    "Run user task and wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Save the trained model to HDFS",
    "Stop",
    "Create an angel job client",
    "Submit this application",
    "Create KMeans model",
    "Add the model meta to client",
    "Start",
    "Run user task and wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Stop",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Training job to obtain a model",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Create an angel job client",
    "Submit this application",
    "Create a model",
    "Load model meta to client",
    "Run user task",
    "Wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Save the incremental trained model to HDFS",
    "Stop",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "If the enviroment has ANGEL_HOME set trust it.",
    "Add the path of the PyAngel module if it exists",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "Normalize the paths",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Get Java HashMap instance which converted from a python dict",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Run ParameterServer  & ParameterServerAgent",
    "Only Run ParameterServer",
    "Run ParameterServer & Worker(embedded ParameterServerAgent)",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To Do",
    "Modify the way to get current Angel version",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Launch the Py4j gateway",
    "Start a socket that will be used by PythonGatewayServer to communicate its port to python sub-proc",
    "Don't send ctrl-c / SIGINT to the Java gateway:",
    "We use select() here in order to avoid blocking indefinitely if the subprocess dies",
    "before connecting",
    "Determine which ephemeral port the server started on:",
    "Connect to the gateway",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To do: need python edition of TVector",
    "To do: need python edition of GetFunc",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Training job to obtain a model",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Create an angel job client",
    "Submit this application",
    "Create a model",
    "Load model meta to client",
    "Run user task",
    "Wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Save the incremental trained model to HDFS",
    "Stop",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "mMatrix.setNnz(100000000);",
    "mMatrix.setNnz(100000000);",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "DenseIntVector deltaVec = new DenseIntVector(100000, delta);",
    "deltaVec.setMatrixId(matrixW1Id);",
    "deltaVec.setRowId(0);",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "group0Id = new WorkerGroupId(0);",
    "worker0Id = new WorkerId(group0Id, 0);",
    "worker0Attempt0Id = new WorkerAttemptId(worker0Id, 0);",
    "task0Id = new TaskId(0);",
    "task1Id = new TaskId(1);",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "test this func in testWriteTo",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "LOG.info(index[0] + \" \" + value[0]);",
    "LOG.info(index[1] + \" \" + value[1]);",
    "LOG.info(index[2] + \" \" + value[2]);",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plusBy",
    "@Test",
    "public void dotDenseFloatVector() throws Exception {",
    "int dim = 1000;",
    "Random random = new Random(System.currentTimeMillis());",
    "",
    "double[] values = new double[dim];",
    "float[] values_1 = new float[dim];",
    "for (int i = 0; i < dim; i++) {",
    "values[i] = random.nextDouble();",
    "values_1[i] = random.nextFloat();",
    "}",
    "",
    "DenseDoubleVector vec = new DenseDoubleVector(dim, values);",
    "TDoubleVector vec_1 = new DenseFloatVector(dim, values_1);",
    "",
    "double sum = 0.0;",
    "for (int i = 0; i < dim; i++) {",
    "sum += values[i] * values_1[i];",
    "}",
    "",
    "assertEquals(sum, vec.dot(vec_1));",
    "",
    "}",
    "@Test",
    "public void plusDenseFlaotVector() throws Exception {",
    "double[] value_1 = new double[]{0.1, 0.2, 0.3, 0.4, 0.5};",
    "double[] value_2 = new double[]{0.1f, 0.2f, 0.3f, 0.4f, 0.5f};",
    "DenseDoubleVector vec = new DenseDoubleVector(5, value_1);",
    "TDoubleVector vec_1 = new DenseFloatVector(5, value_2);",
    "",
    "TDoubleVector vec_2 = vec.plus(vec_1);",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(value_1[i] + value_2[i], vec_2.get(i));",
    "",
    "",
    "TDoubleVector vec_3 = vec.plus(vec_1, 2.0);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec_3.get(i), value_1[i] + 2 * value_2[i]);",
    "",
    "double[] oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + vec_1.get(i));",
    "",
    "oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1, 3);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + 3 * vec_1.get(i));",
    "}",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "@Test",
    "public void plusBy3() throws Exception {",
    "float[][] value = {{1.0f, 2.0f}, {3.0f, 4.0f}};",
    "DenseFloatMatrix mat = new DenseFloatMatrix(2, 2,value);",
    "TFloatVector vec = new DenseFloatVector(2, new float[]{1.0f, 1.0f});",
    "vec.setRowId(0);",
    "TDoubleVector vec_1 = new DenseDoubleVector(2, new double[]{1.0f, 1.0f});",
    "vec_1.setRowId(1);",
    "TDoubleVector vec_2 = new SparseDoubleVector(2);",
    "vec_2.set(1, 1.0);",
    "vec_2.setRowId(0);",
    "",
    "mat.plusBy(vec);",
    "mat.plusBy(vec_1);",
    "mat.plusBy(vec_2);",
    "",
    "assertEquals(2.0f, mat.get(0, 0));",
    "assertEquals(4.0f, mat.get(0, 1));",
    "assertEquals(4.0f, mat.get(1, 0));",
    "assertEquals(5.0f, mat.get(1, 1));",
    "}",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "Start PS",
    "Start to run application",
    "Assert.assertTrue(index.length == row.size());",
    "Assert.assertTrue(index.length == row.size());",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "test worker getActiveTaskNum",
    "test worker getTaskNum",
    "test worker getTaskManager",
    "test workerId",
    "test workerAttemptId",
    "tet worker initFinished",
    "test worker getInitMinclock",
    "test worker loacation",
    "test AppId",
    "test Conf",
    "test UserName",
    "master location",
    "masterClient",
    "test psAgent",
    "test worker get dataBlockManager",
    "workerGroup.getSplits();",
    "application",
    "lcation",
    "workerGroup info",
    "worker info",
    "task",
    "Matrix parameters",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "Create an Angel client",
    "Add different types of matrix",
    "using mock object",
    "verification",
    "Stubbing",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "Init Client manager",
    "Init PS Client manager",
    "init parameter server manager",
    "recover task information if needed",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "Check Workers",
    "Check PSS",
    "Check Clients",
    "Check PS Clients",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "check if parameter server can commit now.",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "check whether psagent heartbeat timeout",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "init and start master committer",
    "check whether parameter server heartbeat timeout",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and COMMITTING, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "check whether worker heartbeat timeout",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Init control connection manager",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Get psagent id",
    "Build PS control rpc client manager",
    "Build local location",
    "Initialize matrix meta information",
    "Start all services",
    "Stop all modules",
    "Stop all modules",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "Filter it, removing zero values",
    "Doing average or not",
    "Split this row according the matrix partitions",
    "Add the splits to the result container",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "LOG.debug(\"receive a message \" + ((ByteBuf) msg).readableBytes());",
    "TODO: use Epoll for linux future",
    "Update location table",
    "Remove the server from failed list",
    "Notify refresh success message to request dispatcher",
    "Check PS exist or not",
    "Check heartbeat timeout",
    "Check PS restart or not",
    "private final HashSet<ParameterServerId> refreshingServerSet;",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Add it to failed rpc list",
    "Add the server to gray server list",
    "Move from gray server list to failed server list",
    "Handle the RPCS to this server",
    "Submit the schedulable failed get RPCS",
    "Submit new get RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "If the queue is empty, just return 0",
    "If request is not over limit, just submit it",
    "Submit the schedulable failed get RPCS",
    "Submit new put RPCS",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "Check all pending RPCS",
    "Check get channel context",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "Check all failed PUT RPCS and put it to schedulable list for re-schedule",
    "&& (ts - item.getContext().getFailedTs() >= retryIntervalMs)) {",
    "for(Entry<PSLocation, Long> entry : psLocToLastChannelTsMap.entrySet()) {",
    "if(ts - entry.getValue() > requestTimeOut * 2)  {",
    "LOG.error(\"Can not get channel for PS \" + entry.getKey() + \" over \" + (ts - entry.getValue())",
    "+ \" milliseconds, close all channels to it\");",
    "closeChannels(entry.getKey());",
    "psLocToLastChannelTsMap.put(entry.getKey(), ts);",
    "}",
    "}",
    "LOG.debug(\"request failed \" + request + \", failedType=\" + failedType + \", errorLog=\" + errorLog);",
    "Remove all pending RPCS",
    "Close all channel to this PS",
    "Get server id and location for this request",
    "If location is null, means that the server is not ready",
    "Get the channel for the location",
    "Check if need get token first",
    "Serialize the request",
    "Send the request",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "Allocate the bytebuf and serialize the request",
    "find the partition request context from cache",
    "Check if the result of the sub-request is received",
    "Update received result number",
    "Get row splits received",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO Auto-generated method stub",
    "Check futures, if the result of a sub-request is received, put it to the result queue",
    "Now we just support pipelined row splits merging for dense type row",
    "Wait until the clock value of this row is greater than or equal to the value",
    "Get partitions for this row",
    "First get this row from matrix storage",
    "If the row exists in the matrix storage and the clock value meets the requirements, just",
    "return",
    "Get row splits of this row from the matrix cache first",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Use simple flow, do not use any cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "JobStateProto jobState = report.getJobState();",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "Add tokens to new user so that it may execute its task correctly.",
    "to exit",
    "context.getSnapshotManager().processRecovery();",
    "private final ParameterServer psServer;",
    "return ServerState.GENERAL;",
    "lock.readLock().lock();",
    "lock.readLock().unlock();",
    "data.rewind();",
    "lock.readLock().lock();",
    "lock.readLock().unlock();",
    "data.rewind();",
    "lock.readLock().lock();",
    "lock.readLock().unlock();",
    "data.rewind();",
    "output.writeInt(clock);",
    "clock = input.readInt();",
    "private final List<PartitionKey> partitionKeys;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "Mapping from taskId to clock value.",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "nnz = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "nnz++;",
    "}",
    "sparseRep = null;",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "}",
    "sparseRep = null;",
    "output.writeInt(data.length);",
    "@Override",
    "public void serialize(ByteBuf buf) {",
    "if (sparseRep != null)",
    "return serializeSparse();",
    "else if (denseRep != null)",
    "return serializeDense();",
    "return serializeEmpty();",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int idx = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "keysBuf.put(idx, keys[i]);",
    "valuesBuf.put(idx, values[i]);",
    "idx++;",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int ov, k, v;",
    "for (int i = 0; i < keys.length; i++) {",
    "if (used[i]) {",
    "k = keys[i];",
    "ov = denseRep.get(k);",
    "v = ov + values[i];",
    "denseRep.put(k, v);",
    "if (ov != 0 && v == 0)",
    "nnz--;",
    "}",
    "}",
    "TODO: use Epoll for linux future",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "add the PSAgentContext,need fix",
    "return this;",
    "return this;",
    "return this;",
    "return this;",
    "return this;",
    "TODO Should be implemented",
    "TODO Should be implemented",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "TODO:",
    "public String uuid;",
    "this.uuid = UUID.randomUUID().toString();",
    "byte [] data = uuid.getBytes();",
    "buf.writeInt(data.length);",
    "buf.writeBytes(data);",
    "int size = buf.readInt();",
    "byte [] data = new byte[size];",
    "buf.readBytes(data);",
    "uuid = new String(data);",
    "return \"PartitionRequest{\" + \"clock=\" + clock + \", partKey=\" + partKey + \", uuid=\" + uuid + \", comeFromPs=\"",
    "+ comeFromPs + \"} \" + super.toString();",
    "public String uuid;",
    "write the max abs",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "TODO Auto-generated constructor stub",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set feature number",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set FM predict output path",
    "Set actionType train",
    "Set feature number",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Submit GBDT Train Task",
    "Load Model from HDFS.",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, save model, log path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "number of mini batch within a update periorid",
    "Data format, libsvm or dummy",
    "Batch size",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "conf.setBoolean(MLConf.ML_INDEX_GET_ENABLE(), true);",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Sample ratio",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set FTRL LR algorithm parameters #feature #epoch",
    "FtrlLRPredictTest();",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set predict data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType train",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set MLR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set feature number",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "Set",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set FM predict output path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation Ratio",
    "Data format",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set basic configuration keys",
    "Set data format",
    "Use local deploy mode",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd SVM algorithm parameters",
    "set input, output path",
    "Set save model path",
    "Set actionType train",
    "Set log path",
    "Submit LR Train Task",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log sava path",
    "Set actionType prediction",
    "double z=pre*y;",
    "if(z<=0) return 0.5-z;",
    "else if(z>0 && z<1) return 0.5*Math.pow(1-z,2);",
    "return 0.0;",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "TODO Auto-generated method stub",
    "start row index for words",
    "doc ids",
    "topic assignments",
    "count word",
    "build word start index",
    "build dks",
    "model.wtMat().increment(w, update);",
    "update.plusBy(t, 1);",
    "model.wtMat().increment(w, update);",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "calculate columns",
    "loss function",
    "gradient and hessian",
    "categorical feature set, null: none, empty: all, else: partial",
    "tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "3. set phase to GET_SKETCH",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "7. set phase to run active",
    "1. start threads of active tree nodes",
    "1.1. start threads for active nodes to generate histogram",
    "1.2. set thread status to batch num",
    "1.3. set the oplog to active",
    "2. check thread stats, if all threads finish, return",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "histogram = (TDoubleVector) ((GetRowResult) histMat.get(func)).getRow();",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "than the split value",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current tree",
    "finish current depth",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = startFid * 7; // each split contains 7 doubles",
    "System.out.println(\"Indices: \" + Arrays.toString(indices));",
    "t[i][code]++;",
    "else if (Math.random() > 0.5) {",
    "t[i][code] = freq;",
    "}",
    "System.out.println(\"Change from \" + t[i][code] + \" to \" + freq);",
    "ret = Math.min(ret, t[i][h[i].encode(key)]);",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "v1.4.0": [
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "in different part",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "find the max abs",
    "compress data",
    "TODO: a better way is needed to deal with defaultValue",
    "TODO: a better way is needed to deal with defaultValue",
    "TODO: a better way is needed to deal with defaultValue",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "Set PS Model values",
    "Wait for all tasks finish this clock",
    "Get values of index array",
    "Set PS Model values",
    "Wait for all tasks finish this clock",
    "Get values of index array",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and data format",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Default location for user home directories #",
    "Default value for FS_HOME_DIR_KEY #",
    "Default umask for files created in HDFS #",
    "Default value for FS_PERMISSIONS_UMASK_KEY #",
    "How often does RPC client send pings to RPC server #",
    "Default value for IPC_PING_INTERVAL_KEY #",
    "Enables pings from RPC client to the server #",
    "Default value of IPC_CLIENT_PING_KEY #",
    "Responses larger than this will be logged #",
    "Default value for IPC_SERVER_RPC_MAX_RESPONSE_SIZE_KEY #",
    "Number of threads in RPC server reading from the socket #",
    "Default value for IPC_SERVER_RPC_READ_THREADS_KEY #",
    "How many calls per handler are allowed in the queue. #",
    "Default value for IPC_SERVER_HANDLER_QUEUE_SIZE_KEY #",
    "Internal buffer size for Lzo compressordecompressors #/",
    "Default value for IO_COMPRESSION_CODEC_LZO_BUFFERSIZE_KEY #",
    "This is for specifying the implementation for the mappings from",
    "hostnames to the racks they belong to",
    "Internal buffer size for Snappy compressordecompressors #/",
    "Default value for IO_COMPRESSION_CODEC_SNAPPY_BUFFERSIZE_KEY #",
    "Internal buffer size for Snappy compressordecompressors #/",
    "Default value for IO_COMPRESSION_CODEC_SNAPPY_BUFFERSIZE_KEY #",
    "Service Authorization",
    "HA health monitor and failover controller.",
    "How often to retry connecting to the service.",
    "How often to check the service.",
    "How long to sleep after an unexpected RPC error.",
    "Timeout for the actual monitorHealth() calls. *",
    "Timeout that the FC waits for the new active to become active",
    "Timeout that the FC waits for the old active to go to standby",
    "FC connection retries for graceful fencing",
    "Timeout that the CLI (manual) FC waits for monitorHealth, getServiceState",
    "Static user web-filter properties.",
    "See StaticUserWebFilter.",
    "EnableDisable aliases serving from jetty",
    "Path to the Kerberos ticket cache.  Setting this will force",
    "UserGroupInformation to use only this ticket cache file when creating a",
    "FileSystem instance.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Input Path, please modify ${YOUR_ANGEL_HOME} as your local angel installation path,",
    "e.g. if your path is /home/angel/angel_1.3.0, your input_path should be:",
    "\"file:///home/angel/angel_1.3.0/data/exampledata/GBDTLocalExampleData/agaricus.txt.train\",",
    "and your out_path could be: \"file:///home/angel/angel_1.3.0/data/output\"",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set GBDT category feature",
    "set input, output path",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample ratio",
    "Data format,libsvm or dummy",
    "Train batch number per epoch",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set job queue, if you use YARN deploy mode, you can set job queue by",
    "self.conf.set('mapreduce.job.queue.name', 'default')",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #tast, #ps",
    "set sgd LR algorithim parameters # feature # epoch",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Set log path",
    "Set actionType train",
    "Load Model from HDFS.",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic self.configuration key",
    "Set angel resource parameters #worker, #task, #PS",
    "Set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic self.configuration keys",
    "Set angel resource parameters #worker, #task, #PS",
    "Set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "If the enviroment has ANGEL_HOME set trust it.",
    "Add the path of the PyAngel module if it exists",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "Normalize the paths",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Get Java HashMap instance which converted from a python dict",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Run ParameterServer  & ParameterServerAgent",
    "Only Run ParameterServer",
    "Run ParameterServer & Worker(embedded ParameterServerAgent)",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To Do",
    "Modify the way to get current Angel version",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Launch the Py4j gateway",
    "Start a socket that will be used by PythonGatewayServer to communicate its port to python sub-proc",
    "Don't send ctrl-c / SIGINT to the Java gateway:",
    "We use select() here in order to avoid blocking indefinitely if the subprocess dies",
    "before connecting",
    "Determine which ephemeral port the server started on:",
    "Connect to the gateway",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To do: need python edition of TVector",
    "To do: need python edition of GetFunc",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Create an angel job client",
    "Submit this application",
    "Create a KMeans model",
    "Load model meta to client",
    "Start",
    "Run user task and wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Save the trained model to HDFS",
    "Stop",
    "Create an angel job client",
    "Submit this application",
    "Create KMeans model",
    "Add the model meta to client",
    "Start",
    "Run user task and wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Stop",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Training job to obtain a model",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Create an angel job client",
    "Submit this application",
    "Create a model",
    "Load model meta to client",
    "Run user task",
    "Wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Save the incremental trained model to HDFS",
    "Stop",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "If the enviroment has ANGEL_HOME set trust it.",
    "Add the path of the PyAngel module if it exists",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "If we are installed in edit mode also look two dirs up",
    "Not pip installed no worries",
    "Normalize the paths",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Get Java HashMap instance which converted from a python dict",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Run ParameterServer  & ParameterServerAgent",
    "Only Run ParameterServer",
    "Run ParameterServer & Worker(embedded ParameterServerAgent)",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To Do",
    "Modify the way to get current Angel version",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Launch the Py4j gateway",
    "Start a socket that will be used by PythonGatewayServer to communicate its port to python sub-proc",
    "Don't send ctrl-c / SIGINT to the Java gateway:",
    "We use select() here in order to avoid blocking indefinitely if the subprocess dies",
    "before connecting",
    "Determine which ephemeral port the server started on:",
    "Connect to the gateway",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited] = a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing] = software distributed under the License is",
    "distributed on an \"AS IS\" BASIS] = WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "To do: need python edition of TVector",
    "To do: need python edition of GetFunc",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Training job to obtain a model",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\") you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https:#opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Create an angel job client",
    "Submit this application",
    "Create a model",
    "Load model meta to client",
    "Run user task",
    "Wait for completion,",
    "User task is set in AngelConf.ANGEL_TASK_USER_TASKCLASS",
    "Save the incremental trained model to HDFS",
    "Stop",
    "",
    "Tencent is pleased to support the open source community by making Angel available.",
    "",
    "Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.",
    "",
    "Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in",
    "compliance with the License. You may obtain a copy of the License at",
    "",
    "https://opensource.org/licenses/BSD-3-Clause",
    "",
    "Unless required by applicable law or agreed to in writing, software distributed under the License is",
    "distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,",
    "either express or implied. See the License for the specific language governing permissions and",
    "",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setBoolean(AngelConf.ANGEL_PS_HA_USE_EVENT_PUSH, true);",
    "conf.setBoolean(AngelConf.ANGEL_PS_HA_PUSH_SYNC, true);",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setBoolean(AngelConf.ANGEL_PS_HA_USE_EVENT_PUSH, true);",
    "conf.setBoolean(AngelConf.ANGEL_PS_HA_PUSH_SYNC, true);",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "DenseIntVector deltaVec = new DenseIntVector(100000, delta);",
    "deltaVec.setMatrixId(matrixW1Id);",
    "deltaVec.setRowId(0);",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test ps agent id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "group0Id = new WorkerGroupId(0);",
    "worker0Id = new WorkerId(group0Id, 0);",
    "worker0Attempt0Id = new WorkerAttemptId(worker0Id, 0);",
    "task0Id = new TaskId(0);",
    "task1Id = new TaskId(1);",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "test this func in testWriteTo",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "LOG.info(index[0] + \" \" + value[0]);",
    "LOG.info(index[1] + \" \" + value[1]);",
    "LOG.info(index[2] + \" \" + value[2]);",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plusBy",
    "@Test",
    "public void dotDenseFloatVector() throws Exception {",
    "int dim = 1000;",
    "Random random = new Random(System.currentTimeMillis());",
    "",
    "double[] values = new double[dim];",
    "float[] values_1 = new float[dim];",
    "for (int i = 0; i < dim; i++) {",
    "values[i] = random.nextDouble();",
    "values_1[i] = random.nextFloat();",
    "}",
    "",
    "DenseDoubleVector vec = new DenseDoubleVector(dim, values);",
    "TDoubleVector vec_1 = new DenseFloatVector(dim, values_1);",
    "",
    "double sum = 0.0;",
    "for (int i = 0; i < dim; i++) {",
    "sum += values[i] * values_1[i];",
    "}",
    "",
    "assertEquals(sum, vec.dot(vec_1));",
    "",
    "}",
    "@Test",
    "public void plusDenseFlaotVector() throws Exception {",
    "double[] value_1 = new double[]{0.1, 0.2, 0.3, 0.4, 0.5};",
    "double[] value_2 = new double[]{0.1f, 0.2f, 0.3f, 0.4f, 0.5f};",
    "DenseDoubleVector vec = new DenseDoubleVector(5, value_1);",
    "TDoubleVector vec_1 = new DenseFloatVector(5, value_2);",
    "",
    "TDoubleVector vec_2 = vec.plus(vec_1);",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(value_1[i] + value_2[i], vec_2.get(i));",
    "",
    "",
    "TDoubleVector vec_3 = vec.plus(vec_1, 2.0);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec_3.get(i), value_1[i] + 2 * value_2[i]);",
    "",
    "double[] oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + vec_1.get(i));",
    "",
    "oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1, 3);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + 3 * vec_1.get(i));",
    "}",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "@Test",
    "public void plusBy3() throws Exception {",
    "float[][] value = {{1.0f, 2.0f}, {3.0f, 4.0f}};",
    "DenseFloatMatrix mat = new DenseFloatMatrix(2, 2,value);",
    "TFloatVector vec = new DenseFloatVector(2, new float[]{1.0f, 1.0f});",
    "vec.setRowId(0);",
    "TDoubleVector vec_1 = new DenseDoubleVector(2, new double[]{1.0f, 1.0f});",
    "vec_1.setRowId(1);",
    "TDoubleVector vec_2 = new SparseDoubleVector(2);",
    "vec_2.set(1, 1.0);",
    "vec_2.setRowId(0);",
    "",
    "mat.plusBy(vec);",
    "mat.plusBy(vec_1);",
    "mat.plusBy(vec_2);",
    "",
    "assertEquals(2.0f, mat.get(0, 0));",
    "assertEquals(4.0f, mat.get(0, 1));",
    "assertEquals(4.0f, mat.get(1, 0));",
    "assertEquals(5.0f, mat.get(1, 1));",
    "}",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add dense double matrix",
    "add sparse double matrix",
    "add component sparse double matrix",
    "add sparse long-key double matrix",
    "add component long-key sparse double matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "add dense float matrix",
    "add sparse float matrix",
    "add component sparse float matrix",
    "Start PS",
    "Start to run application",
    "Assert.assertTrue(index.length == row.size());",
    "Assert.assertTrue(index.length == row.size());",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "test worker getActiveTaskNum",
    "test worker getTaskNum",
    "test worker getTaskManager",
    "test workerId",
    "test workerAttemptId",
    "tet worker initFinished",
    "test worker getInitMinclock",
    "test worker loacation",
    "test AppId",
    "test Conf",
    "test UserName",
    "master location",
    "masterClient",
    "test psAgent",
    "test worker get dataBlockManager",
    "workerGroup.getSplits();",
    "application",
    "lcation",
    "workerGroup info",
    "worker info",
    "task",
    "Matrix parameters",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "Create an Angel client",
    "Add different types of matrix",
    "using mock object",
    "verification",
    "Stubbing",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "init parameter server manager",
    "recover task information if needed",
    "init psagent manager and register psagent manager event",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "check if parameter server can commit now.",
    "Update PS failed counters",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "check whether psagent heartbeat timeout",
    "check whether parameter server heartbeat timeout",
    "check whether worker heartbeat timeout",
    "choose a unused port",
    "start RPC server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "Transitions from the NEW state.",
    "PA_FAILMSG",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG",
    "event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event",
    "dispatched before PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will",
    "retry another attempt or failed",
    "release container",
    "TODO",
    "set the launch time",
    "set tarckerName,httpPort, which used by webserver",
    "added to psManager so psManager can monitor it;",
    "psAttempt.getContext().getParameterServerManager.registerPSAttempt(psAttempt.attemptId);",
    "set the finish time only if launch time is set",
    "ParameterServerJVM.setVMEnv(myEnv, conf);",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "This is so that, if the child forks another \"bin/hadoop\" (common in",
    "streaming) it will have the correct loglevel.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Transitions from the NEW state.",
    "Transitions from the RUNNING state.",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "init and start master committer",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "Refresh ps location & matrix meta",
    "start a new attempt for this ps",
    "notify ps manager",
    "getContext().getLocationManager().setPsLocation(id, null);",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and COMMITTING, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "sb.append(\"killed and failed workergroup is over tolerate \").append(tolerateFailedGroup);",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "Get ps locations from master and put them to the location cache.",
    "Build and initialize rpc client to master",
    "Build local location",
    "Initialize matrix meta information",
    "Start heartbeat thread if need",
    "Start all services",
    "Register to master first",
    "Report state to master every specified time",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "Filter it, removing zero values",
    "Doing average or not",
    "Split this row according the matrix partitions",
    "Add the splits to the result container",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "int seqId = ((ByteBuf) msg).readInt();",
    "LOG.info(\"receive result of seqId=\" + seqId);",
    "((ByteBuf) msg).resetReaderIndex();",
    "TODO: use Epoll for linux future",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "Then submit normal task until reach upper limit of flow control or all tasks are submit",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "check the location of server is ready, if not, we should wait",
    "allocate the bytebuf",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "find the partition request context from cache",
    "Check if the result of the sub-request is received",
    "Update received result number",
    "Get row splits received",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO Auto-generated method stub",
    "Check futures, if the result of a sub-request is received, put it to the result queue",
    "Now we just support pipelined row splits merging for dense type row",
    "Wait until the clock value of this row is greater than or equal to the value",
    "Get partitions for this row",
    "First get this row from matrix storage",
    "If the row exists in the matrix storage and the clock value meets the requirements, just",
    "return",
    "Get row splits of this row from the matrix cache first",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Filter the rowIds which are fetching now",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "if(syncNum % 1024 == 0) {",
    "}",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "private static UnpooledByteBufAllocator allocator = new UnpooledByteBufAllocator(false);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "JobStateProto jobState = report.getJobState();",
    "Used for java code to get a AngelClient instance",
    "Used for python code to get a AngelClient instance",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this location, only master ps can accept the update",
    "Check the partition state again",
    "Start to put the update to the slave pss",
    "Get partition and check the partition state",
    "Get the stored pss for this partition",
    "Check this ps is the master ps for this partition, if not, just return failed",
    "Start to put the update to the slave pss",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "context.getMatrixStorageManager().update(partKey, in);",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "Add tokens to new user so that it may execute its task correctly.",
    "to exit",
    "context.getSnapshotManager().processRecovery();",
    "private final ParameterServer psServer;",
    "data.rewind();",
    "data.rewind();",
    "data.rewind();",
    "output.writeInt(clock);",
    "clock = input.readInt();",
    "private final List<PartitionKey> partitionKeys;",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "Mapping from taskId to clock value.",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "nnz = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "nnz++;",
    "}",
    "sparseRep = null;",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "}",
    "sparseRep = null;",
    "output.writeInt(data.length);",
    "@Override",
    "public void serialize(ByteBuf buf) {",
    "if (sparseRep != null)",
    "return serializeSparse();",
    "else if (denseRep != null)",
    "return serializeDense();",
    "return serializeEmpty();",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int idx = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "keysBuf.put(idx, keys[i]);",
    "valuesBuf.put(idx, values[i]);",
    "idx++;",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int ov, k, v;",
    "for (int i = 0; i < keys.length; i++) {",
    "if (used[i]) {",
    "k = keys[i];",
    "ov = denseRep.get(k);",
    "v = ov + values[i];",
    "denseRep.put(k, v);",
    "if (ov != 0 && v == 0)",
    "nnz--;",
    "}",
    "}",
    "TODO: use Epoll for linux future",
    "find the partition request context from cache",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "Generate seq id",
    "Create a RecoverPartRequest",
    "Serialize the request",
    "Change the seqId for the request",
    "Serialize the request",
    "add the PSAgentContext,need fix",
    "return this;",
    "return this;",
    "return this;",
    "TODO Should be implemented",
    "TODO Should be implemented",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "Sort the parts by partitionId",
    "Sort partition keys use start column index",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "TODO:",
    "protected ParameterServerId psId;",
    "protected Location location;",
    "if(comeFromPs) {",
    "buf.writeInt(psId.getIndex());",
    "byte[] data = location.getIp().getBytes();",
    "buf.writeInt(data.length);",
    "buf.writeBytes(data);",
    "buf.writeInt(location.getPort());",
    "}",
    "if(comeFromPs) {",
    "psId = new ParameterServerId(buf.readInt());",
    "int size = buf.readInt();",
    "byte[] data = new byte[size];",
    "buf.readBytes(data);",
    "location = new Location(new String(data), buf.readInt());",
    "}",
    "write the max abs",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "Mark whether use pyangel or not.",
    "private Configuration conf;",
    "Configuration that should be used in python environment, there should only be one",
    "configuration instance in each Angel context.",
    "Use private access means jconf should not be changed or modified in this way.",
    "Exit on EOF or broken pipe to ensure that this process dies when the Python driver dies:",
    "Do nothing",
    "To-DO: add other ways to justify different value types",
    "This is so ugly, must re-implement by more elegance way",
    "Create python path which include angel's jars, the python directory in ANGEL_HOME,",
    "and other files submitted by user.",
    "Launch python process",
    "TODO Auto-generated constructor stub",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Submit GBDT Train Task",
    "Load Model from HDFS.",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, save model, log path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set MLR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation Ratio",
    "Data format",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set basic configuration keys",
    "Set data format",
    "Use local deploy mode",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd SVM algorithm parameters",
    "set input, output path",
    "Set save model path",
    "Set actionType train",
    "Set log path",
    "Submit LR Train Task",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log sava path",
    "Set actionType prediction",
    "double z=pre*y;",
    "if(z<=0) return 0.5-z;",
    "else if(z>0 && z<1) return 0.5*Math.pow(1-z,2);",
    "return 0.0;",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "TODO Auto-generated method stub",
    "start row index for words",
    "doc ids",
    "topic assignments",
    "count word",
    "build word start index",
    "build dks",
    "model.wtMat().increment(w, update);",
    "update.plusBy(t, 1);",
    "model.wtMat().increment(w, update);",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "loss function",
    "gradient and hessian",
    "tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "categorical features",
    "2. push local sketch to PS",
    "3. set phase to GET_SKETCH",
    "the leader worker",
    "merge categorical features",
    "create updates",
    "pull the global sketch from PS, only called once by each worker",
    "number of categorical feature",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "7. set phase to run active",
    "1. start threads of active tree nodes",
    "1.1. start threads for active nodes to generate histogram",
    "1.2. set thread status to batch num",
    "1.3. set the oplog to active",
    "2. check thread stats, if all threads finish, return",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "histogram = (TDoubleVector) ((GetRowResult) histMat.get(func)).getRow();",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "than the split value",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current tree",
    "finish current depth",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "left child <= split value; right child > split value",
    "the first: minimal, the last: maximal",
    "categorical features",
    "continuous features",
    "left child <= split value; right child > split value",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[0], the first item is the minimal feature value",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "public int[] rootIndex; // specified root index of each instances, can be used for multi task setting",
    "public int[] groupPtr; // the index of begin and end of a group, needed when the learning task is ranking.",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = startFid * 7; // each split contains 7 doubles",
    "System.out.println(\"Indices: \" + Arrays.toString(indices));",
    "t[i][code]++;",
    "else if (Math.random() > 0.5) {",
    "t[i][code] = freq;",
    "}",
    "System.out.println(\"Change from \" + t[i][code] + \" to \" + freq);",
    "ret = Math.min(ret, t[i][h[i].encode(key)]);",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "task type: classification, regression, or ranking",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "categorical feature. size = workerNum * cateFeatNum * splitNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "v1.3.0": [
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "in different part",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "find the max abs",
    "compress data",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "DenseIntVector deltaVec = new DenseIntVector(100000, delta);",
    "deltaVec.setMatrixId(matrixW1Id);",
    "deltaVec.setRowId(0);",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test ps agent id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "Note:[startRow,endRow)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "group0Id = new WorkerGroupId(0);",
    "worker0Id = new WorkerId(group0Id, 0);",
    "worker0Attempt0Id = new WorkerAttemptId(worker0Id, 0);",
    "task0Id = new TaskId(0);",
    "task1Id = new TaskId(1);",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "test this func in testWriteTo",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "LOG.info(index[0] + \" \" + value[0]);",
    "LOG.info(index[1] + \" \" + value[1]);",
    "LOG.info(index[2] + \" \" + value[2]);",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plusBy",
    "@Test",
    "public void dotDenseFloatVector() throws Exception {",
    "int dim = 1000;",
    "Random random = new Random(System.currentTimeMillis());",
    "",
    "double[] values = new double[dim];",
    "float[] values_1 = new float[dim];",
    "for (int i = 0; i < dim; i++) {",
    "values[i] = random.nextDouble();",
    "values_1[i] = random.nextFloat();",
    "}",
    "",
    "DenseDoubleVector vec = new DenseDoubleVector(dim, values);",
    "TDoubleVector vec_1 = new DenseFloatVector(dim, values_1);",
    "",
    "double sum = 0.0;",
    "for (int i = 0; i < dim; i++) {",
    "sum += values[i] * values_1[i];",
    "}",
    "",
    "assertEquals(sum, vec.dot(vec_1));",
    "",
    "}",
    "@Test",
    "public void plusDenseFlaotVector() throws Exception {",
    "double[] value_1 = new double[]{0.1, 0.2, 0.3, 0.4, 0.5};",
    "double[] value_2 = new double[]{0.1f, 0.2f, 0.3f, 0.4f, 0.5f};",
    "DenseDoubleVector vec = new DenseDoubleVector(5, value_1);",
    "TDoubleVector vec_1 = new DenseFloatVector(5, value_2);",
    "",
    "TDoubleVector vec_2 = vec.plus(vec_1);",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(value_1[i] + value_2[i], vec_2.get(i));",
    "",
    "",
    "TDoubleVector vec_3 = vec.plus(vec_1, 2.0);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec_3.get(i), value_1[i] + 2 * value_2[i]);",
    "",
    "double[] oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + vec_1.get(i));",
    "",
    "oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1, 3);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + 3 * vec_1.get(i));",
    "}",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "@Test",
    "public void plusBy3() throws Exception {",
    "float[][] value = {{1.0f, 2.0f}, {3.0f, 4.0f}};",
    "DenseFloatMatrix mat = new DenseFloatMatrix(2, 2,value);",
    "TFloatVector vec = new DenseFloatVector(2, new float[]{1.0f, 1.0f});",
    "vec.setRowId(0);",
    "TDoubleVector vec_1 = new DenseDoubleVector(2, new double[]{1.0f, 1.0f});",
    "vec_1.setRowId(1);",
    "TDoubleVector vec_2 = new SparseDoubleVector(2);",
    "vec_2.set(1, 1.0);",
    "vec_2.setRowId(0);",
    "",
    "mat.plusBy(vec);",
    "mat.plusBy(vec_1);",
    "mat.plusBy(vec_2);",
    "",
    "assertEquals(2.0f, mat.get(0, 0));",
    "assertEquals(4.0f, mat.get(0, 1));",
    "assertEquals(4.0f, mat.get(1, 0));",
    "assertEquals(5.0f, mat.get(1, 1));",
    "}",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "test worker getActiveTaskNum",
    "test worker getTaskNum",
    "test worker getTaskManager",
    "test workerId",
    "test workerAttemptId",
    "tet worker initFinished",
    "test worker getInitMinclock",
    "test worker loacation",
    "test AppId",
    "test Conf",
    "test UserName",
    "master location",
    "masterClient",
    "test psAgent",
    "test worker get dataBlockManager",
    "workerGroup.getSplits();",
    "application",
    "lcation",
    "workerGroup info",
    "worker info",
    "task",
    "Matrix parameters",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "Create an Angel client",
    "Add different types of matrix",
    "using mock object",
    "verification",
    "Stubbing",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "init parameter server manager",
    "recover task information if needed",
    "init psagent manager and register psagent manager event",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "check if parameter server can commit now.",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "check whether psagent heartbeat timeout",
    "check whether parameter server heartbeat timeout",
    "check whether worker heartbeat timeout",
    "choose a unused port",
    "start RPC server",
    "find matrix partitions from master matrix meta manager for this parameter server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "private boolean matrixInited;",
    "check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "dispatch matrix partitions to parameter servers",
    "update matrix id generator",
    "check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "dispatch matrix partitions to parameter servers",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "waitForMatrixReleaseOnPS(matrixId);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "Transitions from the NEW state.",
    "PA_FAILMSG",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG",
    "event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event",
    "dispatched before PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will",
    "retry another attempt or failed",
    "release container",
    "TODO",
    "set the launch time",
    "set tarckerName,httpPort, which used by webserver",
    "added to psManager so psManager can monitor it;",
    "psAttempt.getContext().getParameterServerManager.registerPSAttempt(psAttempt.attemptId);",
    "set the finish time only if launch time is set",
    "ParameterServerJVM.setVMEnv(myEnv, conf);",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "This is so that, if the child forks another \"bin/hadoop\" (common in",
    "streaming) it will have the correct loglevel.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Transitions from the NEW state.",
    "Transitions from the RUNNING state.",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "init and start master committer",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and COMMITTING, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Build and initialize rpc client to master",
    "Build local location",
    "Initialize matrix info, this method will wait until master accepts the information from",
    "client",
    "Get ps locations from master and put them to the location cache.",
    "Initialize matrix meta information",
    "Start heartbeat thread if need",
    "Start all services",
    "Register to master first",
    "Report state to master every specified time",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "array stores clock for each row and clock",
    "local task num",
    "mapping from task index to taskId",
    "mapping from taskId to task index",
    "TODO Auto-generated method stub",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "Get partitions for the matrix",
    "Filter it, removing zero values",
    "Doing average or not",
    "Split this row according the matrix partitions",
    "Add the splits to the result container",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "int seqId = ((ByteBuf) msg).readInt();",
    "LOG.info(\"receive result of seqId=\" + seqId);",
    "((ByteBuf) msg).resetReaderIndex();",
    "TODO: use Epoll for linux future",
    "closeChannelForServer(request.getServerId());",
    "closeChannelForServer(request.getServerId());",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "Then submit normal task until reach upper limit of flow control or all tasks are submit",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "allocate the bytebuf",
    "check the location of server is ready, if not, we should wait",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "find the partition request context from cache",
    "Check if the result of the sub-request is received",
    "Update received result number",
    "Get row splits received",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO Auto-generated method stub",
    "Check futures, if the result of a sub-request is received, put it to the result queue",
    "Now we just support pipelined row splits merging for dense type row",
    "Wait until the clock value of this row is greater than or equal to the value",
    "Get partitions for this row",
    "First get this row from matrix storage",
    "If the row exists in the matrix storage and the clock value meets the requirements, just",
    "return",
    "Get row splits of this row from the matrix cache first",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "use update index if exist",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "if (matrixManager.getMatrixMeta(createResponse.getMatrixId()) != null) {",
    "return matrixManager.getMatrixMeta(createResponse.getMatrixId());",
    "}",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "private static UnpooledByteBufAllocator allocator = new UnpooledByteBufAllocator(false);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "JobStateProto jobState = report.getJobState();",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "Add tokens to new user so that it may execute its task correctly.",
    "to exit",
    "private final ParameterServer psServer;",
    "TODO",
    "when we should write snapshot to hdfs? clearly, we have two methods:",
    "1. write snapshot at regular time, if there are updates, just write them.",
    "2. write snapshot every N iterations, this method depends on notification of master",
    "FSDataOutputStream output = fileContext.create(snapshotsTempFilePath,",
    "EnumSet.of(CreateFlag.CREATE));",
    "@brief get filename of the old snapshot written before",
    "no snapshotFile write before, maybe write snapshots the first time",
    "data.rewind();",
    "data.rewind();",
    "data.rewind();",
    "output.writeInt(clock);",
    "clock = input.readInt();",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "Mapping from taskId to clock value.",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "nnz = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "nnz++;",
    "}",
    "sparseRep = null;",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "}",
    "sparseRep = null;",
    "output.writeInt(data.length);",
    "@Override",
    "public void serialize(ByteBuf buf) {",
    "if (sparseRep != null)",
    "return serializeSparse();",
    "else if (denseRep != null)",
    "return serializeDense();",
    "return serializeEmpty();",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int idx = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "keysBuf.put(idx, keys[i]);",
    "valuesBuf.put(idx, values[i]);",
    "idx++;",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int ov, k, v;",
    "for (int i = 0; i < keys.length; i++) {",
    "if (used[i]) {",
    "k = keys[i];",
    "ov = denseRep.get(k);",
    "v = ov + values[i];",
    "denseRep.put(k, v);",
    "if (ov != 0 && v == 0)",
    "nnz--;",
    "}",
    "}",
    "add the PSAgentContext,need fix",
    "set MatrixPartitionLocation",
    "set attribute",
    "return this;",
    "return this;",
    "return this;",
    "TODO:",
    "write the max abs",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "private Configuration conf;",
    "TODO Auto-generated constructor stub",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Submit GBDT Train Task",
    "Load Model from HDFS.",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, save model, log path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set MLR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation Ratio",
    "Data format",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set basic configuration keys",
    "Set data format",
    "Use local deploy mode",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd SVM algorithm parameters",
    "set input, output path",
    "Set save model path",
    "Set actionType train",
    "Set log path",
    "Submit LR Train Task",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log sava path",
    "Set actionType prediction",
    "double z=pre*y;",
    "if(z<=0) return 0.5-z;",
    "else if(z>0 && z<1) return 0.5*Math.pow(1-z,2);",
    "return 0.0;",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "TODO Auto-generated method stub",
    "start row index for words",
    "doc ids",
    "topic assignments",
    "count word",
    "build word start index",
    "build dks",
    "model.wtMat().increment(w, update);",
    "update.plusBy(t, 1);",
    "model.wtMat().increment(w, update);",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "loss function",
    "gradient and hessian",
    "tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "2. push local sketch to PS",
    "3. set phase to GET_SKETCH",
    "pull the global sketch from PS, only called once by each worker",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "7. set phase to run active",
    "1. start threads of active tree nodes",
    "1.1. start threads for active nodes to generate histogram",
    "1.2. set thread status to batch num",
    "1.3. set the oplog to active",
    "2. check thread stats, if all threads finish, return",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "histogram = (TDoubleVector) ((GetRowResult) histMat.get(func)).getRow();",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "than the split value",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current tree",
    "finish current depth",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "int nodeStart = this.controller.nodePosStart[nid];",
    "int nodeEnd = this.controller.nodePosEnd[nid];",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "int startIdx = fid * 2 * splitNum;",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx+1]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "// update the grad stats of the root node on PS, only called once by leader worker",
    "if (this.nid == 0) {",
    "GradStats rootStats = new GradStats(splitEntry.leftGradStat);",
    "rootStats.add(splitEntry.rightGradStat);",
    "this.controller.updateNodeGradStats(this.nid, rootStats);",
    "}",
    "",
    "// 3. update the grad stats of children node",
    "if (splitEntry.fid != -1) {",
    "// 3.1. update the left child",
    "this.controller.updateNodeGradStats(2 * this.nid + 1, splitEntry.leftGradStat);",
    "// 3.2. update the right child",
    "this.controller.updateNodeGradStats(2 * this.nid + 2, splitEntry.rightGradStat);",
    "}",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[1], since the first item is the minimal",
    "feature value",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = startFid * 7; // each split contains 7 doubles",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "tips: here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "System.out.println(\"Indices: \" + Arrays.toString(indices));",
    "t[i][code]++;",
    "else if (Math.random() > 0.5) {",
    "t[i][code] = freq;",
    "}",
    "System.out.println(\"Change from \" + t[i][code] + \" to \" + freq);",
    "ret = Math.min(ret, t[i][h[i].encode(key)]);",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "get feature type, 0:empty 1:all equal 2:real",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "v1.2.1": [
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "in different part",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "find the max abs",
    "compress data",
    "import jdk.nashorn.internal.runtime.regexp.joni.Config;",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Load model meta",
    "Convert model",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Convert model",
    "load hadoop configuration",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model meta",
    "Check row type",
    "Load model",
    "Load model",
    "load hadoop configuration",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "DenseIntVector deltaVec = new DenseIntVector(100000, delta);",
    "deltaVec.setMatrixId(matrixW1Id);",
    "deltaVec.setRowId(0);",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test ps agent id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "Note:[startRow,endRow)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "group0Id = new WorkerGroupId(0);",
    "worker0Id = new WorkerId(group0Id, 0);",
    "worker0Attempt0Id = new WorkerAttemptId(worker0Id, 0);",
    "task0Id = new TaskId(0);",
    "task1Id = new TaskId(1);",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "test this func in testWriteTo",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "LOG.info(index[0] + \" \" + value[0]);",
    "LOG.info(index[1] + \" \" + value[1]);",
    "LOG.info(index[2] + \" \" + value[2]);",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plusBy",
    "@Test",
    "public void dotDenseFloatVector() throws Exception {",
    "int dim = 1000;",
    "Random random = new Random(System.currentTimeMillis());",
    "",
    "double[] values = new double[dim];",
    "float[] values_1 = new float[dim];",
    "for (int i = 0; i < dim; i++) {",
    "values[i] = random.nextDouble();",
    "values_1[i] = random.nextFloat();",
    "}",
    "",
    "DenseDoubleVector vec = new DenseDoubleVector(dim, values);",
    "TDoubleVector vec_1 = new DenseFloatVector(dim, values_1);",
    "",
    "double sum = 0.0;",
    "for (int i = 0; i < dim; i++) {",
    "sum += values[i] * values_1[i];",
    "}",
    "",
    "assertEquals(sum, vec.dot(vec_1));",
    "",
    "}",
    "@Test",
    "public void plusDenseFlaotVector() throws Exception {",
    "double[] value_1 = new double[]{0.1, 0.2, 0.3, 0.4, 0.5};",
    "double[] value_2 = new double[]{0.1f, 0.2f, 0.3f, 0.4f, 0.5f};",
    "DenseDoubleVector vec = new DenseDoubleVector(5, value_1);",
    "TDoubleVector vec_1 = new DenseFloatVector(5, value_2);",
    "",
    "TDoubleVector vec_2 = vec.plus(vec_1);",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(value_1[i] + value_2[i], vec_2.get(i));",
    "",
    "",
    "TDoubleVector vec_3 = vec.plus(vec_1, 2.0);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec_3.get(i), value_1[i] + 2 * value_2[i]);",
    "",
    "double[] oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + vec_1.get(i));",
    "",
    "oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1, 3);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + 3 * vec_1.get(i));",
    "}",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "@Test",
    "public void plusBy3() throws Exception {",
    "float[][] value = {{1.0f, 2.0f}, {3.0f, 4.0f}};",
    "DenseFloatMatrix mat = new DenseFloatMatrix(2, 2,value);",
    "TFloatVector vec = new DenseFloatVector(2, new float[]{1.0f, 1.0f});",
    "vec.setRowId(0);",
    "TDoubleVector vec_1 = new DenseDoubleVector(2, new double[]{1.0f, 1.0f});",
    "vec_1.setRowId(1);",
    "TDoubleVector vec_2 = new SparseDoubleVector(2);",
    "vec_2.set(1, 1.0);",
    "vec_2.setRowId(0);",
    "",
    "mat.plusBy(vec);",
    "mat.plusBy(vec_1);",
    "mat.plusBy(vec_2);",
    "",
    "assertEquals(2.0f, mat.get(0, 0));",
    "assertEquals(4.0f, mat.get(0, 1));",
    "assertEquals(4.0f, mat.get(1, 0));",
    "assertEquals(5.0f, mat.get(1, 1));",
    "}",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "test worker getActiveTaskNum",
    "test worker getTaskNum",
    "test worker getTaskManager",
    "test workerId",
    "test workerAttemptId",
    "tet worker initFinished",
    "test worker getInitMinclock",
    "test worker loacation",
    "test AppId",
    "test Conf",
    "test UserName",
    "master location",
    "masterClient",
    "test psAgent",
    "test worker get dataBlockManager",
    "workerGroup.getSplits();",
    "application",
    "lcation",
    "workerGroup info",
    "worker info",
    "task",
    "Matrix parameters",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "Create an Angel client",
    "Add different types of matrix",
    "using mock object",
    "verification",
    "Stubbing",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "init parameter server manager",
    "recover task information if needed",
    "init psagent manager and register psagent manager event",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "check if parameter server can commit now.",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "check whether psagent heartbeat timeout",
    "check whether parameter server heartbeat timeout",
    "check whether worker heartbeat timeout",
    "choose a unused port",
    "start RPC server",
    "find matrix partitions from master matrix meta manager for this parameter server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "private boolean matrixInited;",
    "check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "dispatch matrix partitions to parameter servers",
    "update matrix id generator",
    "check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "dispatch matrix partitions to parameter servers",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "waitForMatrixReleaseOnPS(matrixId);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Init matrix files meta",
    "Move output files",
    "Write the meta file",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "Transitions from the NEW state.",
    "PA_FAILMSG",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG",
    "event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event",
    "dispatched before PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will",
    "retry another attempt or failed",
    "release container",
    "TODO",
    "set the launch time",
    "set tarckerName,httpPort, which used by webserver",
    "added to psManager so psManager can monitor it;",
    "psAttempt.getContext().getParameterServerManager.registerPSAttempt(psAttempt.attemptId);",
    "set the finish time only if launch time is set",
    "ParameterServerJVM.setVMEnv(myEnv, conf);",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "This is so that, if the child forks another \"bin/hadoop\" (common in",
    "streaming) it will have the correct loglevel.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Transitions from the NEW state.",
    "Transitions from the RUNNING state.",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "init and start master committer",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and COMMITTING, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Build and initialize rpc client to master",
    "Build local location",
    "Initialize matrix info, this method will wait until master accepts the information from",
    "client",
    "Get ps locations from master and put them to the location cache.",
    "Initialize matrix meta information",
    "Start heartbeat thread if need",
    "Start all services",
    "Register to master first",
    "Report state to master every specified time",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "array stores clock for each row and clock",
    "local task num",
    "mapping from task index to taskId",
    "mapping from taskId to task index",
    "TODO Auto-generated method stub",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "Get partitions for the matrix",
    "Filter it, removing zero values",
    "Doing average or not",
    "Split this row according the matrix partitions",
    "Add the splits to the result container",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "int seqId = ((ByteBuf) msg).readInt();",
    "LOG.info(\"receive result of seqId=\" + seqId);",
    "((ByteBuf) msg).resetReaderIndex();",
    "TODO: use Epoll for linux future",
    "closeChannelForServer(request.getServerId());",
    "closeChannelForServer(request.getServerId());",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "Then submit normal task until reach upper limit of flow control or all tasks are submit",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "allocate the bytebuf",
    "check the location of server is ready, if not, we should wait",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "find the partition request context from cache",
    "Check if the result of the sub-request is received",
    "Update received result number",
    "Get row splits received",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO Auto-generated method stub",
    "Check futures, if the result of a sub-request is received, put it to the result queue",
    "Now we just support pipelined row splits merging for dense type row",
    "Wait until the clock value of this row is greater than or equal to the value",
    "Get partitions for this row",
    "First get this row from matrix storage",
    "If the row exists in the matrix storage and the clock value meets the requirements, just",
    "return",
    "Get row splits of this row from the matrix cache first",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "use update index if exist",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "if (matrixManager.getMatrixMeta(createResponse.getMatrixId()) != null) {",
    "return matrixManager.getMatrixMeta(createResponse.getMatrixId());",
    "}",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "Parse cmd parameters",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load user job jar if it exist",
    "Expand the environment variable",
    "Add default fs(local fs) for lib jars.",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "private static UnpooledByteBufAllocator allocator = new UnpooledByteBufAllocator(false);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "instance submitter class",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "JobStateProto jobState = report.getJobState();",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "Add tokens to new user so that it may execute its task correctly.",
    "to exit",
    "private final ParameterServer psServer;",
    "TODO",
    "when we should write snapshot to hdfs? clearly, we have two methods:",
    "1. write snapshot at regular time, if there are updates, just write them.",
    "2. write snapshot every N iterations, this method depends on notification of master",
    "FSDataOutputStream output = fileContext.create(snapshotsTempFilePath,",
    "EnumSet.of(CreateFlag.CREATE));",
    "@brief get filename of the old snapshot written before",
    "no snapshotFile write before, maybe write snapshots the first time",
    "data.rewind();",
    "data.rewind();",
    "data.rewind();",
    "output.writeInt(clock);",
    "clock = input.readInt();",
    "Read matrix meta from meta file",
    "Load partitions from file use fork-join",
    "Save partitions to files use fork-join",
    "Write the ps matrix meta to the meta file",
    "Mapping from taskId to clock value.",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "nnz = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "nnz++;",
    "}",
    "sparseRep = null;",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "}",
    "sparseRep = null;",
    "output.writeInt(data.length);",
    "@Override",
    "public void serialize(ByteBuf buf) {",
    "if (sparseRep != null)",
    "return serializeSparse();",
    "else if (denseRep != null)",
    "return serializeDense();",
    "return serializeEmpty();",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int idx = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "keysBuf.put(idx, keys[i]);",
    "valuesBuf.put(idx, values[i]);",
    "idx++;",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int ov, k, v;",
    "for (int i = 0; i < keys.length; i++) {",
    "if (used[i]) {",
    "k = keys[i];",
    "ov = denseRep.get(k);",
    "v = ov + values[i];",
    "denseRep.put(k, v);",
    "if (ov != 0 && v == 0)",
    "nnz--;",
    "}",
    "}",
    "add the PSAgentContext,need fix",
    "set MatrixPartitionLocation",
    "set attribute",
    "return this;",
    "return this;",
    "return this;",
    "TODO:",
    "write the max abs",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "private Configuration conf;",
    "TODO Auto-generated constructor stub",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Submit GBDT Train Task",
    "Load Model from HDFS.",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, save model, log path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Model type",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set MLR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation Ratio",
    "Data format",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set basic configuration keys",
    "Set data format",
    "Use local deploy mode",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd SVM algorithm parameters",
    "set input, output path",
    "Set save model path",
    "Set actionType train",
    "Set log path",
    "Submit LR Train Task",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log sava path",
    "Set actionType prediction",
    "double z=pre*y;",
    "if(z<=0) return 0.5-z;",
    "else if(z>0 && z<1) return 0.5*Math.pow(1-z,2);",
    "return 0.0;",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "TODO Auto-generated method stub",
    "start row index for words",
    "doc ids",
    "topic assignments",
    "count word",
    "build word start index",
    "build dks",
    "model.wtMat().increment(w, update);",
    "update.plusBy(t, 1);",
    "model.wtMat().increment(w, update);",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "loss function",
    "gradient and hessian",
    "tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "2. push local sketch to PS",
    "3. set phase to GET_SKETCH",
    "pull the global sketch from PS, only called once by each worker",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "7. set phase to run active",
    "1. start threads of active tree nodes",
    "1.1. start threads for active nodes to generate histogram",
    "1.2. set thread status to batch num",
    "1.3. set the oplog to active",
    "2. check thread stats, if all threads finish, return",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "histogram = (TDoubleVector) ((GetRowResult) histMat.get(func)).getRow();",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "than the split value",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current tree",
    "finish current depth",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "int nodeStart = this.controller.nodePosStart[nid];",
    "int nodeEnd = this.controller.nodePosEnd[nid];",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "int startIdx = fid * 2 * splitNum;",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx+1]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "// update the grad stats of the root node on PS, only called once by leader worker",
    "if (this.nid == 0) {",
    "GradStats rootStats = new GradStats(splitEntry.leftGradStat);",
    "rootStats.add(splitEntry.rightGradStat);",
    "this.controller.updateNodeGradStats(this.nid, rootStats);",
    "}",
    "",
    "// 3. update the grad stats of children node",
    "if (splitEntry.fid != -1) {",
    "// 3.1. update the left child",
    "this.controller.updateNodeGradStats(2 * this.nid + 1, splitEntry.leftGradStat);",
    "// 3.2. update the right child",
    "this.controller.updateNodeGradStats(2 * this.nid + 2, splitEntry.rightGradStat);",
    "}",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[1], since the first item is the minimal",
    "feature value",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = startFid * 7; // each split contains 7 doubles",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "tips: here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "System.out.println(\"Indices: \" + Arrays.toString(indices));",
    "t[i][code]++;",
    "else if (Math.random() > 0.5) {",
    "t[i][code] = freq;",
    "}",
    "System.out.println(\"Change from \" + t[i][code] + \" to \" + freq);",
    "ret = Math.min(ret, t[i][h[i].encode(key)]);",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "Get input path, output path",
    "Init serde",
    "Parse need convert model names, if not set, we will convert all models in input directory",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "get feature type, 0:empty 1:all equal 2:real",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "v1.2.0": [
    "TODO: SplitNum",
    "TODO: implement split method",
    "SplitEntry splitEntry = GradHistHelper.findSplitOfServerRow(row);",
    "int sendStartCol = startFid * 7; // each split contains 7 doubles",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "in different part",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "find the max abs",
    "compress data",
    "paras[1] = \"abc\";",
    "paras[2] = \"123\";",
    "Add standard Hadoop classes",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "DenseIntVector deltaVec = new DenseIntVector(100000, delta);",
    "deltaVec.setMatrixId(matrixW1Id);",
    "deltaVec.setRowId(0);",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConf.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test ps agent id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "Note:[startRow,endRow)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "group0Id = new WorkerGroupId(0);",
    "worker0Id = new WorkerId(group0Id, 0);",
    "worker0Attempt0Id = new WorkerAttemptId(worker0Id, 0);",
    "task0Id = new TaskId(0);",
    "task1Id = new TaskId(1);",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "test this func in testWriteTo",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "LOG.info(index[0] + \" \" + value[0]);",
    "LOG.info(index[1] + \" \" + value[1]);",
    "LOG.info(index[2] + \" \" + value[2]);",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plusBy",
    "@Test",
    "public void dotDenseFloatVector() throws Exception {",
    "int dim = 1000;",
    "Random random = new Random(System.currentTimeMillis());",
    "",
    "double[] values = new double[dim];",
    "float[] values_1 = new float[dim];",
    "for (int i = 0; i < dim; i++) {",
    "values[i] = random.nextDouble();",
    "values_1[i] = random.nextFloat();",
    "}",
    "",
    "DenseDoubleVector vec = new DenseDoubleVector(dim, values);",
    "TDoubleVector vec_1 = new DenseFloatVector(dim, values_1);",
    "",
    "double sum = 0.0;",
    "for (int i = 0; i < dim; i++) {",
    "sum += values[i] * values_1[i];",
    "}",
    "",
    "assertEquals(sum, vec.dot(vec_1));",
    "",
    "}",
    "@Test",
    "public void plusDenseFlaotVector() throws Exception {",
    "double[] value_1 = new double[]{0.1, 0.2, 0.3, 0.4, 0.5};",
    "double[] value_2 = new double[]{0.1f, 0.2f, 0.3f, 0.4f, 0.5f};",
    "DenseDoubleVector vec = new DenseDoubleVector(5, value_1);",
    "TDoubleVector vec_1 = new DenseFloatVector(5, value_2);",
    "",
    "TDoubleVector vec_2 = vec.plus(vec_1);",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(value_1[i] + value_2[i], vec_2.get(i));",
    "",
    "",
    "TDoubleVector vec_3 = vec.plus(vec_1, 2.0);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec_3.get(i), value_1[i] + 2 * value_2[i]);",
    "",
    "double[] oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + vec_1.get(i));",
    "",
    "oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1, 3);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + 3 * vec_1.get(i));",
    "}",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "@Test",
    "public void plusBy3() throws Exception {",
    "float[][] value = {{1.0f, 2.0f}, {3.0f, 4.0f}};",
    "DenseFloatMatrix mat = new DenseFloatMatrix(2, 2,value);",
    "TFloatVector vec = new DenseFloatVector(2, new float[]{1.0f, 1.0f});",
    "vec.setRowId(0);",
    "TDoubleVector vec_1 = new DenseDoubleVector(2, new double[]{1.0f, 1.0f});",
    "vec_1.setRowId(1);",
    "TDoubleVector vec_2 = new SparseDoubleVector(2);",
    "vec_2.set(1, 1.0);",
    "vec_2.setRowId(0);",
    "",
    "mat.plusBy(vec);",
    "mat.plusBy(vec_1);",
    "mat.plusBy(vec_2);",
    "",
    "assertEquals(2.0f, mat.get(0, 0));",
    "assertEquals(4.0f, mat.get(0, 1));",
    "assertEquals(4.0f, mat.get(1, 0));",
    "assertEquals(5.0f, mat.get(1, 1));",
    "}",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "test worker getActiveTaskNum",
    "test worker getTaskNum",
    "test worker getTaskManager",
    "test workerId",
    "test workerAttemptId",
    "tet worker initFinished",
    "test worker getInitMinclock",
    "test worker loacation",
    "test AppId",
    "test Conf",
    "test UserName",
    "master location",
    "masterClient",
    "test psAgent",
    "test worker get dataBlockManager",
    "workerGroup.getSplits();",
    "application",
    "lcation",
    "workerGroup info",
    "worker info",
    "task",
    "Matrix parameters",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "Create an Angel client",
    "Add different types of matrix",
    "using mock object",
    "verification",
    "Stubbing",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "init parameter server manager",
    "recover task information if needed",
    "init psagent manager and register psagent manager event",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "check if parameter server can commit now.",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "check whether psagent heartbeat timeout",
    "check whether parameter server heartbeat timeout",
    "check whether worker heartbeat timeout",
    "choose a unused port",
    "start RPC server",
    "find matrix partitions from master matrix meta manager for this parameter server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "private boolean matrixInited;",
    "check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "dispatch matrix partitions to parameter servers",
    "update matrix id generator",
    "check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "dispatch matrix partitions to parameter servers",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "waitForMatrixReleaseOnPS(matrixId);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "Transitions from the NEW state.",
    "PA_FAILMSG",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG",
    "event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event",
    "dispatched before PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will",
    "retry another attempt or failed",
    "release container",
    "TODO",
    "set the launch time",
    "set tarckerName,httpPort, which used by webserver",
    "added to psManager so psManager can monitor it;",
    "psAttempt.getContext().getParameterServerManager.registerPSAttempt(psAttempt.attemptId);",
    "set the finish time only if launch time is set",
    "ParameterServerJVM.setVMEnv(myEnv, conf);",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "This is so that, if the child forks another \"bin/hadoop\" (common in",
    "streaming) it will have the correct loglevel.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Transitions from the NEW state.",
    "Transitions from the RUNNING state.",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "init and start master committer",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and COMMITTING, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Build and initialize rpc client to master",
    "Build local location",
    "Initialize matrix info, this method will wait until master accepts the information from",
    "client",
    "Get ps locations from master and put them to the location cache.",
    "Initialize matrix meta information",
    "Start heartbeat thread if need",
    "Start all services",
    "Register to master first",
    "Report state to master every specified time",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "array stores clock for each row and clock",
    "local task num",
    "mapping from task index to taskId",
    "mapping from taskId to task index",
    "TODO Auto-generated method stub",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "Get partitions for the matrix",
    "Filter it, removing zero values",
    "Doing average or not",
    "Split this row according the matrix partitions",
    "Add the splits to the result container",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "int seqId = ((ByteBuf) msg).readInt();",
    "LOG.info(\"receive result of seqId=\" + seqId);",
    "((ByteBuf) msg).resetReaderIndex();",
    "TODO: use Epoll for linux future",
    "closeChannelForServer(request.getServerId());",
    "closeChannelForServer(request.getServerId());",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "Then submit normal task until reach upper limit of flow control or all tasks are submit",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "allocate the bytebuf",
    "check the location of server is ready, if not, we should wait",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "find the partition request context from cache",
    "Check if the result of the sub-request is received",
    "Update received result number",
    "Get row splits received",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO Auto-generated method stub",
    "Check futures, if the result of a sub-request is received, put it to the result queue",
    "Now we just support pipelined row splits merging for dense type row",
    "Wait until the clock value of this row is greater than or equal to the value",
    "Get partitions for this row",
    "First get this row from matrix storage",
    "If the row exists in the matrix storage and the clock value meets the requirements, just",
    "return",
    "Get row splits of this row from the matrix cache first",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "use update index if exist",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "if (matrixManager.getMatrixMeta(createResponse.getMatrixId()) != null) {",
    "return matrixManager.getMatrixMeta(createResponse.getMatrixId());",
    "}",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "private static UnpooledByteBufAllocator allocator = new UnpooledByteBufAllocator(false);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "load hadoop configuration",
    "load angel system configuration",
    "load user configuration:",
    "load user config file",
    "load command line parameters",
    "load user job resource files",
    "load user job jar if it exist",
    "Expand the environment variable",
    "instance submitter class",
    "Add default fs(local fs) for lib jars.",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "JobStateProto jobState = report.getJobState();",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "Add tokens to new user so that it may execute its task correctly.",
    "to exit",
    "mkdir does not throw exception if path exits",
    "commitTaskPool.shutdown();",
    "LOG.info(\"rowId = \" + rowId + \" rowType = \" + rowType + \" size = \" + size + \" request \" +",
    "\"update\");",
    "private final ParameterServer psServer;",
    "TODO",
    "when we should write snapshot to hdfs? clearly, we have two methods:",
    "1. write snapshot at regular time, if there are updates, just write them.",
    "2. write snapshot every N iterations, this method depends on notification of master",
    "FSDataOutputStream output = fileContext.create(snapshotsTempFilePath,",
    "EnumSet.of(CreateFlag.CREATE));",
    "@brief get filename of the old snapshot written before",
    "no snapshotFile write before, maybe write snapshots the first time",
    "start end",
    "rowtype",
    "data.rewind();",
    "data.rewind();",
    "data.rewind();",
    "Pass the matrix and partition number field",
    "Mapping from taskId to clock value.",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "nnz = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "nnz++;",
    "}",
    "sparseRep = null;",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "}",
    "sparseRep = null;",
    "output.writeInt(data.length);",
    "@Override",
    "public void serialize(ByteBuf buf) {",
    "if (sparseRep != null)",
    "return serializeSparse();",
    "else if (denseRep != null)",
    "return serializeDense();",
    "return serializeEmpty();",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int idx = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "keysBuf.put(idx, keys[i]);",
    "valuesBuf.put(idx, values[i]);",
    "idx++;",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int ov, k, v;",
    "for (int i = 0; i < keys.length; i++) {",
    "if (used[i]) {",
    "k = keys[i];",
    "ov = denseRep.get(k);",
    "v = ov + values[i];",
    "denseRep.put(k, v);",
    "if (ov != 0 && v == 0)",
    "nnz--;",
    "}",
    "}",
    "add the PSAgentContext,need fix",
    "set MatrixPartitionLocation",
    "set attribute",
    "TODO:",
    "write the max abs",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "private Configuration conf;",
    "TODO Auto-generated constructor stub",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Submit GBDT Train Task",
    "Load Model from HDFS.",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, save model, log path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set MLR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set actionType train",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "parseSparseDouble();",
    "parseDenseFloat();",
    "parseDenseInt();",
    "parseSparseInt();",
    "Set model path",
    "Set model path",
    "Set model path",
    "Set model path",
    "Set model path",
    "Feature number of train data",
    "Total iteration number",
    "Rank",
    "Regularization parameters",
    "Learn rage",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set FM algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set learnType",
    "Set feature number",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set data format",
    "Set trainning data path",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Submit GBDT Train Task",
    "Load Model from HDFS.",
    "Feature number of train data",
    "Total iteration number",
    "Validation Ratio",
    "Data format",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set basic configuration keys",
    "Set data format",
    "Use local deploy mode",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd SVM algorithm parameters",
    "set input, output path",
    "Set save model path",
    "Set actionType train",
    "Set log path",
    "Submit LR Train Task",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log sava path",
    "Set actionType prediction",
    "double z=pre*y;",
    "if(z<=0) return 0.5-z;",
    "else if(z>0 && z<1) return 0.5*Math.pow(1-z,2);",
    "return 0.0;",
    "if (pre * y <= 0)",
    "return y;",
    "else if (pre * y > 0 && pre * y < 1)",
    "return (1 - pre * y) * y;",
    "return 0.0;",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "TODO Auto-generated method stub",
    "start row index for words",
    "doc ids",
    "topic assignments",
    "count word",
    "build word start index",
    "build dks",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "Write #rows",
    "Write each row",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "dense",
    "sparse",
    "LOG.info(buf.refCnt());",
    "loss function",
    "gradient and hessian",
    "tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "2. push local sketch to PS",
    "3. set phase to GET_SKETCH",
    "pull the global sketch from PS, only called once by each worker",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "7. set phase to run active",
    "1. start threads of active tree nodes",
    "1.1. start threads for active nodes to generate histogram",
    "1.2. set thread status to batch num",
    "1.3. set the oplog to active",
    "2. check thread stats, if all threads finish, return",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "histogram = (TDoubleVector) ((GetRowResult) histMat.get(func)).getRow();",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "update the grad stats of children node",
    "update the left child",
    "update the right child",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "2. check thread stats, if all threads finish, return",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "than the split value",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current tree",
    "finish current depth",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "4. reset thread stats to finished",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "get feature type, 0:empty 1:all equal 2:real",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "int nodeStart = this.controller.nodePosStart[nid];",
    "int nodeEnd = this.controller.nodePosEnd[nid];",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "int startIdx = fid * 2 * splitNum;",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx+1]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "// update the grad stats of the root node on PS, only called once by leader worker",
    "if (this.nid == 0) {",
    "GradStats rootStats = new GradStats(splitEntry.leftGradStat);",
    "rootStats.add(splitEntry.rightGradStat);",
    "this.controller.updateNodeGradStats(this.nid, rootStats);",
    "}",
    "",
    "// 3. update the grad stats of children node",
    "if (splitEntry.fid != -1) {",
    "// 3.1. update the left child",
    "this.controller.updateNodeGradStats(2 * this.nid + 1, splitEntry.leftGradStat);",
    "// 3.2. update the right child",
    "this.controller.updateNodeGradStats(2 * this.nid + 2, splitEntry.rightGradStat);",
    "}",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[1], since the first item is the minimal",
    "feature value",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "int sendStartCol = startFid * 7; // each split contains 7 doubles",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "tips: here we set the fvalue=splitIndex, true split value = sketches[splitIdx+1]",
    "the task use index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "grad.timesBy(-1.0 * lr);",
    "System.out.println(\"Quantile sketch indices: \" + Arrays.toString(qSketch.getValues()));",
    "System.out.println(\"Max: \" + qSketch.max() + \", min: \" + qSketch.min());",
    "System.out.println(\"Quantile sketch count: \" + Arrays.toString(qSketch.getCounts()));",
    "System.out.println(\"Zero index: \" + qSketch.getZeroIndex() + \", \"",
    "+ qSketch.get(qSketch.getZeroIndex()) + \", \" + qSketch.get(qSketch.getZeroIndex()-1));",
    "cmSketch.distribution();",
    "write2File(cmSketch.getTable(0), \"E:\\\\dropbox\\\\code\\\\github\\\\sketchML\\\\table0\");",
    "write2File(cmSketch.getTable(1), \"E:\\\\dropbox\\\\code\\\\github\\\\sketchML\\\\table1\");",
    "write2File(cmSketch.getTable(2), \"E:\\\\dropbox\\\\code\\\\github\\\\sketchML\\\\table2\");",
    "System.out.println(\"true freq: \" + trueFreq + \", sketch freq: \" + cmFreq);",
    "System.out.println(\"true grad: \" + grad.get(i) + \", sketch grad: \" + (- qSketch.get(cmFreq)));",
    "ratioArr[ratio]++;",
    "System.out.println(\"true grad: \" + grad.get(i) + \", sketch grad: \" + qSketch.get(cmFreq));",
    "System.out.println(\"true grad: \" + grad.get(i) + \", sketch grad: \" + qSketch.get(cmFreq));",
    "ratioArr[ratio]++;",
    "System.out.println(Arrays.toString(distArr));",
    "System.out.println(Arrays.toString(ratioArr));",
    "System.out.println(\"Nnz grad: \" + nnz +\", zero grad: \" + zeroGrad + \", negative grad: \" + negCount + \", larger grad: \" + largeCount + \", smaller grad: \" + smallCount);",
    "write2File(distArr, \"E:\\\\dropbox\\\\code\\\\github\\\\sketchML\\\\error_hist\");",
    "for (int i = 0; i < grad.getDimension(); i++) {",
    "System.out.println(\"true grad: \" + grad.get(i) + \", sketch grad: \" + qSketch.get(qSketch.indexOf(grad.get(i))));",
    "grad.set(i, qSketch.get(qSketch.indexOf(grad.get(i))));",
    "}",
    "System.out.println(\"Cur index of rIndex: \" + Arrays.toString(curIdx));",
    "change to delta store",
    "System.out.println(\"Before compression: \" + Arrays.toString(rIndex[i]));",
    "System.out.println(\"After compression: \" + Arrays.toString(rIndex[i]));",
    "System.out.println(\"Compressed \" + nnz + \" item to \" + bytes",
    "+ \" bytes, average bytes per item: \" + (double) bytes / qSketch.totalCount()",
    "+ \", uncompressed bytes: \" + 8 * grad.getDimension());",
    "for (int i = 0; i < qSketchSize; i++) {",
    "int tmp = 0;",
    "for (int j = 0; j < curIdx[i]; j++) {",
    "tmp += rIndex[i][j];",
    "grad.set(tmp, qSketch.getSplit(i));",
    "}",
    "}",
    "System.out.println(\"Start calculate loss and auc, sample number: \" + totalNum);",
    "test.trainSGD2(dataset, 47001, 20, 0.01, 0.01, 100);",
    "System.out.println(\"Indices: \" + Arrays.toString(indices));",
    "t[i][code]++;",
    "else if (Math.random() > 0.5) {",
    "t[i][code] = freq;",
    "}",
    "System.out.println(\"Change from \" + t[i][code] + \" to \" + freq);",
    "ret = Math.min(ret, t[i][h[i].encode(key)]);",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "get feature type, 0:empty 1:all equal 2:real",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "v1.1.0": [
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConfiguration.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "Thread.sleep(5000);",
    "response = master.getJobReport(null, request);",
    "assertEquals(response.getJobReport().getJobState(), JobStateProto.J_FAILED);",
    "assertEquals(response.getJobReport().getCurIteration(), jobIteration);",
    "assertEquals(response.getJobReport().getDiagnostics(), \"failed\");",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "DenseIntVector deltaVec = new DenseIntVector(100000, delta);",
    "deltaVec.setMatrixId(matrixW1Id);",
    "deltaVec.setRowId(0);",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConfiguration.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test ps agent id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "Note:[startRow,endRow)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "group0Id = new WorkerGroupId(0);",
    "worker0Id = new WorkerId(group0Id, 0);",
    "worker0Attempt0Id = new WorkerAttemptId(worker0Id, 0);",
    "task0Id = new TaskId(0);",
    "task1Id = new TaskId(1);",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "test this func in testWriteTo",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "LOG.info(index[0] + \" \" + value[0]);",
    "LOG.info(index[1] + \" \" + value[1]);",
    "LOG.info(index[2] + \" \" + value[2]);",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plusBy",
    "@Test",
    "public void dotDenseFloatVector() throws Exception {",
    "int dim = 1000;",
    "Random random = new Random(System.currentTimeMillis());",
    "",
    "double[] values = new double[dim];",
    "float[] values_1 = new float[dim];",
    "for (int i = 0; i < dim; i++) {",
    "values[i] = random.nextDouble();",
    "values_1[i] = random.nextFloat();",
    "}",
    "",
    "DenseDoubleVector vec = new DenseDoubleVector(dim, values);",
    "TDoubleVector vec_1 = new DenseFloatVector(dim, values_1);",
    "",
    "double sum = 0.0;",
    "for (int i = 0; i < dim; i++) {",
    "sum += values[i] * values_1[i];",
    "}",
    "",
    "assertEquals(sum, vec.dot(vec_1));",
    "",
    "}",
    "@Test",
    "public void plusDenseFlaotVector() throws Exception {",
    "double[] value_1 = new double[]{0.1, 0.2, 0.3, 0.4, 0.5};",
    "double[] value_2 = new double[]{0.1f, 0.2f, 0.3f, 0.4f, 0.5f};",
    "DenseDoubleVector vec = new DenseDoubleVector(5, value_1);",
    "TDoubleVector vec_1 = new DenseFloatVector(5, value_2);",
    "",
    "TDoubleVector vec_2 = vec.plus(vec_1);",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(value_1[i] + value_2[i], vec_2.get(i));",
    "",
    "",
    "TDoubleVector vec_3 = vec.plus(vec_1, 2.0);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec_3.get(i), value_1[i] + 2 * value_2[i]);",
    "",
    "double[] oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + vec_1.get(i));",
    "",
    "oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1, 3);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + 3 * vec_1.get(i));",
    "}",
    "@Test",
    "public void plusByArrayTest() {",
    "DenseFloatVector vec = new DenseFloatVector(dim);",
    "int[] index = genSortedIndexs(nnz, dim);",
    "float[] deltF = genFloatArray(nnz);",
    "double[] deltD = genDoubleArray(nnz);",
    "",
    "float[] oldVal = vec.getValues().clone();",
    "vec.plusBy(index, deltF);",
    "for (int i = 0; i < nnz; i++) {",
    "int idx = index[i];",
    "assertEquals(oldVal[idx] + deltF[i], vec.get(idx));",
    "}",
    "",
    "oldVal = vec.getValues().clone();",
    "vec.plusBy(index, deltD);",
    "for (int i = 0; i < nnz; i++) {",
    "int idx = index[i];",
    "assertEquals(oldVal[idx] + (float) deltD[i], vec.get(idx));",
    "}",
    "",
    "oldVal = vec.getValues().clone();",
    "vec.plusBy(index, deltF);",
    "for (int i = 0; i < nnz; i++) {",
    "int idx = index[i];",
    "assertEquals(oldVal[idx] + deltF[i], vec.get(idx));",
    "}",
    "",
    "oldVal = vec.getValues().clone();",
    "vec.plusBy(index, deltD);",
    "for (int i = 0; i < nnz; i++) {",
    "int idx = index[i];",
    "assertEquals(oldVal[idx] + (float) deltD[i], vec.get(idx));",
    "}",
    "}",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "@Test",
    "public void plusBy3() throws Exception {",
    "float[][] value = {{1.0f, 2.0f}, {3.0f, 4.0f}};",
    "DenseFloatMatrix mat = new DenseFloatMatrix(2, 2,value);",
    "TFloatVector vec = new DenseFloatVector(2, new float[]{1.0f, 1.0f});",
    "vec.setRowId(0);",
    "TDoubleVector vec_1 = new DenseDoubleVector(2, new double[]{1.0f, 1.0f});",
    "vec_1.setRowId(1);",
    "TDoubleVector vec_2 = new SparseDoubleVector(2);",
    "vec_2.set(1, 1.0);",
    "vec_2.setRowId(0);",
    "",
    "mat.plusBy(vec);",
    "mat.plusBy(vec_1);",
    "mat.plusBy(vec_2);",
    "",
    "assertEquals(2.0f, mat.get(0, 0));",
    "assertEquals(4.0f, mat.get(0, 1));",
    "assertEquals(4.0f, mat.get(1, 0));",
    "assertEquals(5.0f, mat.get(1, 1));",
    "}",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "test worker getActiveTaskNum",
    "test worker getTaskNum",
    "test worker getTaskManager",
    "test workerId",
    "test workerAttemptId",
    "tet worker initFinished",
    "test worker getInitMinclock",
    "test worker loacation",
    "test AppId",
    "test Conf",
    "test UserName",
    "master location",
    "masterClient",
    "test psAgent",
    "test worker get dataBlockManager",
    "workerGroup.getSplits();",
    "application",
    "lcation",
    "workerGroup info",
    "worker info",
    "task",
    "Matrix parameters",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "Create an Angel client",
    "Add different types of matrix",
    "using mock object",
    "verification",
    "Stubbing",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "Security framework already loaded the tokens into current UGI, just use",
    "them",
    "Now remove the AM->RM token so tasks don't have it",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "init parameter server manager",
    "recover task information if needed",
    "init psagent manager and register psagent manager event",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "check if parameter server can commit now.",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "check whether psagent heartbeat timeout",
    "check whether parameter server heartbeat timeout",
    "check whether worker heartbeat timeout",
    "choose a unused port",
    "start RPC server",
    "find matrix partitions from master matrix meta manager for this parameter server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "private boolean matrixInited;",
    "check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "dispatch matrix partitions to parameter servers",
    "update matrix id generator",
    "check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "dispatch matrix partitions to parameter servers",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "waitForMatrixReleaseOnPS(matrixId);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "Transitions from the NEW state.",
    "PA_FAILMSG",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG",
    "event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event",
    "dispatched before PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will",
    "retry another attempt or failed",
    "release container",
    "TODO",
    "set the launch time",
    "set tarckerName,httpPort, which used by webserver",
    "added to psManager so psManager can monitor it;",
    "psAttempt.getContext().getParameterServerManager.registerPSAttempt(psAttempt.attemptId);",
    "set the finish time only if launch time is set",
    "ParameterServerJVM.setVMEnv(myEnv, conf);",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "This is so that, if the child forks another \"bin/hadoop\" (common in",
    "streaming) it will have the correct loglevel.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Transitions from the NEW state.",
    "Transitions from the RUNNING state.",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "init and start master committer",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and COMMITTING, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Build and initialize rpc client to master",
    "Build local location",
    "Initialize matrix info, this method will wait until master accepts the information from",
    "client",
    "Get ps locations from master and put them to the location cache.",
    "Initialize matrix meta information",
    "Start heartbeat thread if need",
    "Start all services",
    "Register to master first",
    "Report state to master every specified time",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "array stores clock for each row and clock",
    "local task num",
    "mapping from task index to taskId",
    "mapping from taskId to task index",
    "TODO Auto-generated method stub",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "Get partitions for the matrix",
    "Filter it, removing zero values",
    "Doing average or not",
    "Split this row according the matrix partitions",
    "Add the splits to the result container",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "Then submit normal task until reach upper limit of flow control or all tasks are submit",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "allocate the bytebuf",
    "check the location of server is ready, if not, we should wait",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "find the partition request context from cache",
    "Check if the result of the sub-request is received",
    "Update received result number",
    "Get row splits received",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO Auto-generated method stub",
    "Check futures, if the result of a sub-request is received, put it to the result queue",
    "Now we just support pipelined row splits merging for dense type row",
    "Wait until the clock value of this row is greater than or equal to the value",
    "Get partitions for this row",
    "First get this row from matrix storage",
    "If the row exists in the matrix storage and the clock value meets the requirements, just",
    "return",
    "Get row splits of this row from the matrix cache first",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "use update index if exist",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "matrix id to task update index map. each task may only update some specific part for a matrix",
    "if (matrixManager.getMatrixMeta(createResponse.getMatrixId()) != null) {",
    "return matrixManager.getMatrixMeta(createResponse.getMatrixId());",
    "}",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "close is a local operation and should finish within milliseconds; timeout just to be safe",
    "response will be null for one way messages.",
    "maxFrameLength = 2G",
    "lengthFieldOffset = 0",
    "lengthFieldLength = 8",
    "lengthAdjustment = -8, i.e. exclude the 8 byte length itself",
    "initialBytesToStrip = 8, i.e. strip out the length field itself",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "Disable Nagle's Algorithm since we don't want packets to wait",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "private static UnpooledByteBufAllocator allocator = new UnpooledByteBufAllocator(false);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "load angel system configuration",
    "load user configuration:",
    "1. user config file",
    "2. command lines",
    "add user resource files to \"angel.lib.jars\" to upload to hdfs",
    "load user job jar if it exist",
    "Expand the environment variable",
    "instance submitter class",
    "Add default fs(local fs) for lib jars.",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "JobStateProto jobState = report.getJobState();",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "private final ParameterServerId serverId;",
    "private final PSIdProto idProto;",
    "Add tokens to new user so that it may execute its task correctly.",
    "to exit",
    "mkdir does not throw exception if path exits",
    "commitTaskPool.shutdown();",
    "private final ParameterServer psServer;",
    "TODO",
    "when we should write snapshot to hdfs? clearly, we have two methods:",
    "1. write snapshot at regular time, if there are updates, just write them.",
    "2. write snapshot every N iterations, this method depends on notification of master",
    "FSDataOutputStream output = fileContext.create(snapshotsTempFilePath,",
    "EnumSet.of(CreateFlag.CREATE));",
    "@brief get filename of the old snapshot written before",
    "no snapshotFile write before, maybe write snapshots the first time",
    "start end",
    "rowtype",
    "data.rewind();",
    "data.rewind();",
    "data.rewind();",
    "Pass the matrix and partition number field",
    "Mapping from taskId to clock value.",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "nnz = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "nnz++;",
    "}",
    "sparseRep = null;",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "}",
    "sparseRep = null;",
    "output.writeInt(data.length);",
    "@Override",
    "public void serialize(ByteBuf buf) {",
    "if (sparseRep != null)",
    "return serializeSparse();",
    "else if (denseRep != null)",
    "return serializeDense();",
    "return serializeEmpty();",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int idx = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "keysBuf.put(idx, keys[i]);",
    "valuesBuf.put(idx, values[i]);",
    "idx++;",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int ov, k, v;",
    "for (int i = 0; i < keys.length; i++) {",
    "if (used[i]) {",
    "k = keys[i];",
    "ov = denseRep.get(k);",
    "v = ov + values[i];",
    "denseRep.put(k, v);",
    "if (ov != 0 && v == 0)",
    "nnz--;",
    "}",
    "}",
    "add the PSAgentContext,need fix",
    "set MatrixPartitionLocation",
    "set attribute",
    "TODO Auto-generated method stub",
    "@brief Sorted index for non-zero items",
    "@brief Number of non-zero items in this vector",
    "@brief Array to store values.",
    "@brief sum of the square of all of element",
    "LOG.error(\"Cannot perform plus operation on SparseDoubleSortedVector\");",
    "TODO Auto-generated method stub",
    "TODO:",
    "TODO:",
    "write the max abs",
    "Thread.currentThread().getContextClassLoader().getResourceAsStream(\"feature_conf.xml\");",
    "this.matchList = new ArrayList<Match>();",
    "LOG.debug(String.format(\"index: %d, value: %s\", index, value));",
    "LOG.debug(String.format(\"index: %d, value: %s\", index, value));",
    "LOG.debug(String.format(\"index: %d, value: %s\", index, value));",
    "LOG.debug(String.format(\"index: %d, value: %s\", index, value));",
    "LOG.debug(\"target=\" + target);",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "Add tokens to new user so that it may execute its task correctly.",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "private Configuration conf;",
    "TODO Auto-generated constructor stub",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Submit GBDT Train Task",
    "Load Model from HDFS.",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, save model, log path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set trainning data path",
    "Set data format",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set log sava path",
    "Feature number of train data",
    "Total iteration number",
    "Validation Ratio",
    "Data format",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set basic configuration keys",
    "Set data format",
    "Use local deploy mode",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd SVM algorithm parameters",
    "set input, output path",
    "Set save model path",
    "Set actionType train",
    "Set log path",
    "Submit LR Train Task",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log sava path",
    "Set actionType prediction",
    "double z=pre*y;",
    "if(z<=0) return 0.5-z;",
    "else if(z>0 && z<1) return 0.5*Math.pow(1-z,2);",
    "return 0.0;",
    "if (pre * y <= 0)",
    "return y;",
    "else if (pre * y > 0 && pre * y < 1)",
    "return (1 - pre * y) * y;",
    "return 0.0;",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the zero bin of all features, then loop the non-zero entries of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "4. add the grad and hess sum to the zero bin of all features",
    "int startIdx = fid * 2 * splitNum;",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx+1]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "partition number",
    "cols of each partition",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[1], since the first item is the minimal",
    "feature value",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "2.3. find the best split of current feature",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, split value = sketches[splitIdx+1], the task use",
    "index to find fvalue",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "clear all the information",
    "calculate the sum of gradient and hess",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "gradient",
    "second order gradient",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "return the default evaluation metric for the objective",
    "read partition header",
    "deal with row according the rowType",
    "TODO Auto-generated method stub",
    "tree.tree[topic + K] = (row.get(topic) + beta) / (n_k.get(topic) + vbeta);",
    "Inc update to local buffers",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "loss function",
    "gradient and hessian",
    "tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "2. push local sketch to PS",
    "3. set phase to GET_SKETCH",
    "pull the global sketch from PS, only called once by each worker",
    "sample feature",
    "push sampled feature set to the current tree",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "2.2. if use all the features, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "7. set phase to run active",
    "1. start threads of active tree nodes",
    "1.1. start threads for active nodes to generate histogram",
    "1.2. set thread status to running",
    "1.3. set the oplog to active",
    "2. check thread stats, if all threads finish, return",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "2.3. find best split result of this tree node",
    "2.3.1 using server split, each partition of the histogram contains its best split result",
    "find the best split from all partitions",
    "2.3.2 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.3 otherwise, the returned histogram contains the gradient info",
    "2.3.4 the updated split result (tree node/feature/value/gain) on PS,",
    "2.3.5 reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "5. split node",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "6. clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "than the split value",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current tree",
    "calculate the error",
    "predict();",
    "finish current depth",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in GradHistHelper, update the grad stats of children nodes after finding the best split",
    "the root node's stats is updated by leader worker",
    "1. create the update",
    "2. push the update to PS",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "LOG.info(String.format(\"Histogram: size[%d] %s\", histogram.getDimension(),",
    "Arrays.toString(histogram.getValues())));",
    "4. reset thread stats to finished",
    "int sendStartCol = startFid * 7; // each split contains 7 doubles",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "return MathUtils.sqr(sumGrad) / (sumHess + regLambda);",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "same as add, reduce is used in All Reduce",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */",
    "gradient",
    "second order gradient",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "LOG.info(String.format(\"Histogram of feature[%d]: %s\", trueFid,",
    "Arrays.toString(curHistogram.getValues())));",
    "2.3. find the best split of current feature",
    "LOG.info(String.format(\"Best split of feature[%d]: value[%f], gain[%f]\",",
    "trueFid, curSplit.getFvalue(), curSplit.getLossChg()));",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "LOG.info(String.format(\"Find the best split for fid[%d] in server row, size[%d], startIdx[%d]\",",
    "fid, row.size(), startIdx));",
    "StringBuilder sb = new StringBuilder();",
    "for (int i = startIdx; i < startIdx + 2 * splitNum; i++) {",
    "sb.append(row.getData().get(i) + \", \");",
    "}",
    "LOG.info(\"Server row: \" + sb.toString());",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "LOG.info(String.format(\"Feature[%d]: sumGrad[%f], sumHess[%f], gain[%f]\",",
    "fid, rootStats.sumGrad, rootStats.sumHess, rootGain));",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "LOG.info(String.format(\"The current split: fid[%d], split index[%f], lossChg[%f]\",",
    "fid, (float) splitIdx, lossChg));",
    "here we set the fvalue=splitIndex, split value = sketches[splitIdx+1], the task use",
    "index to find fvalue",
    "LOG.info(String.format(\"Find new best split: fid[%d], fvalue[%f], lossChg[%f]\",",
    "splitEntry.fid, splitEntry.fvalue, splitEntry.lossChg));",
    "LOG.info(String.format(\"Left child of node[%d]: sumGrad[%f], sumHess[%f]; \" +",
    "\"right child of node[%d]: sumGrad[%f], sumHess[%f]; lossChg[%f]\",",
    "this.nid, leftStats.sumGrad, leftStats.sumHess,",
    "this.nid, rightStats.sumGrad, rightStats.sumHess, lossChg));",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "LOG.info(String.format(\"The best split for fid[%d], split feature[%d]: split index[%f], lossChg[%f], \"",
    "+",
    "\"leftSumGrad[%f], leftSumHess[%f], rightSumGrad[%f], rightSumHess[%f]\",",
    "fid, splitEntry.fid, splitEntry.fvalue, splitEntry.lossChg,",
    "splitEntry.leftGradStat.sumGrad, splitEntry.leftGradStat.sumHess,",
    "splitEntry.rightGradStat.sumGrad, splitEntry.rightGradStat.sumHess));",
    "grad.timesBy(-1.0 * lr);",
    "System.out.println(\"Quantile sketch indices: \" + Arrays.toString(qSketch.getValues()));",
    "System.out.println(\"Max: \" + qSketch.max() + \", min: \" + qSketch.min());",
    "System.out.println(\"Quantile sketch count: \" + Arrays.toString(qSketch.getCounts()));",
    "System.out.println(\"Zero index: \" + qSketch.getZeroIndex() + \", \"",
    "+ qSketch.get(qSketch.getZeroIndex()) + \", \" + qSketch.get(qSketch.getZeroIndex()-1));",
    "cmSketch.distribution();",
    "write2File(cmSketch.getTable(0), \"E:\\\\dropbox\\\\code\\\\github\\\\sketchML\\\\table0\");",
    "write2File(cmSketch.getTable(1), \"E:\\\\dropbox\\\\code\\\\github\\\\sketchML\\\\table1\");",
    "write2File(cmSketch.getTable(2), \"E:\\\\dropbox\\\\code\\\\github\\\\sketchML\\\\table2\");",
    "System.out.println(\"true freq: \" + trueFreq + \", sketch freq: \" + cmFreq);",
    "System.out.println(\"true grad: \" + grad.get(i) + \", sketch grad: \" + (- qSketch.get(cmFreq)));",
    "ratioArr[ratio]++;",
    "System.out.println(\"true grad: \" + grad.get(i) + \", sketch grad: \" + qSketch.get(cmFreq));",
    "System.out.println(\"true grad: \" + grad.get(i) + \", sketch grad: \" + qSketch.get(cmFreq));",
    "ratioArr[ratio]++;",
    "System.out.println(Arrays.toString(distArr));",
    "System.out.println(Arrays.toString(ratioArr));",
    "System.out.println(\"Nnz grad: \" + nnz +\", zero grad: \" + zeroGrad + \", negative grad: \" + negCount + \", larger grad: \" + largeCount + \", smaller grad: \" + smallCount);",
    "write2File(distArr, \"E:\\\\dropbox\\\\code\\\\github\\\\sketchML\\\\error_hist\");",
    "for (int i = 0; i < grad.getDimension(); i++) {",
    "System.out.println(\"true grad: \" + grad.get(i) + \", sketch grad: \" + qSketch.get(qSketch.indexOf(grad.get(i))));",
    "grad.set(i, qSketch.get(qSketch.indexOf(grad.get(i))));",
    "}",
    "System.out.println(\"Cur index of rIndex: \" + Arrays.toString(curIdx));",
    "change to delta store",
    "System.out.println(\"Before compression: \" + Arrays.toString(rIndex[i]));",
    "System.out.println(\"After compression: \" + Arrays.toString(rIndex[i]));",
    "System.out.println(\"Compressed \" + nnz + \" item to \" + bytes",
    "+ \" bytes, average bytes per item: \" + (double) bytes / qSketch.totalCount()",
    "+ \", uncompressed bytes: \" + 8 * grad.getDimension());",
    "for (int i = 0; i < qSketchSize; i++) {",
    "int tmp = 0;",
    "for (int j = 0; j < curIdx[i]; j++) {",
    "tmp += rIndex[i][j];",
    "grad.set(tmp, qSketch.getSplit(i));",
    "}",
    "}",
    "System.out.println(\"Start calculate loss and auc, sample number: \" + totalNum);",
    "test.trainSGD2(dataset, 47001, 20, 0.01, 0.01, 100);",
    "System.out.println(\"Indices: \" + Arrays.toString(indices));",
    "t[i][code]++;",
    "else if (Math.random() > 0.5) {",
    "t[i][code] = freq;",
    "}",
    "System.out.println(\"Change from \" + t[i][code] + \" to \" + freq);",
    "ret = Math.min(ret, t[i][h[i].encode(key)]);",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "get feature type, 0:empty 1:all equal 2:real",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ],
  "v1.0.0": [
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "set basic configuration keys",
    "use local deploy mode and dummy data spliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "row 0 is a random uniform",
    "row 1 is a random normal",
    "row 2 is filled with 1.0",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Load Model from HDFS.",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, and save model path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log path",
    "Set actionType prediction",
    "Feature number of train data",
    "Total iteration number",
    "Learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set input data path",
    "Set save model path",
    "Set actionType train",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "worker register",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt 1",
    "attempt 2",
    "attempt 3",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "attempt 0",
    "attempt1",
    "attempt1",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "conf.set(AngelConfiguration.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName());",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "DenseIntVector deltaVec = new DenseIntVector(100000, delta);",
    "deltaVec.setMatrixId(matrixW1Id);",
    "deltaVec.setRowId(0);",
    "TODO Auto-generated constructor stub",
    "import com.tencent.angel.psagent.consistency.SSPConsistencyController;",
    "@RunWith(MockitoJUnitRunner.class)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConfiguration.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "get a angel client",
    "add matrix",
    "test create matrix",
    "Int2IntOpenHashMap matrix1Clocks = task1.getMatrixClocks();",
    "assertEquals(matrix1Clocks.size(), 2);",
    "assertEquals(matrix1Clocks.get(w1Id), 1);",
    "assertEquals(matrix1Clocks.get(w2Id), 1);",
    "psAgent.initAndStart();",
    "test conf",
    "test master location",
    "test app id",
    "test user",
    "test ps agent attempt id",
    "test ps agent id",
    "test connection",
    "test master client",
    "test ip",
    "test loc",
    "test master location",
    "test ps location",
    "assertEquals(psLoc, locationCache.updateAndGetPSLocation(psId));",
    "test all ps ids",
    "test all matrix ids",
    "test all matrix names",
    "test matrix attribute",
    "test matrix meta",
    "test ps location",
    "test partitions",
    "PartitionKey part1 = matrixPartitionRouter.getPartitionKey(1, 0);",
    "assertTrue(part1 != null);",
    "assertEquals(part1, partition1Keys.get(0));",
    "PartitionKey part2 = matrixPartitionRouter.getPartitionKey(2, 0);",
    "assertTrue(part2 != null);",
    "assertEquals(part2, partition2Keys.get(1));",
    "assertEquals(((SSPConsistencyController) consistControl).getStaleness(), staleness);",
    "PartitionKey part1 = psAgent.getMatrixPartitionRouter().getPartitionKey(1, 0);",
    "int part1Clock = clockCache.getClock(1, part1);",
    "assertEquals(part1Clock, 0);",
    "",
    "PartitionKey part2 = psAgent.getMatrixPartitionRouter().getPartitionKey(2, 0);",
    "int part2Clock = clockCache.getClock(2, part2);",
    "assertEquals(part2Clock, 0);",
    "Note:[startRow,endRow)",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "test this func in testWriteMatrix",
    "test this func in testClock",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "group0Id = new WorkerGroupId(0);",
    "worker0Id = new WorkerId(group0Id, 0);",
    "worker0Attempt0Id = new WorkerAttemptId(worker0Id, 0);",
    "task0Id = new TaskId(0);",
    "task1Id = new TaskId(1);",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "LOG.info(serverArbitraryIntRow1.getSparseRep());",
    "test this func in testWriteTo",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "LOG.info(index[0] + \" \" + value[0]);",
    "LOG.info(index[1] + \" \" + value[1]);",
    "LOG.info(index[2] + \" \" + value[2]);",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plusBy",
    "@Test",
    "public void dotDenseFloatVector() throws Exception {",
    "int dim = 1000;",
    "Random random = new Random(System.currentTimeMillis());",
    "",
    "double[] values = new double[dim];",
    "float[] values_1 = new float[dim];",
    "for (int i = 0; i < dim; i++) {",
    "values[i] = random.nextDouble();",
    "values_1[i] = random.nextFloat();",
    "}",
    "",
    "DenseDoubleVector vec = new DenseDoubleVector(dim, values);",
    "TDoubleVector vec_1 = new DenseFloatVector(dim, values_1);",
    "",
    "double sum = 0.0;",
    "for (int i = 0; i < dim; i++) {",
    "sum += values[i] * values_1[i];",
    "}",
    "",
    "assertEquals(sum, vec.dot(vec_1));",
    "",
    "}",
    "@Test",
    "public void plusDenseFlaotVector() throws Exception {",
    "double[] value_1 = new double[]{0.1, 0.2, 0.3, 0.4, 0.5};",
    "double[] value_2 = new double[]{0.1f, 0.2f, 0.3f, 0.4f, 0.5f};",
    "DenseDoubleVector vec = new DenseDoubleVector(5, value_1);",
    "TDoubleVector vec_1 = new DenseFloatVector(5, value_2);",
    "",
    "TDoubleVector vec_2 = vec.plus(vec_1);",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(value_1[i] + value_2[i], vec_2.get(i));",
    "",
    "",
    "TDoubleVector vec_3 = vec.plus(vec_1, 2.0);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec_3.get(i), value_1[i] + 2 * value_2[i]);",
    "",
    "double[] oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + vec_1.get(i));",
    "",
    "oldValues = vec.getValues().clone();",
    "",
    "vec.plusBy(vec_1, 3);",
    "",
    "for (int i = 0; i < vec.size(); i++)",
    "assertEquals(vec.get(i), oldValues[i] + 3 * vec_1.get(i));",
    "}",
    "@Test",
    "public void plusByArrayTest() {",
    "DenseFloatVector vec = new DenseFloatVector(dim);",
    "int[] index = genSortedIndexs(nnz, dim);",
    "float[] deltF = genFloatArray(nnz);",
    "double[] deltD = genDoubleArray(nnz);",
    "",
    "float[] oldVal = vec.getValues().clone();",
    "vec.plusBy(index, deltF);",
    "for (int i = 0; i < nnz; i++) {",
    "int idx = index[i];",
    "assertEquals(oldVal[idx] + deltF[i], vec.get(idx));",
    "}",
    "",
    "oldVal = vec.getValues().clone();",
    "vec.plusBy(index, deltD);",
    "for (int i = 0; i < nnz; i++) {",
    "int idx = index[i];",
    "assertEquals(oldVal[idx] + (float) deltD[i], vec.get(idx));",
    "}",
    "",
    "oldVal = vec.getValues().clone();",
    "vec.plusBy(index, deltF);",
    "for (int i = 0; i < nnz; i++) {",
    "int idx = index[i];",
    "assertEquals(oldVal[idx] + deltF[i], vec.get(idx));",
    "}",
    "",
    "oldVal = vec.getValues().clone();",
    "vec.plusBy(index, deltD);",
    "for (int i = 0; i < nnz; i++) {",
    "int idx = index[i];",
    "assertEquals(oldVal[idx] + (float) deltD[i], vec.get(idx));",
    "}",
    "}",
    "dot",
    "plus",
    "plusBy",
    "dot",
    "plus",
    "plusBy",
    "@Test",
    "public void plusBy3() throws Exception {",
    "float[][] value = {{1.0f, 2.0f}, {3.0f, 4.0f}};",
    "DenseFloatMatrix mat = new DenseFloatMatrix(2, 2,value);",
    "TFloatVector vec = new DenseFloatVector(2, new float[]{1.0f, 1.0f});",
    "vec.setRowId(0);",
    "TDoubleVector vec_1 = new DenseDoubleVector(2, new double[]{1.0f, 1.0f});",
    "vec_1.setRowId(1);",
    "TDoubleVector vec_2 = new SparseDoubleVector(2);",
    "vec_2.set(1, 1.0);",
    "vec_2.setRowId(0);",
    "",
    "mat.plusBy(vec);",
    "mat.plusBy(vec_1);",
    "mat.plusBy(vec_2);",
    "",
    "assertEquals(2.0f, mat.get(0, 0));",
    "assertEquals(4.0f, mat.get(0, 1));",
    "assertEquals(4.0f, mat.get(1, 0));",
    "assertEquals(5.0f, mat.get(1, 1));",
    "}",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "get a angel client",
    "add matrix",
    "test worker getActiveTaskNum",
    "test worker getTaskNum",
    "test worker getTaskManager",
    "test workerId",
    "test workerAttemptId",
    "tet worker initFinished",
    "test worker getInitMinclock",
    "test worker loacation",
    "test AppId",
    "test Conf",
    "test UserName",
    "master location",
    "masterClient",
    "test psAgent",
    "test worker get dataBlockManager",
    "workerGroup.getSplits();",
    "application",
    "lcation",
    "workerGroup info",
    "worker info",
    "task",
    "Matrix parameters",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "Create an Angel client",
    "Add different types of matrix",
    "using mock object",
    "verification",
    "Stubbing",
    "Default does nothing.",
    "The app injection is optional",
    "renderText(\"hello world\");",
    "user choose a workerGroupID from the workergroups page,",
    "now we should change the AngelApp params and render the workergroup page;",
    "static final String WORKER_ID = \"worker.id\";",
    "div(\"#logo\").",
    "img(\"/static/hadoop-st.png\")._().",
    "import org.apache.hadoop.yarn.webapp.view.FooterBlock;",
    "import org.apache.hadoop.yarn.webapp.view.HeaderBlock;",
    "JQueryUI.jsnotice(html);",
    "import org.apache.hadoop.conf.Configuration;",
    "import java.lang.reflect.Field;",
    "get block locations from file system",
    "create a list of all block and their locations",
    "if the file is not splitable, just create the one block with",
    "full file length",
    "each split can be a maximum of maxSize",
    "if remainder is between max and 2*max - then",
    "instead of creating splits of size max, left-max we",
    "create splits of size left/2 and left/2. This is",
    "a heuristic to avoid creating really really small",
    "splits.",
    "add this block to the block --> node locations map",
    "For blocks that do not have host/rack information,",
    "assign to default  rack.",
    "add this block to the rack --> block map",
    "Add this host to rackToNodes map",
    "add this block to the node --> block map",
    "if the file system does not have any rack information, then",
    "use dummy rack location.",
    "The topology paths have the host name included as the last",
    "component. Strip it.",
    "get tokens for all the required FileSystems..",
    "TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs,",
    "job.getConfiguration());",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "all the files in input set",
    "it is allowed for maxSize to be 0. Disable smoothing load for such cases",
    "process all nodes and create splits that are local to a node. Generate",
    "one split per node iteration, and walk over nodes multiple times to",
    "distribute the splits across nodes.",
    "Skip the node if it has previously been marked as completed.",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "Remove all blocks which may already have been assigned to other",
    "splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Remove entries from blocksInNode so that we don't walk these",
    "again.",
    "Done creating a single split for this node. Move on to the next",
    "node so that splits are distributed across nodes.",
    "This implies that the last few blocks (or all in case maxSize=0)",
    "were not part of a split. The node is complete.",
    "if there were any blocks left over and their combined size is",
    "larger than minSplitNode, then combine them into one split.",
    "Otherwise add them back to the unprocessed pool. It is likely",
    "that they will be combined with other blocks from the",
    "same rack later on.",
    "This condition also kicks in when max split size is not set. All",
    "blocks on a node will be grouped together into a single split.",
    "haven't created any split on this machine. so its ok to add a",
    "smaller one for parallelism. Otherwise group it in the rack for",
    "balanced size create an input split and add it to the splits",
    "array",
    "Remove entries from blocksInNode so that we don't walk this again.",
    "The node is done. This was the last set of blocks for this node.",
    "Put the unplaced blocks back into the pool for later rack-allocation.",
    "Node is done. All blocks were fit into node-local splits.",
    "Check if node-local assignments are complete.",
    "All nodes have been walked over and marked as completed or all blocks",
    "have been assigned. The rest should be handled via rackLock assignment.",
    "LOG.info(\"DEBUG: Terminated node allocation with : CompletedNodes: \"",
    "+ completedNodes.size() + \", size left: \" + totalLength);",
    "if blocks in a rack are below the specified minimum size, then keep them",
    "in 'overflow'. After the processing of all racks is complete, these",
    "overflow blocks will be combined into splits.",
    "Process all racks over and over again until there is no more work to do.",
    "Create one split for this rack before moving over to the next rack.",
    "Come back to this rack after creating a single split for each of the",
    "remaining racks.",
    "Process one rack location at a time, Combine all possible blocks that",
    "reside on this rack as one split. (constrained by minimum and maximum",
    "split size).",
    "iterate over all racks",
    "for each block, copy it into validBlocks. Delete it from",
    "blockToNodes so that the same block does not appear in",
    "two different splits.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "if we created a split, then just go to the next rack",
    "if there is a minimum size specified, then create a single split",
    "otherwise, store these blocks into overflow data structure",
    "There were a few blocks in this rack that",
    "remained to be processed. Keep them in 'overflow' block list.",
    "These will be combined later.",
    "Process all overflow blocks",
    "This might cause an exiting rack location to be re-added,",
    "but it should be ok.",
    "if the accumulated split size exceeds the maximum, then",
    "create this split.",
    "create an input split and add it to the splits array",
    "Process any remaining blocks, if any.",
    "create an input split",
    "add this split to the list that is returned",
    "long num = totLength / maxSize;",
    "all blocks for all the files in input set",
    "mapping from a rack name to the list of blocks it has",
    "mapping from a block to the nodes on which it has replicas",
    "mapping from a node to the list of blocks that it contains",
    "populate all the blocks for all files",
    "stop all services",
    "1.write application state to file so that the client can get the state of the application",
    "if master exit",
    "2.clear tmp and staging directory",
    "waiting for client to get application state",
    "stop the RPC server",
    "add a shutdown hook",
    "init app state storage",
    "init event dispacher",
    "init location manager",
    "init container allocator",
    "init a rpc service",
    "recover matrix meta if needed",
    "recover ps attempt information if need",
    "init parameter server manager",
    "recover task information if needed",
    "init psagent manager and register psagent manager event",
    "a dummy data spliter is just for test now",
    "recover data splits information if needed",
    "init worker manager and register worker manager event",
    "register slow worker/ps checker",
    "register app manager event and finish event",
    "start a web service if use yarn deploy mode",
    "load from app state storage first if attempt index great than 1(the master is not the first",
    "retry)",
    "if load failed, just build a new MatrixMetaManager",
    "load ps attempt index from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "load task information from app state storage first if attempt index great than 1(the master",
    "is not the first retry)",
    "if load failed, just build a new AMTaskManager",
    "load data splits information from app state storage first if attempt index great than 1(the",
    "master is not the first retry)",
    "if load failed, we need to recalculate the data splits",
    "parse parameter server counters",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "refresh last heartbeat timestamp",
    "send a state update event to the specific PSAttempt",
    "check if parameter server can commit now.",
    "check matrix metadata inconsistencies between master and parameter server.",
    "if a matrix exists on the Master and does not exist on ps, then it is necessary to notify ps to establish the matrix",
    "if a matrix exists on the ps and does not exist on master, then it is necessary to notify ps to remove the matrix",
    "if psAttemptId is not in monitor set, just return a PSCOMMAND_SHUTDOWN command.",
    "check whether psagent heartbeat timeout",
    "check whether parameter server heartbeat timeout",
    "check whether worker heartbeat timeout",
    "choose a unused port",
    "start RPC server",
    "find matrix partitions from master matrix meta manager for this parameter server",
    "remove this parameter server attempt from monitor set",
    "remove this parameter server attempt from monitor set",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "find workergroup in worker manager",
    "if this worker group does not initialized, just return WORKERGROUP_NOTREADY",
    "if this worker group run over, just return WORKERGROUP_EXITED",
    "if this worker group is running now, return tasks, workers, data splits for it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "if worker attempt id is not in monitor set, we should shutdown it",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update the clock for this matrix",
    "get Task meta from task manager, if can not find, just new a AMTask object and put it to task manager",
    "in ANGEL_PS mode, task id may can not know advance",
    "update task iteration",
    "private boolean matrixInited;",
    "check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "dispatch matrix partitions to parameter servers",
    "update matrix id generator",
    "check whether the matrix name conflicts with the existing matrix names, the matrix name must be only",
    "dispatch matrix partitions to parameter servers",
    "get matrix ids in the parameter server report",
    "get the matrices parameter server need to create and delete",
    "if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix",
    "if a matrix exists on master but not exist on parameter server, this parameter server need build it.",
    "waitForMatrixReleaseOnPS(matrixId);",
    "Calculate how many splits we need. As each task handles a separate split of data, so we want",
    "the number of splits equal to the number of tasks",
    "split data",
    "dispatch the splits to workergroups",
    "split data",
    "dispatch the splits to workergroups",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Set split minsize and maxsize to expected split size. We need to get the total size of data",
    "first, then divided by expected split number",
    "get input format class from configuration and then instantiation a input format object",
    "split data",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "Since the actual split size is sometimes not exactly equal to the expected split size, we",
    "need to fine tune the number of workergroup and task based on the actual split number",
    "Dispatch data splits to workergroups, each SplitClassification corresponds to a workergroup.",
    "Record the location information for the splits in order to data localized schedule",
    "write meta data to a temporary file",
    "rename the temporary file to final file",
    "if the file exists, read from file and deserialize it",
    "write task meta",
    "write ps meta",
    "generate a temporary file",
    "write task meta to the temporary file first",
    "rename the temporary file to the final file",
    "if last final task file exist, remove it",
    "find task meta file which has max timestamp",
    "if the file does not exist, just return null",
    "read task meta from file and deserialize it",
    "generate a temporary file",
    "write ps meta to the temporary file first.",
    "rename the temporary file to the final file",
    "if the old final file exist, just remove it",
    "find ps meta file",
    "if ps meta file does not exist, just return null",
    "read ps meta from file and deserialize it",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "Transitions from the NEW state.",
    "PA_FAILMSG",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG",
    "event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event",
    "dispatched before PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will",
    "retry another attempt or failed",
    "release container",
    "TODO",
    "set the launch time",
    "set tarckerName,httpPort, which used by webserver",
    "added to psManager so psManager can monitor it;",
    "psAttempt.getContext().getParameterServerManager.registerPSAttempt(psAttempt.attemptId);",
    "set the finish time only if launch time is set",
    "ParameterServerJVM.setVMEnv(myEnv, conf);",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "This is so that, if the child forks another \"bin/hadoop\" (common in",
    "streaming) it will have the correct loglevel.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Transitions from the NEW state.",
    "Transitions from the RUNNING state.",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "Application resources",
    "Application environment",
    "Service data",
    "Tokens",
    "Set up JobConf to be localized properly on the remote NM.",
    "Setup DistributedCache",
    "Setup up task credentials buffer",
    "LocalStorageToken is needed irrespective of whether security is enabled",
    "or not.",
    "TokenCache.setJobToken(jobToken, taskCredentials);",
    "Add pwd to LD_LIBRARY_PATH, add this before adding anything else",
    "Construct the actual Container",
    "The null fields are per-container and will be constructed for each",
    "container separately.",
    "Set up the launch command",
    "Duplicate the ByteBuffers for access by multiple containers.",
    "Construct the actual Container",
    "a * in the classpath will only find a .jar, so we need to filter out",
    "all .jars and add everything else",
    "Propagate the system classpath when using the mini cluster",
    "Add standard Hadoop classes",
    "Cache archives",
    "Cache files",
    "Sanity check",
    "Add URI fragment or just the filename",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Finally add the jvmID",
    "vargs.add(String.valueOf(jvmID.getId()));",
    "Final commmand",
    "Add the env variables passed by the user",
    "Set logging level in the environment.",
    "Setup the log4j prop",
    "Add main class and its arguments",
    "Final commmand",
    "if amTask is not null, we should clone task state from it",
    "if all parameter server complete commit, master can commit now",
    "init and start master committer",
    "Transitions from the NEW state.",
    "Transitions from the UNASSIGNED state.",
    "when user kill task, or task timeout, psAttempt will receive TA_FAILMSG event",
    "Transitions from the ASSIGNED state.",
    "this happened when launch thread run slowly, and PA_REGISTER event dispatched before",
    "PA_CONTAINER_LAUNCHED event",
    "Transitions from the PSAttemptStateInternal.RUNNING state.",
    "Transitions from the PSAttemptStateInternal.COMMITTING state",
    "Transitions from the PSAttemptStateInternal.KILLED state",
    "Transitions from the PSAttemptStateInternal.FAILED state",
    "create the topology tables",
    "reqeuest resource:send a resource request to the resource allocator",
    "Once the resource is applied, build and send the launch request to the container launcher",
    "deallocator the resource of the ps attempt:send a resource deallocator request to the",
    "resource allocator",
    "set the launch time",
    "add the ps attempt to the heartbeat timeout monitoring list",
    "parse ps attempt location and put it to location manager",
    "send PS_ATTEMPT_FAILED to AMParameterServer, AMParameterServer will retry another attempt",
    "or failed",
    "remove ps attempt id from heartbeat timeout monitor list",
    "release container:send a release request to container launcher",
    "set the finish time only if launch time is set",
    "private long scheduledTime;",
    "Transitions from the NEW state.",
    "Transitions from the SCHEDULED state.",
    "Transitions from the RUNNING state.",
    "another attempt launched,",
    "Transitions from the SUCCEEDED state",
    "Transitions from the KILLED state",
    "Transitions from the FAILED state",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "start a new attempt for this ps",
    "notify ps manager",
    "notify the event handler of state change",
    "If new state is not RUNNING and COMMITTING, add it to state timeout monitor",
    "if forcedState is set, just return",
    "else get state from state machine",
    "add this worker group to the success set",
    "check if all worker group run over",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "add this worker group to the failed set",
    "check if too many worker groups are failed or killed",
    "notify a run failed event",
    "calculate the actual number of worker groups and the total number of tasks based on the number of data split",
    "init all tasks , workers and worker groups and put them to the corresponding maps",
    "just return the total task number now",
    "TODO",
    "if workerAttempt is not null, we should clone task state from it",
    "from NEW state",
    "from SCHEDULED state",
    "get data splits location for data locality",
    "reqeuest resource:send a resource request to the resource allocator",
    "once the resource is applied, build and send the launch request to the container launcher",
    "notify failed message to the worker",
    "notify killed message to the worker",
    "release the allocated container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "release the allocated container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "clean the container",
    "notify failed message to the worker",
    "remove the worker attempt from heartbeat timeout listen list",
    "record the finish time",
    "clean the container",
    "notify killed message to the worker",
    "remove the worker attempt from heartbeat timeout listening list",
    "record the finish time",
    "if the worker attempt launch successfully, add it to heartbeat timeout listening list",
    "set worker attempt location",
    "notify the register message to the worker",
    "record the launch time",
    "update worker attempt metrics",
    "update tasks metrics",
    "clean the container",
    "notify the worker attempt run successfully message to the worker",
    "record the finish time",
    "init a worker attempt for the worker",
    "schedule the worker attempt",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "add diagnostic",
    "check whether the number of failed attempts is less than the maximum number of allowed",
    "init and start a new attempt for this ps",
    "notify worker manager",
    "If we need Yarn to restart a new application master, we should not unregister from Yarn RM",
    "register to Yarn RM",
    "send heartbeat to Yarn RM every rmPollInterval milliseconds",
    "catch YarnRuntimeException, we should exit and need not retry",
    "build heartbeat request",
    "send heartbeat request to rm",
    "This can happen if the RM has been restarted. If it is in that state,",
    "this application must clean itself up.",
    "Setting NMTokens",
    "assgin containers",
    "if some container is not assigned, release them",
    "handle finish containers",
    "dispatch container exit message to corresponding components",
    "killed by framework",
    "killed by framework",
    "killed by framework",
    "get application finish state",
    "build application diagnostics",
    "TODO:add a job history for angel",
    "build unregister request",
    "send unregister request to rm",
    "Note this down for next interaction with ResourceManager",
    "based on blacklisting comments above we can end up decrementing more",
    "than requested. so guard for that.",
    "send the updated resource request to RM",
    "send 0 container count requests also to cancel previous requests",
    "Update resource requests",
    "try to assign to all nodes first to match node local",
    "try to match all rack local",
    "assign remaining",
    "Update resource requests",
    "send the container-assigned event to task attempt",
    "build the start container request use launch context",
    "send the start request to Yarn nm",
    "send the message that the container starts successfully to the corresponding component",
    "after launching, send launched event to task attempt to move",
    "it from ASSIGNED to RUNNING state",
    "send the message that the container starts failed to the corresponding component",
    "kill the remote container if already launched",
    "start a thread pool to startup the container",
    "See if we need up the pool size only if haven't reached the",
    "maximum limit yet.",
    "nodes where containers will run at *this* point of time. This is",
    "*not* the cluster size and doesn't need to be.",
    "Bump up the pool size to idealPoolSize+INITIAL_POOL_SIZE, the",
    "later is just a buffer so we are not always increasing the",
    "pool-size",
    "the events from the queue are handled in parallel",
    "using a thread pool",
    "return if already stopped",
    "shutdown any containers that might be left running",
    "Build and initialize rpc client to master",
    "Build local location",
    "Initialize matrix info, this method will wait until master accepts the information from",
    "client",
    "Get ps locations from master and put them to the location cache.",
    "Initialize matrix meta information",
    "Start heartbeat thread if need",
    "Start all services",
    "Register to master first",
    "Report state to master every specified time",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "Notify run success to master only on ANGEL_PS_PSAGENT running mode",
    "Stop all modules",
    "Exit the process if on ANGEL_PS_PSAGENT mode",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "Update generic resource counters",
    "Updating resources specified in ResourceCalculatorProcessTree",
    "Remove the CPU time consumed previously by JVM reuse",
    "array stores clock for each row and clock",
    "local task num",
    "mapping from task index to taskId",
    "mapping from taskId to task index",
    "TODO Auto-generated method stub",
    "Generate a flush request and put it to request queue",
    "Generate a clock request and put it to request queue",
    "Generate a merge request and put it to request queue",
    "If the matrix op log cache does not exist for the matrix, create a new one for the",
    "matrix",
    "and add it to cache maps",
    "Add the message to the tree map",
    "If there are flush / clock requests blocked, we need to put this merge request into",
    "the waiting queue",
    "Launch a merge worker to merge the update to matrix op log cache",
    "Remove the message from the tree map",
    "Wake up blocked flush/clock request",
    "Add flush/clock request to listener list to waiting for all the existing",
    "updates are merged",
    "Wake up blocked flush/clock request",
    "If all updates are merged for this matrix, we need wake up flush/clock requests which are",
    "blocked.",
    "Get next merge message sequence id",
    "Wake up listeners(flush/clock requests) that have little sequence id than current merge",
    "position",
    "Wake up blocked merge requests",
    "Get minimal sequence id from listeners",
    "If hogwild mode is enabled on the number of local task is more than 1 on SSP mode, we",
    "should flush updates to local matrix storage",
    "unused now",
    "Get partitions for the matrix",
    "Filter it, removing zero values",
    "Doing average or not",
    "Split this row according the matrix partitions",
    "Add the splits to the result container",
    "For each partition, we generate a update split.",
    "Although the split is empty for partitions those without any update data,",
    "we still need to generate a update split to update the clock info on ps.",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "Then submit normal task until reach upper limit of flow control or all tasks are submit",
    "if submit task in getQueue failed, we should make up the last chosen get queue index",
    "LOG.info(\"choose put server \" + psIds[index]);",
    "allocate the bytebuf",
    "check the location of server is ready, if not, we should wait",
    "get a channel to server from pool",
    "if channel is not valid, it means maybe the connections to the server are closed",
    "channelManager.removeChannelPool(loc);",
    "find the partition request context from cache",
    "Check if the result of the sub-request is received",
    "Update received result number",
    "Get row splits received",
    "Put the row split to the cache(row index to row splits map)",
    "If all splits of the row are received, means this row can be merged",
    "TODO Auto-generated method stub",
    "Check futures, if the result of a sub-request is received, put it to the result queue",
    "Now we just support pipelined row splits merging for dense type row",
    "Wait until the clock value of this row is greater than or equal to the value",
    "Get partitions for this row",
    "First get this row from matrix storage",
    "If the row exists in the matrix storage and the clock value meets the requirements, just",
    "return",
    "Get row splits of this row from the matrix cache first",
    "If the row split does not exist in cache, get it from parameter server",
    "Wait the final result",
    "Put it to the matrix cache",
    "Split the matrix oplog according to the matrix partitions",
    "If need update clock, we should send requests to all partitions",
    "use update index if exist",
    "Filter the rowIds which are fetching now",
    "Send the rowIndex to rpc dispatcher and return immediately",
    "Get the partition to sub-row splits map:use to storage the rows stored in a matrix partition",
    "Generate dispatch items and add them to the corresponding queues",
    "Pre-fetching is disable default",
    "matrix id to clock map",
    "task index, it must be unique for whole application",
    "matrix id to task update index map. each task may only update some specific part for a matrix",
    "if (matrixManager.getMatrixMeta(createResponse.getMatrixId()) != null) {",
    "return matrixManager.getMatrixMeta(createResponse.getMatrixId());",
    "}",
    "Deserialize data splits meta",
    "Get workers",
    "Send request to every ps",
    "Wait the responses",
    "Update clock cache",
    "Get row from cache.",
    "if row clock is satisfy ssp staleness limit, just return.",
    "Get row from ps.",
    "For ASYNC mode, just get from pss.",
    "For BSP/SSP, get rows from storage/cache first",
    "Get from ps.",
    "For ASYNC, just get rows from pss.",
    "no more retries.",
    "calculate sleep time and return.",
    "parse the i-th sleep-time",
    "parse the i-th number-of-retries",
    "calculateSleepTime may overflow.",
    "A few common retry policies, with no delays.",
    "response will be null for one way messages.",
    "serial number and list size",
    "indicates whether this connection's life cycle is managed",
    "See if we already have a connection (common case)",
    "create a unique lock for this RS + protocol (if necessary)",
    "get the RS lock",
    "do one more lookup in case we were stalled above",
    "Only create isa when we need to.",
    "definitely a cache miss. establish an RPC for",
    "this RS",
    "Throw what the RemoteException was carrying.",
    "check",
    "every",
    "minutes",
    "TODO",
    "\u521b\u5efafailoverHandler",
    "The number of times this invocation handler has ever been failed over,",
    "before this method invocation attempt. Used to prevent concurrent",
    "failed method invocations from triggering multiple failover attempts.",
    "Make sure that concurrent failed method invocations",
    "only cause a",
    "single actual fail over.",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "LOG.info(\"method \" + method.getName() + \"construct request time = \"",
    "+ (System.currentTimeMillis() - beforeConstructTs));",
    "get an instance of the method arg type",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "Message (hand written code usually has only a single",
    "argument)",
    "log any RPC responses that are slower than the configured",
    "warn",
    "response time or larger than configured warning size",
    "when tagging, we let TooLarge trump TooSmall to keep",
    "output simple",
    "note that large responses will often also be slow.",
    "provides a count of log-reported slow responses",
    "RpcController + Message in the method args",
    "(generated code from RPC bits in .proto files have",
    "RpcController)",
    "unexpected",
    "in the protobuf methods, args[1] is the only significant argument",
    "for JSON encoding",
    "base information that is reported regardless of type of call",
    "DefaultChannelFuture.setUseDeadLockChecker(false);",
    "Set up.",
    "Configure the event pipeline factory.",
    "Make a new connection.",
    "Need to reconnect",
    "Upgrade to write lock",
    "Downgrade to read lock:",
    "(TODO: why use writeLock? why not use this.channel instead of channel?",
    "Remove all pending requests (will be canceled after relinquishing",
    "write lock).",
    "Cancel any pending requests by sending errors to the callbacks:",
    "Close the channel:",
    "Close the connection:",
    "Shut down all thread pools to exit.",
    "LOG.info(\"serial \" + serial + \"start time = \" + System.currentTimeMillis());",
    "See NettyServer.prepareResponse for where we write out the response.",
    "It writes the call.id (int), a boolean signifying any error (and if",
    "so the exception name/trace), and the response bytes",
    "Read the call id.",
    "When the stream is closed, protobuf doesn't raise an EOFException,",
    "instead, it returns a null message object.",
    "channel = e.getChannel();",
    "channel = e.getChannel();",
    "LOG.info(\"method \" + dataPack.getSerial() + \" received ts = \" +",
    "System.currentTimeMillis());",
    "Make an ml rpc client.",
    "It would be good widen this to just Throwable, but IOException is what we",
    "allow now",
    "not implemented",
    "not implemented",
    "track what RpcEngine is used by a proxy class, for stopProxy()",
    "cache of RpcEngines by protocol",
    "return the RpcEngine configured to handle a protocol",
    "We only handle the ConnectException.",
    "This is the exception we can't handle.",
    "check if timed out",
    "wait for retry",
    "IGNORE",
    "return the RpcEngine that handles a proxy object",
    "The default implementation works synchronously",
    "punt: allocate a new buffer & copy into it",
    "LOG.info(System.getProperty(\"user.dir\"));",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "get tokens for all the required FileSystems..",
    "Whether we need to recursive look into the directory structure",
    "creates a MultiPathFilter with the hiddenFileFilter and the",
    "user provided one (if any).",
    "LOG.info(\"Total input paths to process : \" + result.size());",
    "a simple hdfs copy function assume src path and dest path are in same hdfs",
    "and FileSystem object has same schema",
    "LOG.warn(\"interrupted while sleeping\", ie);",
    "private static UnpooledByteBufAllocator allocator = new UnpooledByteBufAllocator(false);",
    "public static String getHostname() {",
    "try {",
    "return new StringBuilder().append(\"\").append(InetAddress.getLocalHost()).toString();",
    "} catch (UnknownHostException uhe) {",
    "}",
    "return new StringBuilder().append(\"\").append(uhe).toString();",
    "}",
    "public static void startupShutdownMessage(Class<?> clazz, String[] args, Log LOG) {",
    "String hostname = getHostname();",
    "String classname = clazz.getSimpleName();",
    "LOG.info(toStartupShutdownString(\"STARTUP_MSG: \", new String[]{new",
    "StringBuilder().append(\"Starting \").append(classname).toString(), new",
    "StringBuilder().append(\"  host = \").append(hostname).toString(), new",
    "StringBuilder().append(\"  args = \").append(Arrays.asList(args)).toString(), new",
    "StringBuilder().append(\"  version = \").append(VersionInfo.getVersion()).toString(), new",
    "StringBuilder().append(\"  build = \").append(VersionInfo.getUrl()).append(\" -r \").append(VersionInfo.getRevision()).append(\"; compiled by '\").append(VersionInfo.getUser()).append(\"' on \").append(VersionInfo.getDate()).toString()}));",
    "",
    "Runtime.getRuntime().addShutdownHook(new Thread(LOG, classname, hostname) {",
    "public void run() {",
    "this.val$LOG.info(StringUtils.access$000(\"SHUTDOWN_MSG: \", new String[]{\"Shutting down \" +",
    "this.val$classname + \" at \" + this.val$hostname}));",
    "}",
    "});",
    "}",
    "We we interrupted because we're meant to stop? If not, just",
    "continue ignoring the interruption",
    "Recalculate waitTime.",
    "// Begin delegation to Thread",
    "// End delegation to Thread",
    "load angel system configuration",
    "load user configuration:",
    "1. user config file",
    "2. command lines",
    "add user resource files to \"angel.lib.jars\" to upload to hdfs",
    "load user job jar if it exist",
    "Expand the environment variable",
    "instance submitter class",
    "Add default fs(local fs) for lib jars.",
    "Obtain filename from path",
    "Split filename to prexif and suffix (extension)",
    "Check if the filename is okay",
    "Prepare temporary file",
    "Prepare buffer for data copying",
    "Open and check input stream",
    "Open output stream and copy data between source file in JAR and the temporary file",
    "If read/write fails, close streams safely before throwing an exception",
    "Finally, load the library",
    "little endian load order",
    "tail",
    "fallthrough",
    "fallthrough",
    "finalization",
    "fmix(h1);",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "----------",
    "body",
    "----------",
    "tail",
    "----------",
    "finalization",
    "JobStateProto jobState = report.getJobState();",
    "generate tmp output directory",
    "the leaf level file should be readable by others",
    "the subdirs in the path should have execute permissions for",
    "others",
    "2.get job id",
    "Credentials credentials = new Credentials();",
    "4.copy resource files to hdfs",
    "5.write configuration to a xml file",
    "6.create am container context",
    "7.Submit to ResourceManager",
    "8.get app master client",
    "Create a number of filenames in the JobTracker's fs namespace",
    "add all the command line files/ jars and archive",
    "first copy them to jobtrackers filesystem",
    "should not throw a uri exception",
    "should not throw an uri excpetion",
    "set the timestamps of the archives and files",
    "set the public/private visibility of the archives and files",
    "get DelegationToken for each cached file",
    "check if we do not need to copy the files",
    "is jt using the same file system.",
    "just checking for uri strings... doing no dns lookups",
    "to see if the filesystems are the same. This is not optimal.",
    "but avoids name resolution.",
    "this might have name collisions. copy will throw an exception",
    "parse the original path to create new path",
    "check for ports",
    "Write job file to JobTracker's fs",
    "Setup resource requirements",
    "Setup LocalResources",
    "Setup security tokens",
    "Setup the command to run the AM",
    "Add AM user command opts",
    "Final command",
    "Setup the CLASSPATH in environment",
    "i.e. add { Hadoop jars, job jar, CWD } to classpath.",
    "Setup the environment variables for Admin first",
    "Setup the environment variables (LD_LIBRARY_PATH, etc)",
    "Parse distributed cache",
    "Setup ContainerLaunchContext for AM container",
    "Set up the ApplicationSubmissionContext",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "resposne.encode(buf);",
    "TODO:",
    "private final ParameterServerId serverId;",
    "private final PSIdProto idProto;",
    "to exit",
    "mkdir does not throw exception if path exits",
    "commitTaskPool.shutdown();",
    "private final ParameterServer psServer;",
    "TODO",
    "when we should write snapshot to hdfs? clearly, we have two methods:",
    "1. write snapshot at regular time, if there are updates, just write them.",
    "2. write snapshot every N iterations, this method depends on notification of master",
    "FSDataOutputStream output = fileContext.create(snapshotsTempFilePath,",
    "EnumSet.of(CreateFlag.CREATE));",
    "@brief get filename of the old snapshot written before",
    "no snapshotFile write before, maybe write snapshots the first time",
    "start end",
    "rowtype",
    "data.rewind();",
    "data.rewind();",
    "data.rewind();",
    "Pass the matrix and partition number field",
    "Mapping from taskId to clock value.",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "nnz = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "nnz++;",
    "}",
    "sparseRep = null;",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "denseRep.put(keys[i], values[i]);",
    "}",
    "sparseRep = null;",
    "output.writeInt(data.length);",
    "@Override",
    "public void serialize(ByteBuf buf) {",
    "if (sparseRep != null)",
    "return serializeSparse();",
    "else if (denseRep != null)",
    "return serializeDense();",
    "return serializeEmpty();",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int idx = 0;",
    "for (int i = 0; i < keys.length; i++)",
    "if (used[i]) {",
    "keysBuf.put(idx, keys[i]);",
    "valuesBuf.put(idx, values[i]);",
    "idx++;",
    "}",
    "int[] keys = sparseRep.getKeys();",
    "int[] values = sparseRep.getValues();",
    "boolean[] used = sparseRep.getUsed();",
    "int ov, k, v;",
    "for (int i = 0; i < keys.length; i++) {",
    "if (used[i]) {",
    "k = keys[i];",
    "ov = denseRep.get(k);",
    "v = ov + values[i];",
    "denseRep.put(k, v);",
    "if (ov != 0 && v == 0)",
    "nnz--;",
    "}",
    "}",
    "add the PSAgentContext,need fix",
    "set MatrixPartitionLocation",
    "set attribute",
    "TODO Auto-generated method stub",
    "@brief Sorted index for non-zero items",
    "@brief Number of non-zero items in this vector",
    "@brief Array to store values.",
    "@brief sum of the square of all of element",
    "LOG.error(\"Cannot perform plus operation on SparseDoubleSortedVector\");",
    "TODO Auto-generated method stub",
    "TODO:",
    "TODO:",
    "write the max abs",
    "Thread.currentThread().getContextClassLoader().getResourceAsStream(\"feature_conf.xml\");",
    "this.matchList = new ArrayList<Match>();",
    "LOG.debug(String.format(\"index: %d, value: %s\", index, value));",
    "LOG.debug(String.format(\"index: %d, value: %s\", index, value));",
    "LOG.debug(String.format(\"index: %d, value: %s\", index, value));",
    "LOG.debug(String.format(\"index: %d, value: %s\", index, value));",
    "LOG.debug(\"target=\" + target);",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "TODO Auto-generated method stub",
    "get configuration from config file",
    "set localDir with enviroment set by nm.",
    "get master location",
    "init task manager and start tasks",
    "start heartbeat thread",
    "taskManager.assignTaskIds(response.getTaskidsList());",
    "todo",
    "if worker timeout, it may be knocked off.",
    "SUCCESS, do nothing",
    "heartbeatFailedTime = 0;",
    "private KEY currentKey;",
    "will be created",
    "TODO Auto-generated method stub",
    "Bitmap bitmap = new Bitmap();",
    "int max = indexArray[size - 1];",
    "byte [] bitIndexArray = new byte[max / 8 + 1];",
    "for(int i = 0; i < size; i++){",
    "int bitIndex = indexArray[i] >> 3;",
    "int bitOffset = indexArray[i] - (bitIndex << 3);",
    "switch(bitOffset){",
    "case 0:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x01);break;",
    "case 1:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x02);break;",
    "case 2:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x04);break;",
    "case 3:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x08);break;",
    "case 4:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x10);break;",
    "case 5:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x20);break;",
    "case 6:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x40);break;",
    "case 7:bitIndexArray[bitIndex] = (byte) (bitIndexArray[bitIndex] & 0x80);break;",
    "}",
    "}",
    "//////////////////////////////",
    "Application Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Master Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Worker Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "Task Configs",
    "//////////////////////////////",
    "//////////////////////////////",
    "ParameterServer Configs",
    "//////////////////////////////",
    "////////////////// IPC //////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "//////////////////////////////",
    "Matrix transfer Configs.",
    "//////////////////////////////",
    "Configs used to ANGEL_PS_PSAGENT running mode future.",
    "model parse",
    "private Configuration conf;",
    "TODO Auto-generated constructor stub",
    "set basic configuration keys",
    "use local deploy mode and dummy dataspliter",
    "conf.setInt(AngelConfiguration.ANGEL_PREPROCESS_VECTOR_MAXDIM, 10000);",
    "conf.set(AngelConfiguration.ANGEL_MODEL_PATH, LOCAL_FS + TMP_PATH + \"/out\");",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "get a angel client",
    "add matrix",
    "Feature number of train data",
    "Number of nonzero features",
    "Tree number",
    "Tree depth",
    "Split number",
    "Feature sample ratio",
    "Data format",
    "Learning rate",
    "Set basic configuration keys",
    "Use local deploy mode and dummy data spliter",
    "set input, output path",
    "set angel resource parameters #worker, #task, #PS",
    "Set GBDT algorithm parameters",
    "Submit GBDT Train Task",
    "Load Model from HDFS.",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "Set trainning data, save model, log path",
    "Set actionType train",
    "Set MF algorithm parameters",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Batch number",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set log path",
    "Set actionType incremental train",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "LOG.info(sigmoid(data[i]));",
    "LOG.info(Math.exp(-data[i]));",
    "when b is a negative number",
    "Cluster center number",
    "Feature number of train data",
    "Total iteration number",
    "Sample ratio per mini-batch",
    "C",
    "Set local deploy mode",
    "Set basic configuration keys",
    "set angel resource parameters #worker, #task, #PS",
    "set Kmeans algorithm parameters #cluster #feature #epoch",
    "Set trainning data path",
    "Set data format",
    "Set save model path",
    "Set log sava path",
    "Set actionType train",
    "Set load model path",
    "Set predict result path",
    "Set actionType prediction",
    "Set log sava path",
    "Feature number of train data",
    "Total iteration number",
    "Validation Ratio",
    "Data format",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set basic configuration keys",
    "Set data format",
    "Use local deploy mode",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd SVM algorithm parameters",
    "set input, output path",
    "Set save model path",
    "Set actionType train",
    "Set log path",
    "Submit LR Train Task",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Feature number of train data",
    "Total iteration number",
    "Validation sample Ratio",
    "Data format, libsvm or dummy",
    "Train batch number per epoch.",
    "Learning rate",
    "Decay of learning rate",
    "Regularization coefficient",
    "Set local deploy mode",
    "Set basic configuration keys",
    "Set data format",
    "set angel resource parameters #worker, #task, #PS",
    "set sgd LR algorithm parameters #feature #epoch",
    "Set trainning data path",
    "Set save model path",
    "Set log path",
    "Set actionType train",
    "Set trainning data path",
    "Set load model path",
    "Set save model path",
    "Set actionType incremental train",
    "Set log path",
    "Set trainning data path",
    "Set load model path",
    "Set predict result path",
    "Set log sava path",
    "Set actionType prediction",
    "double z=pre*y;",
    "if(z<=0) return 0.5-z;",
    "else if(z>0 && z<1) return 0.5*Math.pow(1-z,2);",
    "return 0.0;",
    "if (pre * y <= 0)",
    "return y;",
    "else if (pre * y > 0 && pre * y < 1)",
    "return (1 - pre * y) * y;",
    "return 0.0;",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "the minimal split value is the minimal value of feature",
    "the splits do not include the maximal value of feature",
    "1. the average distance, (maxValue - minValue) / splitNum",
    "2. calculate the candidate split value",
    "insIdx is the index of instances",
    "loop over features",
    "int[] counts = {10, 2, 1, 2, 0, 3, 0, 5};",
    "setting",
    "ranking.",
    "clear all the information",
    "map feature id to the position in units",
    "add hist unit of each feature",
    "loop instance's position, find those belong to nid",
    "calculate the sum of gradient and hess",
    "queue of nodes to be expanded, -1 means no work",
    "map active node to its working index offset in qexpand",
    "can be -1, which means the node is not actively expanding",
    "position of each instances in the tree",
    "can be negative, which means this ins2Node is no longer expanding",
    "used to candidate split cut value",
    "HistSet of all nodes, use node2Work to find the position",
    "loss function",
    "gradient statistics",
    "create loss function",
    "calculate gradient info",
    "add root node, including split entry",
    "add root node work",
    "create split value helper",
    "init instance position to root",
    "init histogram",
    "calculate grad info of each instance",
    "add active work(node) to queue",
    "add new work to the queue",
    "init histogram",
    "get one work(node) from queue, -1 means no active work",
    "get candidate split values",
    "build gradient histogram",
    "get candidate split value",
    "find the best split from candidates, add new node to tree",
    "add new node,",
    "set node's left and right children",
    "create left and right children node, add them to regtree",
    "create node stats for children nodes add them to regtree",
    "job after splits",
    "update work queue, add new work to queue, update node to work",
    "update instance pos,",
    "no extra work for leaf node",
    "update work queue, set finished node to inactive",
    "set node's work to inactive, set node2Work to inactivate",
    "add children node's work to queue",
    "update instance ins2Node",
    "update instance's corresponding node",
    "LOG.info(String.format(\"Move ins[%d] fid[%d] fvalue[%f] to node[%d]\",",
    "insIdx, fid, fvalue, 2 * nid + 1));",
    "LOG.info(String.format(\"Move ins[%d] fid[%d] fvalue[%f] to node[%d]\",",
    "insIdx, fid, fvalue, 2 * nid + 2));",
    "check whether there exist active works in the queue",
    "change the node to leaf",
    "change to leaf",
    "update the preds of instances",
    "evaluate the pre result",
    "build the regression tree",
    "if reach the max depth, set it to leaf",
    "1. new feature's histogram (grad + hess)",
    "size: sampled_featureNum * (2 * splitNum)",
    "in other words, concatenate each feature's histogram",
    "2. get the span of this node",
    "------ 3. using sparse-aware method to build histogram ---",
    "first add grads of all instances to the first bin of all features, then loop the non-zero",
    "entries",
    "the grad sum and hess sum of all the instances",
    "3.1. get the instance index",
    "3.2. get the grad and hess of the instance",
    "3.3. add to the sum",
    "LOG.info(String.format(\"Instance[%d]: indices size[%d], indices%s\",",
    "insIdx, instance.getIndices().length, Arrays.toString(instance.getIndices())));",
    "LOG.info(String.format(\"Instance[%d]: values size[%d], values%s \",",
    "insIdx, instance.getValues().length, Arrays.toString(instance.getValues())));",
    "3.4. loop the non-zero entries",
    "3.4.1. get feature value",
    "3.4.2. current feature's position in the sampled feature set",
    "3.4.3. find the position of feature value in a histogram",
    "the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "3.4.4. add the grad and hess to the corresponding bin",
    "3.4.5. add the reverse to the bin that contains 0.0f",
    "int gradStartIdx = 2 * splitNum * fPos;",
    "int hessStartIdx = gradStartIdx + splitNum;",
    "if (idx % 50000 == 0 && fPos % 5 == 0) {",
    "LOG.info(String.format(\"instance:%d, feature pos: %d, index of 0.0f: %d, \" +",
    "\"grad index: %d, hess index: %d\",",
    "idx, fPos, fZeroValueIdx, gradZeroIdx, hessZeroIdx));",
    "}",
    "LOG.info(String.format(\"Add negative grad to index[%d] value[%f], \" +",
    "\"add negative hess to index[%d] value[%f]\",",
    "gradStartIdx, curGrad, hessStartIdx, curHess));",
    "LOG.info(String.format(\"Update 0-th bin grad to %f, 0-th bin hess to %f\",",
    "histogram.get(gradStartIdx), histogram.get(hessStartIdx)));",
    "4. add the grad and hess sum to the first bin of all features",
    "int startIdx = fid * 2 * splitNum;",
    "if (fid % 5000 == 0) {",
    "LOG.info(String.format(\"feature pos: %d, index of 0.0f: %d, \" +",
    "\"grad index: %d, hess index: %d\",",
    "fid, fZeroValueIdx, gradZeroIdx, hessZeroIdx));",
    "}",
    "// 3. loop over all the features of all the instances on this node",
    "for (int idx = nodeStart; idx <= nodeEnd; idx++) {",
    "// 3.1. get the instance index",
    "int insIdx = this.controller.instancePos[idx]; // the instance index",
    "SparseDoubleSortedVector instance = this.controller.dataMeta.instances.get(insIdx);",
    "// 3.2. get instance indices and values",
    "//int[] indices = instance.getIndices();",
    "//double[] values = instance.getValues();",
    "//for (int i = 0; i < indices.length; i++) {",
    "for(int fid = 0; fid < instance.getDimension(); fid++) {",
    "// 3.3. get feature id",
    "//int fid = indices[i];",
    "// 3.4. current feature's position in the sampled feature set",
    "int fPos = findFidPlace(this.controller.fset, fid);",
    "if (fPos == -1) {",
    "continue;",
    "}",
    "// 3.5. get feature value",
    "//float fv = (float) values[i];",
    "float fv = (float) instance.get(fid);",
    "// 3.6. find the position of feature value in a histogram",
    "// the search area in the sketch is [fid * #splitNum, (fid+1) * #splitNum - 1]",
    "int fvalueIdx = findFvaluePlace(this.controller.sketches, fv,",
    "fid * this.controller.param.numSplit, (fid + 1) * this.controller.param.numSplit - 1);",
    "// 3.7. get the grad and hess of the instance",
    "GradPair gradPair = this.controller.gradPairs.get(insIdx);",
    "// 3.8. the updated position in the histogram",
    "// since the siz of histogram = grad(# splitNum) + hess(# splitNum)",
    "// the hessIndex = gradIndex + numSplit",
    "//if (insIdx % 100000 == 0) {",
    "//",
    "LOG.info(String.format(\"Instance[%d], fid: %d, fpos: %d, fvalueIdx: %d, grad: %f, hess: %f\",",
    "// insIdx, fid, fPos, fvalueIdx, gradPair.getGrad(), gradPair.getHess()));",
    "//}",
    "int gradIdx = 2 * this.controller.param.numSplit * fPos + fvalueIdx;",
    "int hessIdx = 2 * this.controller.param.numSplit * fPos + fvalueIdx + this.controller.param.numSplit;",
    "// 3.9. add grad and hess to the corresponding histogram",
    "histogram.set(gradIdx, histogram.get(gradIdx) + gradPair.getGrad());",
    "histogram.set(hessIdx, histogram.get(hessIdx) + gradPair.getHess());",
    "}",
    "}",
    "find the best split result of the histogram of a tree node",
    "1. calculate the gradStats of the root node",
    "1.1. update the grad stats of the root node on PS, only called once by leader worker",
    "2. loop over features",
    "2.1. get the ture feature id in the sampled feature set",
    "2.2. get the indexes of histogram of this feature",
    "LOG.info(String.format(\"Histogram of feature[%d]: %s\", trueFid,",
    "Arrays.toString(curHistogram.getValues())));",
    "2.3. find the best split of current feature",
    "LOG.info(String.format(\"Best split of feature[%d]: value[%f], gain[%f]\",",
    "trueFid, curSplit.getFvalue(), curSplit.getLossChg()));",
    "2.4. update the best split result if possible",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "find the best split result of one feature",
    "LOG.info(String.format(\"Find best split for fid[%d] in histogram[size:%d], startIdx[%d]\",",
    "fid, histogram.getDimension(), startIdx));",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "LOG.info(String.format(\"Node[%d] feature[%d]: sumGrad[%f], sumHess[%f], gain[%f]\",",
    "this.nid, fid, rootStats.sumGrad, rootStats.sumHess, rootGain));",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "split value = sketches[splitIdx+1]",
    "LOG.info(String.format(\"Find new best split: fid[%d], fvalue[%f], lossChg[%f]\",",
    "splitEntry.fid, splitEntry.fvalue, splitEntry.lossChg));",
    "LOG.info(String.format(\"Left child of node[%d]: sumGrad[%f], sumHess[%f]; \" +",
    "\"right child of node[%d]: sumGrad[%f], sumHess[%f]; lossChg[%f]\",",
    "this.nid, leftStats.sumGrad, leftStats.sumHess,",
    "this.nid, rightStats.sumGrad, rightStats.sumHess, lossChg));",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "LOG.info(String.format(\"Best left node grad: sumGrad[%f], sumHess[%f]\",",
    "bestLeftStat.sumGrad, bestLeftStat.sumHess));",
    "LOG.info(String.format(\"Best right node grad: sumGrad[%f], sumHess[%f]\",",
    "bestRightStat.sumGrad, bestRightStat.sumHess));",
    "partition number",
    "cols of each partition",
    "update the grad stats of the root node on PS, only called once by leader worker",
    "3. update the grad stats of children node",
    "3.1. update the left child",
    "3.2. update the right child",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "loop all the possible split value, start from split[1], since the first item is the minimal",
    "feature value",
    "find the best split result of the histogram of a tree node",
    "2.2. get the indexes of histogram of this feature",
    "LOG.info(String.format(\"Histogram of feature[%d]: %s\", trueFid,",
    "Arrays.toString(curHistogram.getValues())));",
    "2.3. find the best split of current feature",
    "LOG.info(String.format(\"Best split of feature[%d]: value[%f], gain[%f]\",",
    "trueFid, curSplit.getFvalue(), curSplit.getLossChg()));",
    "2.4. update the best split result if possible",
    "find the best split result of one feature",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "LOG.info(String.format(\"The current split: fid[%d], split index[%f], lossChg[%f]\",",
    "fid, (float) splitIdx, lossChg));",
    "split value = sketches[splitIdx+1]",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "LOG.info(String.format(\"Histogram of feature[%d]: %s\", trueFid,",
    "Arrays.toString(curHistogram.getValues())));",
    "2.3. find the best split of current feature",
    "LOG.info(String.format(\"Best split of feature[%d]: value[%f], gain[%f]\",",
    "trueFid, curSplit.getFvalue(), curSplit.getLossChg()));",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "1. set the feature id",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "LOG.info(String.format(\"Node[%d] feature[%d]: sumGrad[%f], sumHess[%f], gain[%f]\",",
    "this.nid, fid, rootStats.sumGrad, rootStats.sumHess, rootGain));",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "here we set the fvalue=splitIndex, split value = sketches[splitIdx+1], the task use",
    "index to find fvalue",
    "LOG.info(String.format(\"Find new best split: fid[%d], fvalue[%f], lossChg[%f]\",",
    "splitEntry.fid, splitEntry.fvalue, splitEntry.lossChg));",
    "LOG.info(String.format(\"Left child of node[%d]: sumGrad[%f], sumHess[%f]; \" +",
    "\"right child of node[%d]: sumGrad[%f], sumHess[%f]; lossChg[%f]\",",
    "this.nid, leftStats.sumGrad, leftStats.sumHess,",
    "this.nid, rightStats.sumGrad, rightStats.sumHess, lossChg));",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "LOG.info(String.format(\"Best left node grad: sumGrad[%f], sumHess[%f]\",",
    "bestLeftStat.sumGrad, bestLeftStat.sumHess));",
    "LOG.info(String.format(\"Best right node grad: sumGrad[%f], sumHess[%f]\",",
    "bestRightStat.sumGrad, bestRightStat.sumHess));",
    "features used in this tree, if equals null, means use all the features without sampling",
    "node in the tree",
    "the gradient info of each instances",
    "initialize nodes",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "check if necessary information is ready",
    "same as add, reduce is used in All Reduce",
    "features used in this tree",
    "node in the tree",
    "the gradient info of each instances",
    "initialize feature id",
    "initialize nodes",
    "add root node, creete split entry",
    "initialize statistic of the root, including gradient stats",
    "LOG.info(String.format(\"Add fid[%d] fvalue[%f] to [%d]-bin\", this.fid, fv, i));",
    "loop over all the data in hist",
    "whether we can split with current hessian",
    "right = root -left",
    "whether we can split with current hessian",
    "LOG.info(String.format(\"Left child of node[%d]: sumGrad[%f], sumHess[%f]; \" +",
    "\"right child of node[%d]: sumGrad[%f], sumHess[%f]; lossChg[%f]\",",
    "this.nid, leftStats.sumGrad, leftStats.sumHess,",
    "this.nid, rightStats.sumGrad, rightStats.sumHess, lossChg));",
    "LOG.info(String.format(\"The best split of node[%d]: fid[%d], fvalue[%f], lossChg[%f]\",",
    "this.nid, splitEntry.fid, splitEntry.fvalue, splitEntry.lossChg));",
    "gradient",
    "second order gradient",
    "logistic loss for binary classification task.",
    "logistic loss, but predict un-transformed margin",
    "check if label in range",
    "if (!prob) {",
    "preds.clear();",
    "preds.addAll(rec);",
    "}",
    "return the default evaluation metric for the objective",
    "read partition header",
    "deal with row according the rowType",
    "TODO Auto-generated method stub",
    "tree.tree[topic + K] = (row.get(topic) + beta) / (n_k.get(topic) + vbeta);",
    "Inc update to local buffers",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "print();",
    "The starting point",
    "There's always an unused entry.",
    "The starting point",
    "There's always an unused entry.",
    "loss function",
    "gradient and hessian",
    "tree node",
    "initialize the phase",
    "current tree and depth",
    "create loss function",
    "calculate grad info of each instance",
    "create data sketch, push candidate split value to PS",
    "1. calculate candidate split value",
    "float[][] splits = TAvgDisSplit.getSplitValue(this.dataMeta, this.param.numSplit);",
    "LOG.info(String.format(\"Local sketch size[%d]: %s\",",
    "sketchVec.getDimension(), Arrays.toString(sketchVec.getValues())));",
    "2. push local sketch to PS",
    "sketchClient.activateOpLog(new String[] {this.param.sketchName});",
    "3. set phase to GET_SKETCH",
    "pull the global sketch from PS, only called once by each worker",
    "LOG.info(String.format(\"Sketch vector: %s\", Arrays.toString(sketchVector.getValues())));",
    "this.sketches = Floats.toArray(Doubles.asList(sketchVector.getValues()));",
    "sample feature",
    "push sampled feature set to the current tree",
    "this.taskContext.activateOpLog(new String[] {this.param.sampledFeaturesName});",
    "create new tree",
    "pull sampled features, initialize tree nodes, reset active nodes, reset instance position,",
    "calculate gradient",
    "1. create new tree, initialize tree nodes and node stats",
    "2. initialize feature set, if sampled, get from PS, otherwise use all the features",
    "2.1. pull the sampled features of the current tree",
    "2.2. if use all the featues, only called one",
    "3. reset active tree nodes, set all tree nodes to inactive, set thread status to idle",
    "4. set root node to active",
    "5. reset instance position, set the root node's span",
    "6. calculate gradient",
    "7. set phase to run active",
    "1. start threads of active tree nodes",
    "1.1. start threads for active nodes to generate histogram",
    "1.2. set thread status to running",
    "1.3. set the oplog to active",
    "activeOpLogSet.add(histParaName);",
    "2. check thread stats, if all threads finish, return",
    "this.taskContext.activateOpLog(activeOpLogSet);",
    "clock",
    "find split",
    "1. find responsible tree node, using RR scheme",
    "2. pull gradient histogram",
    "2.1. get the name of this node's gradient histogram on PS",
    "2.2. pull the histogram",
    "find best split result of this tree node",
    "2.4. using server split, each partition of the histogram contains its best split result",
    "find the best split from all partitions",
    "2.5. the updated split result (tree node/feature/value/gain) on PS,",
    "2.4. otherwise, the returned histogram contains the gradient info",
    "2.5. the updated split result (tree node/feature/value/gain) on PS,",
    "2.6. reset this tree node's gradient histogram to 0",
    "3. push split feature to PS",
    "4. push split value to PS",
    "5. push split gain to PS",
    "6. set phase to AFTER_SPLIT",
    "clock",
    "1. get split feature",
    "2. get split value",
    "3. get split gain",
    "4. get node weight",
    "LOG.info(String.format(\"Node grad stats: %s\", Arrays.toString(nodeGradStatsVec.getValues())));",
    "5. split node",
    "5.1. set the children nodes of this node",
    "5.2. set split info and grad stats to this node",
    "5.2. create children nodes",
    "5.3. create node stats for children nodes, and add them to the tree",
    "5.4. reset instance position",
    "5.5. add new active nodes if possible, inc depth, otherwise finish this tree",
    "LOG.info(String.format(\"Current depth: %d, max depth: %d\",",
    "this.currentDepth, this.param.maxDepth));",
    "5.6. set children nodes to leaf nodes",
    "5.7. set nid to leaf node",
    "5.8. deactivate active node",
    "6. check if there is active node, if not, finish current tree",
    "boolean hasActive = hasActiveTNode();",
    "if (!hasActive) {",
    "finishCurrentTree();",
    "this.phase = GBDTPhase.NEW_TREE;",
    "} else {",
    "finishCurrentDepth();",
    "this.phase = GBDTPhase.RUN_ACTIVE;",
    "}",
    "clock",
    "split the span of one node, reset the instance position",
    "in case this worker has no instance on this node",
    "set the span of left child",
    "set the span of right child",
    "1. left to right, find the first instance that should be in the right child",
    "2. right to left, find the first instance that should be in the left child",
    "3. swap two instances",
    "4. find the cut pos",
    "than the split value",
    "5. set the span of left child",
    "6. set the span of right child",
    "set tree node to active",
    "set node to leaf",
    "set node to inactive",
    "finish current tree",
    "calculate the error",
    "predict();",
    "finish current depth",
    "set the tree phase",
    "check if there is active node",
    "check if finish all the tree",
    "update node's grad stats on PS",
    "called during splitting in DistributedHistHelper, update the grad stats of children nodes after",
    "find the best split",
    "the root node's stats is updated by leader worker by one time",
    "// 1.1. get the index of the grad and hess",
    "int[] nodeIndice = { nid, nid + this.activeNode.length };",
    "// 1.2. get the grad sum and hess sum",
    "double[] weightValue = { gradStats.sumGrad, gradStats.sumHess };",
    "1.3. create the update",
    "for (int i = 0; i < nodeIndice.length; i++) {",
    "vec.set(nodeIndice[i], weightValue[i]);",
    "}",
    "1.4. push the update to PS",
    "LOG.info(String.format(\"Update the prediction of instance[%d] to %f, label[%f]\",",
    "insIdx, this.dataMeta.preds[insIdx], this.dataMeta.labels[insIdx]));",
    "the leader task adds node prediction to flush list",
    "1. name of this node's grad histogram on PS",
    "2. build the grad histogram of this node",
    "3. push the histograms to PS",
    "LOG.info(String.format(\"Histogram: size[%d] %s\", histogram.getDimension(),",
    "Arrays.toString(histogram.getValues())));",
    "4. reset thread stats to finished",
    "int sendStartCol = startFid * 7; // each split contains 7 doubles",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "return MathUtils.sqr(sumGrad) / (sumHess + regLambda);",
    "feature index used to split",
    "feature value used to split",
    "loss change after split this node",
    "grad stats of the left child",
    "grad stats of the right child",
    "LOG.info(\"Constructor with fid = -1\");",
    "fid = -1: no split currently",
    "whether this is simply statistics, only need to call Add(gpair), instead of Add(gpair, info,",
    "ridx)",
    "same as add, reduce is used in All Reduce",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */",
    "gradient",
    "second order gradient",
    "1. calculate the total grad sum and hess sum",
    "2. create the grad stats of the node",
    "find the best split result of a serve row on the PS",
    "2. the fid here is the index in the sampled feature set, rather than the true feature id",
    "2.2. get the start index in histogram of this feature",
    "LOG.info(String.format(\"Histogram of feature[%d]: %s\", trueFid,",
    "Arrays.toString(curHistogram.getValues())));",
    "2.3. find the best split of current feature",
    "LOG.info(String.format(\"Best split of feature[%d]: value[%f], gain[%f]\",",
    "trueFid, curSplit.getFvalue(), curSplit.getLossChg()));",
    "2.4. update the best split result if possible",
    "find the best split result of one feature from a server row, used by the PS",
    "LOG.info(String.format(\"Find the best split for fid[%d] in server row, size[%d], startIdx[%d]\",",
    "fid, row.size(), startIdx));",
    "StringBuilder sb = new StringBuilder();",
    "for (int i = startIdx; i < startIdx + 2 * splitNum; i++) {",
    "sb.append(row.getData().get(i) + \", \");",
    "}",
    "LOG.info(\"Server row: \" + sb.toString());",
    "1. set the feature id",
    "splitEntry.setFid(fid);",
    "2. create the best left stats and right stats",
    "3. the gain of the root node",
    "LOG.info(String.format(\"Feature[%d]: sumGrad[%f], sumHess[%f], gain[%f]\",",
    "fid, rootStats.sumGrad, rootStats.sumHess, rootGain));",
    "4. create the temp left and right grad stats",
    "5. loop over all the data in histogram",
    "5.1. get the grad and hess of current hist bin",
    "5.2. check whether we can split with current left hessian",
    "right = root - left",
    "5.3. check whether we can split with current right hessian",
    "5.4. calculate the current loss gain",
    "5.5. check whether we should update the split result with current loss gain",
    "LOG.info(String.format(\"The current split: fid[%d], split index[%f], lossChg[%f]\",",
    "fid, (float) splitIdx, lossChg));",
    "here we set the fvalue=splitIndex, split value = sketches[splitIdx+1], the task use",
    "index to find fvalue",
    "LOG.info(String.format(\"Find new best split: fid[%d], fvalue[%f], lossChg[%f]\",",
    "splitEntry.fid, splitEntry.fvalue, splitEntry.lossChg));",
    "LOG.info(String.format(\"Left child of node[%d]: sumGrad[%f], sumHess[%f]; \" +",
    "\"right child of node[%d]: sumGrad[%f], sumHess[%f]; lossChg[%f]\",",
    "this.nid, leftStats.sumGrad, leftStats.sumHess,",
    "this.nid, rightStats.sumGrad, rightStats.sumHess, lossChg));",
    "5.6. if should update, also update the best left and right grad stats",
    "6. set the best left and right grad stats",
    "LOG.info(String.format(\"The best split for fid[%d], split feature[%d]: split index[%f], lossChg[%f], \"",
    "+",
    "\"leftSumGrad[%f], leftSumHess[%f], rightSumGrad[%f], rightSumHess[%f]\",",
    "fid, splitEntry.fid, splitEntry.fvalue, splitEntry.lossChg,",
    "splitEntry.leftGradStat.sumGrad, splitEntry.leftGradStat.sumHess,",
    "splitEntry.rightGradStat.sumGrad, splitEntry.rightGradStat.sumHess));",
    "grad.timesBy(-1.0 * lr);",
    "System.out.println(Arrays.toString(distArr));",
    "System.out.println(String.format(\"Epoch[%d] batch[%d], loss[%f]\", epoch, batch, loss));",
    "System.out.println(\"Start calculate loss and auc, sample number: \" + totalNum);",
    "System.out.println(\"Sort cost \" + (System.currentTimeMillis() - sortStartTime) + \"ms, Scores list size: \"",
    "+ scoresArray.length + \", sorted values:\" + scoresArray[0] + \",\"",
    "+ scoresArray[scoresArray.length / 5] + \",\" + scoresArray[scoresArray.length / 3] + \",\"",
    "+ scoresArray[scoresArray.length / 2] + \",\" + scoresArray[scoresArray.length - 1]);",
    "System.out.println(\"M = \" + M + \", N = \" + N + \", sigma = \" + sigma + \", AUC = \" + aucResult);",
    "System.out.println(String.format(\"Validation TP=%d, TN=%d, FP=%d, FN=%d\", truePos, trueNeg, falsePos,falseNeg));",
    "System.out.println(input + \" | \" + hashFunc.encode(input));",
    "step size for a tree",
    "number of class",
    "minimum loss change required for a split",
    "maximum depth of a tree",
    "number of features",
    "number of nonzero",
    "number of candidates split value",
    "----- the rest parameters are less important ----",
    "base instance weight",
    "minimum amount of hessian(weight) allowed in a child",
    "L2 regularization factor",
    "L1 regularization factor",
    "default direction choice",
    "maximum delta update we can add in weight estimation",
    "this parameter can be used to stabilize update",
    "default=0 means no constraint on weight delta",
    "whether we want to do subsample for row",
    "whether to subsample columns for each tree",
    "accuracy of sketch",
    "accuracy of sketch",
    "leaf vector size",
    "option for parallelization",
    "option to open cacheline optimization",
    "whether to not print info during training.",
    "return MathUtils.sqr(sumGrad) / (sumHess + regLambda);",
    "get feature type, 0:empty 1:all equal 2:real",
    "quantile sketch, size = featureNum * splitNum",
    "gradient histograms, size = treeNodeNum * featureNum * splitNum",
    "active tree nodes, size = pow(2, treeDepth) -1",
    "sampled features. size = treeNum * sampleRatio * featureNum",
    "split features, size = treeNum * treeNodeNum",
    "split values, size = treeNum * treeNodeNum",
    "split gains, size = treeNum * treeNodeNum",
    "node weights, size = treeNum * treeNodeNum",
    "node preds, size = treeNum * treeNodeNum",
    "if using PS to perform split",
    "maximum depth of the tree",
    "number of features used for tree construction",
    "minimum loss change required for a split, otherwise stop split",
    "----- the rest parameters are less important ----",
    "default direction choice",
    "whether we want to do sample data",
    "whether to sample columns during tree construction",
    "whether to use histogram for split",
    "number of histogram units",
    "whether to print info during training.",
    "----- the rest parameters are obtained after training ----",
    "total number of nodes",
    "number of deleted nodes */"
  ]
}